local printFunction = print;
local errorFunction = error;
local setmetatableFunction = setmetatable;
local rawSetFunction = rawset;
local rawgetFunction = rawget;
local pairsFunction = pairs;
local newproxyFunction = newproxy;
local getmetatableFunction = getmetatable;
local typeofFunction = typeof;
local assertFunction = assert;
local tostringFunction = tostring;
local bit32Library = bit32;
local bit32_bxor = bit32Library.bxor;
local bit32_rrotate = bit32Library.rrotate;
local band = bit32Library.band;
local bor = bit32Library.bor;
local bitXor = bit32Library.bxor;
local lshift = bit32Library.lshift;
local rshift = bit32Library.rshift;
local lrotate = bit32Library.lrotate;
local rrotate = bit32Library.rrotate;
local L_16 = bitXor;
local osClock = os.clock;
local osTimeFunction = os.time;
local stringFormat = string.format;
local stringSubFunction = string.sub;
local stringPackFunction = string.pack;
local bufferCopyFunction = buffer.copy;
local bufferFillFunction = buffer.fill;
local bufferCreateFunction = buffer.create;
local bufferFromStringFunction = buffer.fromstring;
local bufferLenFunction = buffer.len;
local bufferReadU8Function = buffer.readu8;
local bufferReadU16Function = buffer.readu16;
local bufferReadU32Function = buffer.readu32;
local bufferToStringFunction = buffer.tostring;
local bufferWriteStringFunction = buffer.writestring;
local bufferWriteU8Function = buffer.writeu8;
local bufferWriteU16Function = buffer.writeu16;
local bufferWriteU32Function = buffer.writeu32;
local mathFloor = math.floor;
local mathRandomFunction = math.random;
local environment = getfenv();
local engineType = _VERSION:find(("Lune\000"):gsub("\000", "")) and "\000Lune" or "Luau";
local httpRequestFunction = request;
local hardwareIdFunction = engineType == "\000Lune" and function()
    return "spxnso";
end or gethwid or function()
    return string.gsub(game:GetService("RbxAnalyticsService"):GetClientId(), "-", "");
end;
local startTime = osClock();
local infiniteLoopFunction = function()
    while true do
    end;
end;
local crashHandlerFunction = function(crashSource)
    printFunction("[" .. (crashSource .. "]: Crashed"));
    writefile("crash.log", "[" .. (crashSource .. "]: Crashed"));
    return ;
end;
local padding = 0;
local serviceId = function()
    crashHandlerFunction(0);
    while true do
    end;
end;
local isFlagEnabled = function()
    crashHandlerFunction(16);
    while true do
    end;
end;
local logFlagMessage = function(...)
    if not isFlagEnabled then
        printFunction(...);
    end;
    return ;
end;
local value54 = padding + 4.5;
local createTable = function(dataType)
    if dataType == "table" then
        local newTable = {};
        local randomValue = mathRandomFunction(2, 10);
        if randomValue < 2 and 10 < randomValue then
            crashHandlerFunction(1);
            while true do
            end;
        end;
        local loopStart = 1;
        local randomNumberGenerator = mathRandomFunction;
        for loopIndex = loopStart, randomNumberGenerator(2, 10), 1 do
            newTable[tostring({}) .. mathRandomFunction(1000000, 2000000)] = tostring({}) .. mathRandomFunction(1000000, 2000000);
        end;
        return newTable;
    end;
    local tableString = "table";
    return __JUNK_CODE__("table", __JUNK_CODE__("table"));
end;
local isSetEnvFailedFunction = function(environment)
    return not pcall(function()
        setfenv(environment, getfenv(environment));
        return ;
    end);
end;
local checkStackOverflow = function(wrappedCoroutine)
    for overflowLoopIndex = 1, 198, 1 do
        wrappedCoroutine = coroutine.wrap(wrappedCoroutine);
    end;
    local pcallSuccess2, pcallResult2 = pcall(wrappedCoroutine);
    if not pcallSuccess2 and string.find(pcallResult2, "C stack overflow") then
        return true;
    end;
    return false;
end;
local transformFunction = function(arg1)
    local counter = 0;
    local identityFunctionWrapper = function(L_72)
        return function(L_73)
            return L_73;
        end;
    end;
    return (function(inputParameter)
        counter = counter + 1;
        if counter == 82 then
            counter = 0;
            return inputParameter;
        end;
        return identityFunctionWrapper(function(value76)
            return value76;
        end)(inputParameter);
    end)(arg1);
end;
local loadFunction = function(arg2)
    local counter2 = 0;
    local indexWrapper = function(L_80)
        return {
            __index = function()
                return L_80;
            end
        };
    end;
    return (function(value82)
        counter2 = counter2 + 1;
        if counter2 == 82 then
            counter2 = 0;
            return value82;
        end;
        return indexWrapper({
            __index = function()
                return value82;
            end
        }).__index();
    end)(arg2);
end;
local counter = 0;
xpcall(tostring, function()
    counter = counter + 1;
    return ;
end);
xpcall(setmetatableFunction, function()
    counter = counter + 1;
    return ;
end);
xpcall(setfenv, function()
    counter = counter + 1;
    return ;
end);
xpcall(buffer.tostring, function()
    counter = counter + 1;
    return ;
end);
if counter ~= 4 then
    crashHandlerFunction(2);
    while true do
    end;
end;
local L_85 = value54 + 5.5 + 123;
local moduleCache = nil;
moduleCache = {
    cache = {},
    load = function(key)
        if not moduleCache.cache[key] then
            moduleCache.cache[key] = { c = moduleCache[key]() };
        end;
        return moduleCache.cache[key].c;
    end,
    a = function()
        return {
            ["\000generateSeed"] = function()
                local osTime = os.time();
                local osClock2 = os.clock();
                local randomNumber = math.floor(math.random() * 1000000);
                return (osTime * 1664525 + osClock2 + randomNumber) % 4294967296;
            end,
            ["\000lcg"] = function(L_91, loopCount, minValue, maxValue)
                local randomValues = {};
                local seed = L_91;
                for i = 1, loopCount, 1 do
                    seed = (1664525 * seed + 1013904223) % 4294967296;
                    randomValues[i] = minValue + seed % (maxValue - minValue + 1);
                end;
                return randomValues;
            end,
            ["\000sign"] = function(L_98, L_99)
                return L_98 + (#L_99 % 1000) ^ 2;
            end
        };
    end,
    b = function()
        return {
            ["\000AES"] = function(unknownValue)
                local buffer131072 = bufferCreateFunction(131072);
                local buffer65536_1 = bufferCreateFunction(65536);
                local buffer65536_2 = bufferCreateFunction(65536);
                local buffer65536_3 = bufferCreateFunction(65536);
                local buffer65536_4 = bufferCreateFunction(65536);
                local buffer65536_5 = bufferCreateFunction(65536);
                local cipherMethods = {
                    FwdMode = function(memoryCopyFunction, L_108, inputBuffer, outputBuffer, L_111, optionalBuffer)
                        local inputLengthMinus16 = bufferLenFunction(inputBuffer) - 16;
                        assertFunction(inputLengthMinus16 % 16 == 0, "Input length must be a multiple of 16 bytes");
                        local initializationVector = optionalBuffer or bufferCreateFunction(16);
                        assertFunction(bufferLenFunction(initializationVector) == 16, "Initialization vector must be 16 bytes long");
                        bufferWriteU32Function(outputBuffer, 0, bit32_bxor(bufferReadU32Function(inputBuffer, 0), bufferReadU32Function(initializationVector, 0)));
                        bufferWriteU32Function(outputBuffer, 4, bit32_bxor(bufferReadU32Function(inputBuffer, 4), bufferReadU32Function(initializationVector, 4)));
                        bufferWriteU32Function(outputBuffer, 8, bit32_bxor(bufferReadU32Function(inputBuffer, 8), bufferReadU32Function(initializationVector, 8)));
                        bufferWriteU32Function(outputBuffer, 12, bit32_bxor(bufferReadU32Function(inputBuffer, 12), bufferReadU32Function(initializationVector, 12)));
                        memoryCopyFunction(outputBuffer, 0, outputBuffer, 0);
                        for blockIndex = 16, inputLengthMinus16, 16 do
                            bufferWriteU32Function(outputBuffer, blockIndex, bit32_bxor(bufferReadU32Function(inputBuffer, blockIndex), bufferReadU32Function(outputBuffer, blockIndex - 16)));
                            bufferWriteU32Function(outputBuffer, blockIndex + 4, bit32_bxor(bufferReadU32Function(inputBuffer, blockIndex + 4), bufferReadU32Function(outputBuffer, blockIndex - 12)));
                            bufferWriteU32Function(outputBuffer, blockIndex + 8, bit32_bxor(bufferReadU32Function(inputBuffer, blockIndex + 8), bufferReadU32Function(outputBuffer, blockIndex - 8)));
                            bufferWriteU32Function(outputBuffer, blockIndex + 12, bit32_bxor(bufferReadU32Function(inputBuffer, blockIndex + 12), bufferReadU32Function(outputBuffer, blockIndex - 4)));
                            memoryCopyFunction(outputBuffer, blockIndex, outputBuffer, blockIndex);
                        end;
                        return ;
                    end,
                    InvMode = function(L_116, xorBlocks, dataBuffer, outputBuffer, L_120, optionalBuffer2)
                        local inputLengthMinus16_2 = bufferLenFunction(dataBuffer) - 16;
                        assertFunction(inputLengthMinus16_2 % 16 == 0, "Input length must be a multiple of 16 bytes");
                        local initializationVector = optionalBuffer2 or bufferCreateFunction(16);
                        assertFunction(bufferLenFunction(initializationVector) == 16, "Initialization vector must be 16 bytes long");
                        local block0 = bufferReadU32Function(dataBuffer, 0);
                        local block1 = bufferReadU32Function(dataBuffer, 4);
                        local block2 = bufferReadU32Function(dataBuffer, 8);
                        local block3 = bufferReadU32Function(dataBuffer, 12);
                        local value1 = nil;
                        local value2 = nil;
                        local value3 = nil;
                        local value4 = nil;
                        xorBlocks(dataBuffer, 0, outputBuffer, 0);
                        bufferWriteU32Function(outputBuffer, 0, bit32_bxor(bufferReadU32Function(outputBuffer, 0), bufferReadU32Function(initializationVector, 0)));
                        bufferWriteU32Function(outputBuffer, 4, bit32_bxor(bufferReadU32Function(outputBuffer, 4), bufferReadU32Function(initializationVector, 4)));
                        bufferWriteU32Function(outputBuffer, 8, bit32_bxor(bufferReadU32Function(outputBuffer, 8), bufferReadU32Function(initializationVector, 8)));
                        bufferWriteU32Function(outputBuffer, 12, bit32_bxor(bufferReadU32Function(outputBuffer, 12), bufferReadU32Function(initializationVector, 12)));
                        for blockOffset = 16, inputLengthMinus16_2, 16 do
                            local currentBlock0 = bufferReadU32Function(dataBuffer, blockOffset);
                            local currentBlock1 = bufferReadU32Function(dataBuffer, blockOffset + 4);
                            local currentBlock2 = bufferReadU32Function(dataBuffer, blockOffset + 8);
                            local currentBlock3 = bufferReadU32Function(dataBuffer, blockOffset + 12);
                            xorBlocks(dataBuffer, blockOffset, outputBuffer, blockOffset);
                            bufferWriteU32Function(outputBuffer, blockOffset, bit32_bxor(bufferReadU32Function(outputBuffer, blockOffset), block0));
                            bufferWriteU32Function(outputBuffer, blockOffset + 4, bit32_bxor(bufferReadU32Function(outputBuffer, blockOffset + 4), block1));
                            bufferWriteU32Function(outputBuffer, blockOffset + 8, bit32_bxor(bufferReadU32Function(outputBuffer, blockOffset + 8), block2));
                            bufferWriteU32Function(outputBuffer, blockOffset + 12, bit32_bxor(bufferReadU32Function(outputBuffer, blockOffset + 12), block3));
                            block0 = currentBlock0;
                            block1 = currentBlock1;
                            block2 = currentBlock2;
                            block3 = currentBlock3;
                        end;
                        return ;
                    end
                };
                local paddingFunctions = {
                    Pad = function(inputBuffer, outputBuffer, alignment)
                        local inputLength = bufferLenFunction(inputBuffer);
                        local paddedLength = inputLength - inputLength % alignment;
                        if outputBuffer then
                            assertFunction(bufferLenFunction(outputBuffer) >= inputLength + alignment, "Output buffer out of bounds");
                        else
                            outputBuffer = bufferCreateFunction(paddedLength + alignment);
                        end;
                        local paddingSize = alignment - inputLength % alignment;
                        bufferCopyFunction(outputBuffer, 0, inputBuffer, 0, inputLength);
                        bufferFillFunction(outputBuffer, inputLength, paddingSize, paddingSize);
                        return outputBuffer;
                    end,
                    Unpad = function(inputData, outputData, maxPadding)
                        local dataLength = bufferLenFunction(inputData);
                        local paddingValue = bufferReadU8Function(inputData, dataLength - 1);
                        local unpaddedLength = dataLength - paddingValue;
                        assertFunction(0 < paddingValue and paddingValue <= maxPadding, "Got unexpected padding");
                        for paddingIndex = unpaddedLength, dataLength - 2, 1 do
                            if bufferReadU8Function(inputData, paddingIndex) ~= paddingValue then
                                errorFunction("Got unexpected padding");
                            end;
                        end;
                        if outputData then
                            assertFunction(bufferLenFunction(outputData) >= unpaddedLength, "Output buffer out of bounds");
                        else
                            outputData = bufferCreateFunction(unpaddedLength);
                        end;
                        bufferCopyFunction(outputData, 0, inputData, 0, unpaddedLength);
                        return outputData;
                    end,
                    Overwrite = nil
                };
                local processBlocks = function(sourceBuffer, offset, destinationBuffer, shouldCopy)
                    if shouldCopy then
                        bufferCopyFunction(destinationBuffer, 0, sourceBuffer, 0, offset);
                    else
                        bufferWriteStringFunction(destinationBuffer, 0, sourceBuffer, offset);
                    end;
                    local roundConstant = bit32_rrotate(bufferReadU32Function(destinationBuffer, offset - 4), 8);
                    local multiplier = 0.5;
                    if offset == 32 then
                        for offset1 = 32, 192, 32 do
                            multiplier = multiplier * 2 % 229;
                            local value159 = bit32_bxor(bufferReadU32Function(destinationBuffer, offset1 - 32), bufferReadU16Function(buffer131072, mathFloor(roundConstant / 65536) * 2) * 65536 + bufferReadU16Function(buffer131072, roundConstant % 65536 * 2), multiplier);
                            bufferWriteU32Function(destinationBuffer, offset1, value159);
                            local value160 = bit32_bxor(bufferReadU32Function(destinationBuffer, offset1 - 28), value159);
                            bufferWriteU32Function(destinationBuffer, offset1 + 4, value160);
                            local value161 = bit32_bxor(bufferReadU32Function(destinationBuffer, offset1 - 24), value160);
                            bufferWriteU32Function(destinationBuffer, offset1 + 8, value161);
                            local value1 = bit32_bxor(bufferReadU32Function(destinationBuffer, offset1 - 20), value161);
                            bufferWriteU32Function(destinationBuffer, offset1 + 12, value1);
                            local value2 = bit32_bxor(bufferReadU32Function(destinationBuffer, offset1 - 16), bufferReadU16Function(buffer131072, mathFloor(value1 / 65536) * 2) * 65536 + bufferReadU16Function(buffer131072, value1 % 65536 * 2));
                            bufferWriteU32Function(destinationBuffer, offset1 + 16, value2);
                            local value3 = bit32_bxor(bufferReadU32Function(destinationBuffer, offset1 - 12), value2);
                            bufferWriteU32Function(destinationBuffer, offset1 + 20, value3);
                            local value4 = bit32_bxor(bufferReadU32Function(destinationBuffer, offset1 - 8), value3);
                            bufferWriteU32Function(destinationBuffer, offset1 + 24, value4);
                            local value6 = bit32_bxor(bufferReadU32Function(destinationBuffer, offset1 - 4), value4);
                            bufferWriteU32Function(destinationBuffer, offset1 + 28, value6);
                            roundConstant = bit32_rrotate(value6, 8);
                        end;
                        local value7 = bit32_bxor(bufferReadU32Function(destinationBuffer, 192), bufferReadU16Function(buffer131072, mathFloor(roundConstant / 65536) * 2) * 65536 + bufferReadU16Function(buffer131072, roundConstant % 65536 * 2), 64);
                        bufferWriteU32Function(destinationBuffer, 224, value7);
                        local value8 = bit32_bxor(bufferReadU32Function(destinationBuffer, 196), value7);
                        bufferWriteU32Function(destinationBuffer, 228, value8);
                        local value9 = bit32_bxor(bufferReadU32Function(destinationBuffer, 200), value8);
                        bufferWriteU32Function(destinationBuffer, 232, value9);
                        bufferWriteU32Function(destinationBuffer, 236, bit32_bxor(bufferReadU32Function(destinationBuffer, 204), value9));
                    elseif offset == 24 then
                        for offset2 = 24, 168, 24 do
                            multiplier = multiplier * 2 % 229;
                            local value5 = bit32_bxor(bufferReadU32Function(destinationBuffer, offset2 - 24), bufferReadU16Function(buffer131072, mathFloor(roundConstant / 65536) * 2) * 65536 + bufferReadU16Function(buffer131072, roundConstant % 65536 * 2), multiplier);
                            bufferWriteU32Function(destinationBuffer, offset2, value5);
                            local value6 = bit32_bxor(bufferReadU32Function(destinationBuffer, offset2 - 20), value5);
                            bufferWriteU32Function(destinationBuffer, offset2 + 4, value6);
                            local value7 = bit32_bxor(bufferReadU32Function(destinationBuffer, offset2 - 16), value6);
                            bufferWriteU32Function(destinationBuffer, offset2 + 8, value7);
                            local value8 = bit32_bxor(bufferReadU32Function(destinationBuffer, offset2 - 12), value7);
                            bufferWriteU32Function(destinationBuffer, offset2 + 12, value8);
                            local value9 = bit32_bxor(bufferReadU32Function(destinationBuffer, offset2 - 8), value8);
                            bufferWriteU32Function(destinationBuffer, offset2 + 16, value9);
                            local value10 = bit32_bxor(bufferReadU32Function(destinationBuffer, offset2 - 4), value9);
                            bufferWriteU32Function(destinationBuffer, offset2 + 20, value10);
                            roundConstant = bit32_rrotate(value10, 8);
                        end;
                        local value11 = bit32_bxor(bufferReadU32Function(destinationBuffer, 168), bufferReadU16Function(buffer131072, mathFloor(roundConstant / 65536) * 2) * 65536 + bufferReadU16Function(buffer131072, roundConstant % 65536 * 2), 128);
                        bufferWriteU32Function(destinationBuffer, 192, value11);
                        local value12 = bit32_bxor(bufferReadU32Function(destinationBuffer, 172), value11);
                        bufferWriteU32Function(destinationBuffer, 196, value12);
                        local value13 = bit32_bxor(bufferReadU32Function(destinationBuffer, 176), value12);
                        bufferWriteU32Function(destinationBuffer, 200, value13);
                        bufferWriteU32Function(destinationBuffer, 204, bit32_bxor(bufferReadU32Function(destinationBuffer, 180), value13));
                    else
                        for offset3 = 16, 144, 16 do
                            multiplier = multiplier * 2 % 229;
                            local value10 = bit32_bxor(bufferReadU32Function(destinationBuffer, offset3 - 16), bufferReadU16Function(buffer131072, mathFloor(roundConstant / 65536) * 2) * 65536 + bufferReadU16Function(buffer131072, roundConstant % 65536 * 2), multiplier);
                            bufferWriteU32Function(destinationBuffer, offset3, value10);
                            local value11 = bit32_bxor(bufferReadU32Function(destinationBuffer, offset3 - 12), value10);
                            bufferWriteU32Function(destinationBuffer, offset3 + 4, value11);
                            local value12 = bit32_bxor(bufferReadU32Function(destinationBuffer, offset3 - 8), value11);
                            bufferWriteU32Function(destinationBuffer, offset3 + 8, value12);
                            local value14 = bit32_bxor(bufferReadU32Function(destinationBuffer, offset3 - 4), value12);
                            bufferWriteU32Function(destinationBuffer, offset3 + 12, value14);
                            roundConstant = bit32_rrotate(value14, 8);
                        end;
                        local value15 = bit32_bxor(bufferReadU32Function(destinationBuffer, 144), bufferReadU16Function(buffer131072, mathFloor(roundConstant / 65536) * 2) * 65536 + bufferReadU16Function(buffer131072, roundConstant % 65536 * 2), 54);
                        bufferWriteU32Function(destinationBuffer, 160, value15);
                        local value16 = bit32_bxor(bufferReadU32Function(destinationBuffer, 148), value15);
                        bufferWriteU32Function(destinationBuffer, 164, value16);
                        local value17 = bit32_bxor(bufferReadU32Function(destinationBuffer, 152), value16);
                        bufferWriteU32Function(destinationBuffer, 168, value17);
                        bufferWriteU32Function(destinationBuffer, 172, bit32_bxor(bufferReadU32Function(destinationBuffer, 156), value17));
                    end;
                    return destinationBuffer;
                end;
                local processDataFunction = function(dataArray2, maxOffset, dataArray1, index1, arg1, arg2)
                    local data1 = bit32_bxor(bufferReadU8Function(dataArray1, index1), bufferReadU8Function(dataArray2, 0));
                    local data2 = bit32_bxor(bufferReadU8Function(dataArray1, index1 + 1), bufferReadU8Function(dataArray2, 1));
                    local data3 = bit32_bxor(bufferReadU8Function(dataArray1, index1 + 2), bufferReadU8Function(dataArray2, 2));
                    local data4 = bit32_bxor(bufferReadU8Function(dataArray1, index1 + 3), bufferReadU8Function(dataArray2, 3));
                    local data5 = bit32_bxor(bufferReadU8Function(dataArray1, index1 + 4), bufferReadU8Function(dataArray2, 4));
                    local data6 = bit32_bxor(bufferReadU8Function(dataArray1, index1 + 5), bufferReadU8Function(dataArray2, 5));
                    local data7 = bit32_bxor(bufferReadU8Function(dataArray1, index1 + 6), bufferReadU8Function(dataArray2, 6));
                    local data8 = bit32_bxor(bufferReadU8Function(dataArray1, index1 + 7), bufferReadU8Function(dataArray2, 7));
                    local data9 = bit32_bxor(bufferReadU8Function(dataArray1, index1 + 8), bufferReadU8Function(dataArray2, 8));
                    local data10 = bit32_bxor(bufferReadU8Function(dataArray1, index1 + 9), bufferReadU8Function(dataArray2, 9));
                    local data11 = bit32_bxor(bufferReadU8Function(dataArray1, index1 + 10), bufferReadU8Function(dataArray2, 10));
                    local data12 = bit32_bxor(bufferReadU8Function(dataArray1, index1 + 11), bufferReadU8Function(dataArray2, 11));
                    local data13 = bit32_bxor(bufferReadU8Function(dataArray1, index1 + 12), bufferReadU8Function(dataArray2, 12));
                    local data14 = bit32_bxor(bufferReadU8Function(dataArray1, index1 + 13), bufferReadU8Function(dataArray2, 13));
                    local byte14 = bit32_bxor(bufferReadU8Function(dataArray1, index1 + 14), bufferReadU8Function(dataArray2, 14));
                    local byte15 = bit32_bxor(bufferReadU8Function(dataArray1, index1 + 15), bufferReadU8Function(dataArray2, 15));
                    local value1 = data1 * 256 + data6;
                    local value2 = data6 * 256 + data11;
                    local value3 = data11 * 256 + byte15;
                    local colorValue1 = byte15 * 256 + data1;
                    local colorValue2 = data5 * 256 + data10;
                    local colorValue3 = data10 * 256 + byte14;
                    local colorValue4 = byte14 * 256 + data4;
                    local colorValue5 = data4 * 256 + data5;
                    local colorValue6 = data9 * 256 + data14;
                    local colorValue7 = data14 * 256 + data3;
                    local colorValue8 = data3 * 256 + data8;
                    local colorValue9 = data8 * 256 + data9;
                    local colorValue10 = data13 * 256 + data2;
                    local colorValue11 = data2 * 256 + data7;
                    local colorValue12 = data7 * 256 + data12;
                    local colorValue13 = data12 * 256 + data13;
                    for i = 16, maxOffset, 16 do
                        local combinedValue1 = bit32_bxor(bufferReadU8Function(buffer65536_1, value1), bufferReadU8Function(buffer65536_2, value3), bufferReadU8Function(dataArray2, i));
                        local color1 = bit32_bxor(bufferReadU8Function(buffer65536_1, value2), bufferReadU8Function(buffer65536_2, colorValue1), bufferReadU8Function(dataArray2, i + 1));
                        local color2 = bit32_bxor(bufferReadU8Function(buffer65536_1, value3), bufferReadU8Function(buffer65536_2, value1), bufferReadU8Function(dataArray2, i + 2));
                        local color3 = bit32_bxor(bufferReadU8Function(buffer65536_1, colorValue1), bufferReadU8Function(buffer65536_2, value2), bufferReadU8Function(dataArray2, i + 3));
                        local colorPaletteIndex1 = bit32_bxor(bufferReadU8Function(buffer65536_1, colorValue2), bufferReadU8Function(buffer65536_2, colorValue4), bufferReadU8Function(dataArray2, i + 4));
                        local colorPaletteIndex2 = bit32_bxor(bufferReadU8Function(buffer65536_1, colorValue3), bufferReadU8Function(buffer65536_2, colorValue5), bufferReadU8Function(dataArray2, i + 5));
                        local colorPaletteIndex3 = bit32_bxor(bufferReadU8Function(buffer65536_1, colorValue4), bufferReadU8Function(buffer65536_2, colorValue2), bufferReadU8Function(dataArray2, i + 6));
                        local colorPaletteIndex4 = bit32_bxor(bufferReadU8Function(buffer65536_1, colorValue5), bufferReadU8Function(buffer65536_2, colorValue3), bufferReadU8Function(dataArray2, i + 7));
                        local colorPaletteIndex5 = bit32_bxor(bufferReadU8Function(buffer65536_1, colorValue6), bufferReadU8Function(buffer65536_2, colorValue8), bufferReadU8Function(dataArray2, i + 8));
                        local colorPaletteIndex6 = bit32_bxor(bufferReadU8Function(buffer65536_1, colorValue7), bufferReadU8Function(buffer65536_2, colorValue9), bufferReadU8Function(dataArray2, i + 9));
                        local colorPaletteIndex7 = bit32_bxor(bufferReadU8Function(buffer65536_1, colorValue8), bufferReadU8Function(buffer65536_2, colorValue6), bufferReadU8Function(dataArray2, i + 10));
                        local colorPaletteIndex8 = bit32_bxor(bufferReadU8Function(buffer65536_1, colorValue9), bufferReadU8Function(buffer65536_2, colorValue7), bufferReadU8Function(dataArray2, i + 11));
                        local colorPaletteIndex9 = bit32_bxor(bufferReadU8Function(buffer65536_1, colorValue10), bufferReadU8Function(buffer65536_2, colorValue12), bufferReadU8Function(dataArray2, i + 12));
                        local colorPaletteIndex10 = bit32_bxor(bufferReadU8Function(buffer65536_1, colorValue11), bufferReadU8Function(buffer65536_2, colorValue13), bufferReadU8Function(dataArray2, i + 13));
                        local colorPaletteIndex11 = bit32_bxor(bufferReadU8Function(buffer65536_1, colorValue12), bufferReadU8Function(buffer65536_2, colorValue10), bufferReadU8Function(dataArray2, i + 14));
                        local colorPaletteIndex12 = bit32_bxor(bufferReadU8Function(buffer65536_1, colorValue13), bufferReadU8Function(buffer65536_2, colorValue11), bufferReadU8Function(dataArray2, i + 15));
                        value1, value2, value3, colorValue1, colorValue2, colorValue3, colorValue4, colorValue5, colorValue6, colorValue7, colorValue8, colorValue9, colorValue10, colorValue11, colorValue12, colorValue13 = combinedValue1 * 256 + colorPaletteIndex2, colorPaletteIndex2 * 256 + colorPaletteIndex7, colorPaletteIndex7 * 256 + colorPaletteIndex12, colorPaletteIndex12 * 256 + combinedValue1, colorPaletteIndex1 * 256 + colorPaletteIndex6, colorPaletteIndex6 * 256 + colorPaletteIndex11, colorPaletteIndex11 * 256 + color3, color3 * 256 + colorPaletteIndex1, colorPaletteIndex5 * 256 + colorPaletteIndex10, colorPaletteIndex10 * 256 + color2, color2 * 256 + colorPaletteIndex4, colorPaletteIndex4 * 256 + colorPaletteIndex5, colorPaletteIndex9 * 256 + color1, color1 * 256 + colorPaletteIndex3, colorPaletteIndex3 * 256 + colorPaletteIndex8, colorPaletteIndex8 * 256 + colorPaletteIndex9;
                    end;
                    bufferWriteU32Function(arg1, arg2, bit32_bxor(bufferReadU16Function(buffer131072, bit32_bxor(bufferReadU8Function(buffer65536_1, colorValue13), bufferReadU8Function(buffer65536_2, colorValue11), bufferReadU8Function(dataArray2, maxOffset + 31)) * 512 + bit32_bxor(bufferReadU8Function(buffer65536_1, colorValue8), bufferReadU8Function(buffer65536_2, colorValue6), bufferReadU8Function(dataArray2, maxOffset + 26)) * 2) * 65536 + bufferReadU16Function(buffer131072, bit32_bxor(bufferReadU8Function(buffer65536_1, colorValue3), bufferReadU8Function(buffer65536_2, colorValue5), bufferReadU8Function(dataArray2, maxOffset + 21)) * 512 + bit32_bxor(bufferReadU8Function(buffer65536_1, value1), bufferReadU8Function(buffer65536_2, value3), bufferReadU8Function(dataArray2, maxOffset + 16)) * 2), bufferReadU32Function(dataArray2, maxOffset + 32)));
                    bufferWriteU32Function(arg1, arg2 + 4, bit32_bxor(bufferReadU16Function(buffer131072, bit32_bxor(bufferReadU8Function(buffer65536_1, colorValue1), bufferReadU8Function(buffer65536_2, value2), bufferReadU8Function(dataArray2, maxOffset + 19)) * 512 + bit32_bxor(bufferReadU8Function(buffer65536_1, colorValue12), bufferReadU8Function(buffer65536_2, colorValue10), bufferReadU8Function(dataArray2, maxOffset + 30)) * 2) * 65536 + bufferReadU16Function(buffer131072, bit32_bxor(bufferReadU8Function(buffer65536_1, colorValue7), bufferReadU8Function(buffer65536_2, colorValue9), bufferReadU8Function(dataArray2, maxOffset + 25)) * 512 + bit32_bxor(bufferReadU8Function(buffer65536_1, colorValue2), bufferReadU8Function(buffer65536_2, colorValue4), bufferReadU8Function(dataArray2, maxOffset + 20)) * 2), bufferReadU32Function(dataArray2, maxOffset + 36)));
                    bufferWriteU32Function(arg1, arg2 + 8, bit32_bxor(bufferReadU16Function(buffer131072, bit32_bxor(bufferReadU8Function(buffer65536_1, colorValue5), bufferReadU8Function(buffer65536_2, colorValue3), bufferReadU8Function(dataArray2, maxOffset + 23)) * 512 + bit32_bxor(bufferReadU8Function(buffer65536_1, value3), bufferReadU8Function(buffer65536_2, value1), bufferReadU8Function(dataArray2, maxOffset + 18)) * 2) * 65536 + bufferReadU16Function(buffer131072, bit32_bxor(bufferReadU8Function(buffer65536_1, colorValue11), bufferReadU8Function(buffer65536_2, colorValue13), bufferReadU8Function(dataArray2, maxOffset + 29)) * 512 + bit32_bxor(bufferReadU8Function(buffer65536_1, colorValue6), bufferReadU8Function(buffer65536_2, colorValue8), bufferReadU8Function(dataArray2, maxOffset + 24)) * 2), bufferReadU32Function(dataArray2, maxOffset + 40)));
                    bufferWriteU32Function(arg1, arg2 + 12, bit32_bxor(bufferReadU16Function(buffer131072, bit32_bxor(bufferReadU8Function(buffer65536_1, colorValue9), bufferReadU8Function(buffer65536_2, colorValue7), bufferReadU8Function(dataArray2, maxOffset + 27)) * 512 + bit32_bxor(bufferReadU8Function(buffer65536_1, colorValue4), bufferReadU8Function(buffer65536_2, colorValue2), bufferReadU8Function(dataArray2, maxOffset + 22)) * 2) * 65536 + bufferReadU16Function(buffer131072, bit32_bxor(bufferReadU8Function(buffer65536_1, value2), bufferReadU8Function(buffer65536_2, colorValue1), bufferReadU8Function(dataArray2, maxOffset + 17)) * 512 + bit32_bxor(bufferReadU8Function(buffer65536_1, colorValue10), bufferReadU8Function(buffer65536_2, colorValue12), bufferReadU8Function(dataArray2, maxOffset + 28)) * 2), bufferReadU32Function(dataArray2, maxOffset + 44)));
                    return ;
                end;
                local processData = function(dataArray4, loopStart, dataArray3, index2, unknownValue1, offset)
                    local dataByte1 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataArray3, index2) * 256 + bufferReadU8Function(dataArray4, loopStart + 32)), bufferReadU8Function(dataArray4, loopStart + 16));
                    local dataByte2 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataArray3, index2 + 13) * 256 + bufferReadU8Function(dataArray4, loopStart + 45)), bufferReadU8Function(dataArray4, loopStart + 17));
                    local dataByte3 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataArray3, index2 + 10) * 256 + bufferReadU8Function(dataArray4, loopStart + 42)), bufferReadU8Function(dataArray4, loopStart + 18));
                    local dataByte4 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataArray3, index2 + 7) * 256 + bufferReadU8Function(dataArray4, loopStart + 39)), bufferReadU8Function(dataArray4, loopStart + 19));
                    local dataByte5 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataArray3, index2 + 4) * 256 + bufferReadU8Function(dataArray4, loopStart + 36)), bufferReadU8Function(dataArray4, loopStart + 20));
                    local dataByte6 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataArray3, index2 + 1) * 256 + bufferReadU8Function(dataArray4, loopStart + 33)), bufferReadU8Function(dataArray4, loopStart + 21));
                    local dataByte7 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataArray3, index2 + 14) * 256 + bufferReadU8Function(dataArray4, loopStart + 46)), bufferReadU8Function(dataArray4, loopStart + 22));
                    local dataByte8 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataArray3, index2 + 11) * 256 + bufferReadU8Function(dataArray4, loopStart + 43)), bufferReadU8Function(dataArray4, loopStart + 23));
                    local dataByte9 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataArray3, index2 + 8) * 256 + bufferReadU8Function(dataArray4, loopStart + 40)), bufferReadU8Function(dataArray4, loopStart + 24));
                    local dataByte10 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataArray3, index2 + 5) * 256 + bufferReadU8Function(dataArray4, loopStart + 37)), bufferReadU8Function(dataArray4, loopStart + 25));
                    local dataByte11 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataArray3, index2 + 2) * 256 + bufferReadU8Function(dataArray4, loopStart + 34)), bufferReadU8Function(dataArray4, loopStart + 26));
                    local dataByte12 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataArray3, index2 + 15) * 256 + bufferReadU8Function(dataArray4, loopStart + 47)), bufferReadU8Function(dataArray4, loopStart + 27));
                    local dataByte13 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataArray3, index2 + 12) * 256 + bufferReadU8Function(dataArray4, loopStart + 44)), bufferReadU8Function(dataArray4, loopStart + 28));
                    local dataByte14 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataArray3, index2 + 9) * 256 + bufferReadU8Function(dataArray4, loopStart + 41)), bufferReadU8Function(dataArray4, loopStart + 29));
                    local dataByte15 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataArray3, index2 + 6) * 256 + bufferReadU8Function(dataArray4, loopStart + 38)), bufferReadU8Function(dataArray4, loopStart + 30));
                    local dataByte16 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataArray3, index2 + 3) * 256 + bufferReadU8Function(dataArray4, loopStart + 35)), bufferReadU8Function(dataArray4, loopStart + 31));
                    local combinedData1 = dataByte1 * 256 + dataByte2;
                    local combinedData2 = dataByte2 * 256 + dataByte3;
                    local combinedData3 = dataByte3 * 256 + dataByte4;
                    local colorValue1 = dataByte4 * 256 + dataByte1;
                    local colorValue2 = dataByte5 * 256 + dataByte6;
                    local colorValue3 = dataByte6 * 256 + dataByte7;
                    local colorValue4 = dataByte7 * 256 + dataByte8;
                    local colorValue5 = dataByte8 * 256 + dataByte5;
                    local colorValue6 = dataByte9 * 256 + dataByte10;
                    local colorValue7 = dataByte10 * 256 + dataByte11;
                    local colorValue8 = dataByte11 * 256 + dataByte12;
                    local colorValue9 = dataByte12 * 256 + dataByte9;
                    local colorValue10 = dataByte13 * 256 + dataByte14;
                    local colorValue11 = dataByte14 * 256 + dataByte15;
                    local colorValue12 = dataByte15 * 256 + dataByte16;
                    local colorValue13 = dataByte16 * 256 + dataByte13;
                    for i = loopStart, 16, -16 do
                        local processedValue1 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, combinedData1) * 256 + bufferReadU8Function(buffer65536_5, combinedData3)), bufferReadU8Function(dataArray4, i));
                        local colorComponent2 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, colorValue11) * 256 + bufferReadU8Function(buffer65536_5, colorValue13)), bufferReadU8Function(dataArray4, i + 1));
                        local value1 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, colorValue8) * 256 + bufferReadU8Function(buffer65536_5, colorValue6)), bufferReadU8Function(dataArray4, i + 2));
                        local value2 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, colorValue5) * 256 + bufferReadU8Function(buffer65536_5, colorValue3)), bufferReadU8Function(dataArray4, i + 3));
                        local value3 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, colorValue2) * 256 + bufferReadU8Function(buffer65536_5, colorValue4)), bufferReadU8Function(dataArray4, i + 4));
                        local value4 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, combinedData2) * 256 + bufferReadU8Function(buffer65536_5, colorValue1)), bufferReadU8Function(dataArray4, i + 5));
                        local value5 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, colorValue12) * 256 + bufferReadU8Function(buffer65536_5, colorValue10)), bufferReadU8Function(dataArray4, i + 6));
                        local value6 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, colorValue9) * 256 + bufferReadU8Function(buffer65536_5, colorValue7)), bufferReadU8Function(dataArray4, i + 7));
                        local value7 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, colorValue6) * 256 + bufferReadU8Function(buffer65536_5, colorValue8)), bufferReadU8Function(dataArray4, i + 8));
                        local value8 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, colorValue3) * 256 + bufferReadU8Function(buffer65536_5, colorValue5)), bufferReadU8Function(dataArray4, i + 9));
                        local value9 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, combinedData3) * 256 + bufferReadU8Function(buffer65536_5, combinedData1)), bufferReadU8Function(dataArray4, i + 10));
                        local value10 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, colorValue13) * 256 + bufferReadU8Function(buffer65536_5, colorValue11)), bufferReadU8Function(dataArray4, i + 11));
                        local value11 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, colorValue10) * 256 + bufferReadU8Function(buffer65536_5, colorValue12)), bufferReadU8Function(dataArray4, i + 12));
                        local value12 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, colorValue7) * 256 + bufferReadU8Function(buffer65536_5, colorValue9)), bufferReadU8Function(dataArray4, i + 13));
                        local value13 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, colorValue4) * 256 + bufferReadU8Function(buffer65536_5, colorValue2)), bufferReadU8Function(dataArray4, i + 14));
                        local value14 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, colorValue1) * 256 + bufferReadU8Function(buffer65536_5, combinedData2)), bufferReadU8Function(dataArray4, i + 15));
                        combinedData1, combinedData2, combinedData3, colorValue1, colorValue2, colorValue3, colorValue4, colorValue5, colorValue6, colorValue7, colorValue8, colorValue9, colorValue10, colorValue11, colorValue12, colorValue13 = processedValue1 * 256 + colorComponent2, colorComponent2 * 256 + value1, value1 * 256 + value2, value2 * 256 + processedValue1, value3 * 256 + value4, value4 * 256 + value5, value5 * 256 + value6, value6 * 256 + value3, value7 * 256 + value8, value8 * 256 + value9, value9 * 256 + value10, value10 * 256 + value7, value11 * 256 + value12, value12 * 256 + value13, value13 * 256 + value14, value14 * 256 + value11;
                    end;
                    bufferWriteU32Function(unknownValue1, offset, bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, colorValue5) * 256 + bufferReadU8Function(buffer65536_5, colorValue3)), bufferReadU8Function(dataArray4, 3)) * 16777216 + bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, colorValue8) * 256 + bufferReadU8Function(buffer65536_5, colorValue6)), bufferReadU8Function(dataArray4, 2)) * 65536 + bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, colorValue11) * 256 + bufferReadU8Function(buffer65536_5, colorValue13)), bufferReadU8Function(dataArray4, 1)) * 256 + bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, combinedData1) * 256 + bufferReadU8Function(buffer65536_5, combinedData3)), bufferReadU8Function(dataArray4, 0)));
                    bufferWriteU32Function(unknownValue1, offset + 4, bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, colorValue9) * 256 + bufferReadU8Function(buffer65536_5, colorValue7)), bufferReadU8Function(dataArray4, 7)) * 16777216 + bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, colorValue12) * 256 + bufferReadU8Function(buffer65536_5, colorValue10)), bufferReadU8Function(dataArray4, 6)) * 65536 + bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, combinedData2) * 256 + bufferReadU8Function(buffer65536_5, colorValue1)), bufferReadU8Function(dataArray4, 5)) * 256 + bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, colorValue2) * 256 + bufferReadU8Function(buffer65536_5, colorValue4)), bufferReadU8Function(dataArray4, 4)));
                    bufferWriteU32Function(unknownValue1, offset + 8, bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, colorValue13) * 256 + bufferReadU8Function(buffer65536_5, colorValue11)), bufferReadU8Function(dataArray4, 11)) * 16777216 + bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, combinedData3) * 256 + bufferReadU8Function(buffer65536_5, combinedData1)), bufferReadU8Function(dataArray4, 10)) * 65536 + bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, colorValue3) * 256 + bufferReadU8Function(buffer65536_5, colorValue5)), bufferReadU8Function(dataArray4, 9)) * 256 + bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, colorValue6) * 256 + bufferReadU8Function(buffer65536_5, colorValue8)), bufferReadU8Function(dataArray4, 8)));
                    bufferWriteU32Function(unknownValue1, offset + 12, bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, colorValue1) * 256 + bufferReadU8Function(buffer65536_5, combinedData2)), bufferReadU8Function(dataArray4, 15)) * 16777216 + bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, colorValue4) * 256 + bufferReadU8Function(buffer65536_5, colorValue2)), bufferReadU8Function(dataArray4, 14)) * 65536 + bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, colorValue7) * 256 + bufferReadU8Function(buffer65536_5, colorValue9)), bufferReadU8Function(dataArray4, 13)) * 256 + bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, colorValue10) * 256 + bufferReadU8Function(buffer65536_5, colorValue12)), bufferReadU8Function(dataArray4, 12)));
                    return ;
                end;
                local buffer1 = bufferCreateFunction(256);
                local buffer2 = bufferCreateFunction(256);
                local buffer3 = bufferCreateFunction(256);
                local buffer1 = bufferCreateFunction(256);
                local buffer2 = bufferCreateFunction(256);
                local state = 1;
                local key = 1;
                local someValue1 = nil;
                local galoisMultiply = function(someValue2, data)
                    local result = 0;
                    for i = 0, 7, 1 do
                        if data % 2 == 1 then
                            result = bit32_bxor(result, someValue2);
                        end;
                        someValue2 = if not (128 <= someValue2) then someValue2 * 2 % 256 else bit32_bxor(someValue2 * 2 % 256, 27);
                        data = mathFloor(data / 2);
                    end;
                    return result;
                end;
                bufferWriteU8Function(buffer1, 0, 99);
                for i = 1, 255, 1 do
                    state = bit32_bxor(state, state * 2, state < 128 and 0 or 27) % 256;
                    local temp1 = bit32_bxor(key, key * 2);
                    local temp2 = bit32_bxor(temp1, temp1 * 4);
                    key = bit32_bxor(temp2, temp2 * 16) % 256;
                    if 128 <= key then
                        key = bit32_bxor(key, 9);
                    end;
                    local tempKey = bit32_bxor(key, key % 128 * 2 + key / 128, key % 64 * 4 + key / 64, key % 32 * 8 + key / 32, key % 16 * 16 + key / 16, 99);
                    bufferWriteU8Function(buffer1, state, tempKey);
                    bufferWriteU8Function(buffer2, tempKey, state);
                    bufferWriteU8Function(buffer3, state, galoisMultiply(3, state));
                    bufferWriteU8Function(buffer1, state, galoisMultiply(9, state));
                    bufferWriteU8Function(buffer2, state, galoisMultiply(11, state));
                end;
                local someValue3 = nil;
                local someValue4 = nil;
                local someValue5 = nil;
                local someValue6 = nil;
                local counter = 0;
                for x = 0, 255, 1 do
                    local value1 = bufferReadU8Function(buffer1, x);
                    local scaledValue = value1 * 256;
                    local sBoxValue1, sBoxValue2, sBoxValue3 = galoisMultiply(2, value1), galoisMultiply(13, x), galoisMultiply(14, x);
                    for y = 0, 255, 1 do
                        local value2 = bufferReadU8Function(buffer1, y);
                        bufferWriteU16Function(buffer131072, counter * 2, scaledValue + value2);
                        bufferWriteU8Function(buffer65536_3, counter, bufferReadU8Function(buffer2, bit32_bxor(x, y)));
                        bufferWriteU8Function(buffer65536_1, counter, bit32_bxor(sBoxValue1, bufferReadU8Function(buffer3, value2)));
                        bufferWriteU8Function(buffer65536_2, counter, bit32_bxor(value1, value2));
                        bufferWriteU8Function(buffer65536_4, counter, bit32_bxor(sBoxValue3, bufferReadU8Function(buffer2, y)));
                        bufferWriteU8Function(buffer65536_5, counter, bit32_bxor(sBoxValue2, bufferReadU8Function(buffer1, y)));
                        counter = counter + 1;
                    end;
                end;
                local newIndexHandler = function(L_331, target)
                    return errorFunction(string.format("%s cannot be assigned to", tostring(target)));
                end;
                local toStringFunction = function()
                    return "AesCipher";
                end;
                local createCipher = function(data, arg3)
                    local isBuffer = typeofFunction(data) == "buffer";
                    local dataLength = (isBuffer and { [1] = bufferLenFunction(data) } or { [1] = #data })[1];
                    local keySize = dataLength == 32 and 240 or dataLength == 16 and 176 or dataLength == 24 and 208 or errorFunction("Key must be either 16, 24 or 32 bytes long");
                    return processBlocks(data, dataLength, arg3 or bufferCreateFunction(keySize), isBuffer);
                end;
                return (function(key, initializationVector, salt)
                    local keyLength = bufferLenFunction(key);
                    local keySize = nil;
                    local roundKey = nil;
                    local roundKeys = bufferToStringFunction(key);
                    if keyLength == 240 then
                        keySize = 192;
                        roundKey = stringSubFunction(roundKeys, 1, 32);
                    elseif keyLength == 208 then
                        keySize = 160;
                        roundKey = stringSubFunction(roundKeys, 1, 24);
                    elseif keyLength == 176 then
                        keySize = 128;
                        roundKey = stringSubFunction(roundKeys, 1, 16);
                    else
                        errorFunction("Round keys must be either 240, 208 or 128 bytes long");
                    end;
                    local cipherObject = key;
                    local mode = initializationVector or cipherMethods;
                    local forwardMode = mode.FwdMode;
                    local inverseMode = mode.InvMode;
                    local segmentSize = mode.SegmentSize or 16;
                    local padding = salt or paddingFunctions;
                    local padFunction = padding.Pad;
                    local unpadFunction = padding.Unpad;
                    local aesMetaTable = newproxyFunction(true);
                    local aesCipherMetatable = getmetatableFunction(aesMetaTable);
                    local encryptBytes = function(arg4, arg5, arg6, arg7)
                        processDataFunction(cipherObject, keySize, arg4, arg5, arg6, arg7);
                        return ;
                    end;
                    local decryptBytes = function(arg8, arg9, arg10, arg11)
                        processData(cipherObject, keySize, arg8, arg9, arg10, arg11);
                        return ;
                    end;
                    local encryptFunction = function(cipherInstance, dataToEncrypt, dataBuffer, ...)
                        local inputType = typeofFunction(dataToEncrypt);
                        local encryptedBuffer = (inputType == "buffer" and { [1] = dataToEncrypt } or { [1] = (inputType == "string" and { [1] = bufferFromStringFunction(dataToEncrypt) } or { [1] = errorFunction(string.format("Unable to cast %s to buffer", tostring(inputType))) })[1] })[1];
                        local ivBuffer = typeofFunction(dataBuffer) == "buffer" and dataBuffer;
                        if cipherInstance ~= aesMetaTable then
                            return cipherInstance:Encrypt(encryptedBuffer, ivBuffer, ...);
                        end;
                        if keySize then
                            local encryptedData = padFunction(encryptedBuffer, ivBuffer, segmentSize);
                            forwardMode(encryptBytes, decryptBytes, (padding.Overwrite == false and { [1] = encryptedBuffer } or { [1] = encryptedData })[1], encryptedData, mode, ...);
                            return encryptedData;
                        end;
                        errorFunction("AesCipher object's already destroyed");
                        return bufferCreateFunction(0);
                    end;
                    local encryptBlock = function(cipherInstance, inputBuffer, encryptionKey, encryptionKey1, encryptionKey2)
                        if cipherInstance ~= aesMetaTable then
                            cipherInstance:EncryptBlock(inputBuffer, encryptionKey, encryptionKey1, encryptionKey2);
                        elseif keySize then
                            processDataFunction(cipherObject, keySize, inputBuffer, encryptionKey, encryptionKey1 or inputBuffer, encryptionKey2 or encryptionKey);
                        else
                            errorFunction("AesCipher object's already destroyed");
                        end;
                        return ;
                    end;
                    local decryptFunction = function(cipherInstance, dataToDecrypt, bufferData, ...)
                        local inputType = typeofFunction(dataToDecrypt);
                        local decryptedBuffer = (inputType == "buffer" and { [1] = dataToDecrypt } or { [1] = (inputType == "string" and { [1] = bufferFromStringFunction(dataToDecrypt) } or { [1] = errorFunction(string.format("Unable to cast %s to buffer", tostring(inputType))) })[1] })[1];
                        local ivBuffer = typeofFunction(bufferData) == "buffer" and bufferData;
                        if cipherInstance ~= aesMetaTable then
                            return cipherInstance:Decrypt(decryptedBuffer, ivBuffer, ...);
                        end;
                        if keySize then
                            local shouldOverwrite = padding.Overwrite;
                            local decryptedData = (shouldOverwrite == nil and { [1] = bufferCreateFunction(bufferLenFunction(decryptedBuffer)) } or { [1] = (shouldOverwrite and { [1] = decryptedBuffer } or { [1] = ivBuffer or bufferCreateFunction(bufferLenFunction(decryptedBuffer)) })[1] })[1];
                            inverseMode(encryptBytes, decryptBytes, decryptedBuffer, decryptedData, mode, ...);
                            return unpadFunction(decryptedData, ivBuffer, segmentSize);
                        end;
                        errorFunction("AesCipher object's already destroyed");
                        return bufferCreateFunction(0);
                    end;
                    local decryptBlockFunction = function(cipherInstance, blockData, blockOffset, decryptionKey1, decryptionKey2)
                        if cipherInstance ~= aesMetaTable then
                            cipherInstance:DecryptBlock(blockData, blockOffset, decryptionKey1, decryptionKey2);
                        elseif keySize then
                            processData(cipherObject, keySize, blockData, blockOffset, decryptionKey1 or blockData, decryptionKey2 or blockOffset);
                        else
                            errorFunction("AesCipher object's already destroyed");
                        end;
                        return ;
                    end;
                    local destroyCipherFunction = function(cipherObject)
                        if cipherObject ~= aesMetaTable then
                            cipherObject:Destroy();
                        elseif keySize then
                            roundKeys, cipherObject, keySize, forwardMode, inverseMode, mode, padding, roundKey, keyLength = nil, nil, nil, nil, nil, nil, nil, nil, nil;
                        else
                            errorFunction("AesCipher object's already destroyed");
                        end;
                        return ;
                    end;
                    local aesCipherMethods = { Encrypt = encryptFunction, Decrypt = decryptFunction, EncryptBlock = encryptBlock, DecryptBlock = decryptBlockFunction, Destroy = destroyCipherFunction };
                    local aesCipherProperties = { Key = roundKey, RoundKeys = roundKeys, Mode = mode, Padding = padding, Length = keyLength };
                    aesCipherMetatable.__index = function(L_401, propertyName)
                        if aesCipherMethods[propertyName] then
                            return aesCipherMethods[propertyName];
                        end;
                        if keySize and aesCipherProperties[propertyName] then
                            return aesCipherProperties[propertyName];
                        end;
                        if keySize then
                            errorFunction(("%s is not a valid member of AesCipher"):format(propertyName));
                        else
                            errorFunction("AesCipher object's already destroyed");
                        end;
                        return ;
                    end;
                    aesCipherMetatable.__newindex = newIndexHandler;
                    aesCipherMetatable.__tostring = toStringFunction;
                    aesCipherMetatable.__len = function()
                        return keyLength or errorFunction("AesCipher object's destroyed");
                    end;
                    aesCipherMetatable.__metatable = "AesCipher object: Metatable's locked";
                    return aesMetaTable;
                end)(createCipher(unknownValue), cipherMethods, paddingFunctions);
            end,
            ["\000ECC"] = function(L_403)
                local normalizeVector = function(vector)
                    for i = 0, 15, 1 do
                        vector[i] = vector[i] + 65536;
                        local integerPart = vector[i] / 65536 - vector[i] / 65536 % 1;
                        if i < 15 then
                            vector[i + 1] = vector[i + 1] + integerPart - 1;
                        else
                            vector[0] = vector[0] + 38 * (integerPart - 1);
                        end;
                        vector[i] = vector[i] - integerPart * 65536;
                    end;
                    return ;
                end;
                local swapVectors = function(vectorA, valueArray2, rotationFactor)
                    for i = 0, 15, 1 do
                        vectorA[i], valueArray2[i] = vectorA[i] * ((rotationFactor - 1) % 2) + valueArray2[i] * rotationFactor, valueArray2[i] * ((rotationFactor - 1) % 2) + vectorA[i] * rotationFactor;
                    end;
                    return ;
                end;
                local convertBytesToShorts = function(outputBuffer, sourceData)
                    for i = 0, 15, 1 do
                        outputBuffer[i] = sourceData[2 * i] + sourceData[2 * i + 1] * 256;
                    end;
                    outputBuffer[15] = outputBuffer[15] % 32768;
                    return ;
                end;
                local processDataFunction = function(outputArray, sourceArray)
                    local tempBuffer1 = {};
                    local tempBuffer2 = {};
                    for i = 0, 15, 1 do
                        tempBuffer1[i] = sourceArray[i];
                    end;
                    normalizeVector(tempBuffer1);
                    normalizeVector(tempBuffer1);
                    normalizeVector(tempBuffer1);
                    local constantValues = { [0] = 65517, [15] = 32767 };
                    for i = 1, 14, 1 do
                        constantValues[i] = 65535;
                    end;
                    for roundIndex = 0, 1, 1 do
                        tempBuffer2[0] = tempBuffer1[0] - constantValues[0];
                        for j = 1, 15, 1 do
                            tempBuffer2[j] = tempBuffer1[j] - constantValues[j] - (tempBuffer2[j - 1] / 65536 - tempBuffer2[j - 1] / 65536 % 1) % 2;
                            tempBuffer2[j - 1] = (tempBuffer2[j - 1] + 65536) % 65536;
                        end;
                        local L_426 = (tempBuffer2[15] / 65536 - tempBuffer2[15] / 65536 % 1) % 2;
                        swapVectors(tempBuffer1, tempBuffer2, 1 - L_426);
                    end;
                    for k = 0, 15, 1 do
                        outputArray[2 * k] = tempBuffer1[k] % 256;
                        outputArray[2 * k + 1] = tempBuffer1[k] / 256 - tempBuffer1[k] / 256 % 1;
                    end;
                    return ;
                end;
                local addArraysFunction = function(destinationArray, inputData1, sourceArray1)
                    for i = 0, 15, 1 do
                        destinationArray[i] = inputData1[i] + sourceArray1[i];
                    end;
                    return ;
                end;
                local subtractArraysFunction = function(destinationArray, inputData2, sourceArray2)
                    for i = 0, 15, 1 do
                        destinationArray[i] = inputData2[i] - sourceArray2[i];
                    end;
                    return ;
                end;
                local multiplyArraysFunction = function(outputArray, matrixA, matrixB)
                    local intermediateBuffer = {};
                    for l = 0, 31, 1 do
                        intermediateBuffer[l] = 0;
                    end;
                    for m = 0, 15, 1 do
                        for n = 0, 15, 1 do
                            intermediateBuffer[m + n] = intermediateBuffer[m + n] + matrixA[m] * matrixB[n];
                        end;
                    end;
                    for i = 0, 14, 1 do
                        intermediateBuffer[i] = intermediateBuffer[i] + 38 * intermediateBuffer[i + 16];
                    end;
                    for o = 0, 15, 1 do
                        outputArray[o] = intermediateBuffer[o];
                    end;
                    normalizeVector(outputArray);
                    normalizeVector(outputArray);
                    return ;
                end;
                local processArrayFunction = function(destinationArray2, sourceArray2)
                    local tempArray = {};
                    for i = 0, 15, 1 do
                        tempArray[i] = sourceArray2[i];
                    end;
                    for p = 253, 0, -1 do
                        multiplyArraysFunction(tempArray, tempArray, tempArray);
                        if p ~= 2 and p ~= 4 then
                            multiplyArraysFunction(tempArray, tempArray, sourceArray2);
                        end;
                    end;
                    for q = 0, 15, 1 do
                        destinationArray2[q] = tempArray[q];
                    end;
                    return ;
                end;
                local mainProcessingFunction = function(unknownValue, sourceData2, keyData)
                    local buffer1 = {};
                    local buffer2 = {};
                    local buffer3 = {};
                    local buffer4 = {};
                    local buffer5 = {};
                    local tempTable = {};
                    local buffer6 = {};
                    local buffer7 = {};
                    convertBytesToShorts(buffer6, keyData);
                    for i = 0, 15, 1 do
                        local tempValue = buffer6[i];
                        buffer1[i] = 0;
                        buffer2[i] = tempValue;
                        buffer3[i] = 0;
                        buffer4[i] = 0;
                    end;
                    buffer1[0] = 1;
                    buffer4[0] = 1;
                    for r = 0, 30, 1 do
                        buffer7[r] = sourceData2[r];
                    end;
                    buffer7[0] = buffer7[0] - buffer7[0] % 8;
                    buffer7[31] = sourceData2[31] % 64 + 64;
                    for bitIndex = 254, 0, -1 do
                        local bitValue = (buffer7[bitIndex / 8 - bitIndex / 8 % 1] / 2 ^ (bitIndex % 8) - buffer7[bitIndex / 8 - bitIndex / 8 % 1] / 2 ^ (bitIndex % 8) % 1) % 2;
                        swapVectors(buffer1, buffer2, bitValue);
                        swapVectors(buffer3, buffer4, bitValue);
                        addArraysFunction(buffer5, buffer1, buffer3);
                        subtractArraysFunction(buffer1, buffer1, buffer3);
                        addArraysFunction(buffer3, buffer2, buffer4);
                        subtractArraysFunction(buffer2, buffer2, buffer4);
                        multiplyArraysFunction(buffer4, buffer5, buffer5);
                        multiplyArraysFunction(tempTable, buffer1, buffer1);
                        multiplyArraysFunction(buffer1, buffer3, buffer1);
                        multiplyArraysFunction(buffer3, buffer2, buffer5);
                        addArraysFunction(buffer5, buffer1, buffer3);
                        subtractArraysFunction(buffer1, buffer1, buffer3);
                        multiplyArraysFunction(buffer2, buffer1, buffer1);
                        subtractArraysFunction(buffer3, buffer4, tempTable);
                        multiplyArraysFunction(buffer1, buffer3, { [0] = 56129, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 });
                        addArraysFunction(buffer1, buffer1, buffer4);
                        multiplyArraysFunction(buffer3, buffer3, buffer1);
                        multiplyArraysFunction(buffer1, buffer4, tempTable);
                        multiplyArraysFunction(buffer4, buffer2, buffer6);
                        multiplyArraysFunction(buffer2, buffer5, buffer5);
                        swapVectors(buffer1, buffer2, bitValue);
                        swapVectors(buffer3, buffer4, bitValue);
                    end;
                    processArrayFunction(buffer3, buffer3);
                    multiplyArraysFunction(buffer1, buffer1, buffer3);
                    processDataFunction(unknownValue, buffer1);
                    return ;
                end;
                local generateKeypair = function(randomGenerator)
                    local randomGeneratorFunction = randomGenerator or function()
                        return math.random(0, 255);
                    end;
                    local keyMap = {};
                    local byteArray = {};
                    for i = 0, 31, 1 do
                        keyMap[i] = randomGeneratorFunction();
                    end;
                    local L_478 = { [0] = 9 };
                    for i = 1, 31, 1 do
                        L_478[i] = 0;
                    end;
                    mainProcessingFunction(byteArray, keyMap, L_478);
                    return keyMap, byteArray;
                end;
                local getSharedKey = function(unknownValue2, arg12)
                    local sharedKeyMap = {};
                    mainProcessingFunction(sharedKeyMap, unknownValue2, arg12);
                    return sharedKeyMap;
                end;
                return { generate_keypair = generateKeypair, get_shared_key = getSharedKey };
            end,
            ["\000HASH"] = function(hashFunction)
                local createKeyGenerator = function(keyGeneratorFunction)
                    local metatable = {};
                    local keyObject = setmetatableFunction({}, metatable);
                    metatable.__index = function(L_489, key)
                        local generatedKey = keyGeneratorFunction(key);
                        keyObject[key] = generatedKey;
                        return generatedKey;
                    end;
                    return keyObject;
                end;
                local matrixMultiplier = function(L_493, base)
                    return function(value1, value2)
                        local result = 0;
                        local powerOfBase = 1;
                        while value1 ~= 0 and value2 ~= 0 do
                            local remainder1 = value1 % base;
                            local remainder = value2 % base;
                            result = result + L_493[remainder1][remainder] * powerOfBase;
                            value1 = (value1 - remainder1) / base;
                            value2 = (value2 - remainder) / base;
                            powerOfBase = powerOfBase * base;
                        end;
                        return result + (value1 + value2) * powerOfBase;
                    end;
                end;
                local magicFunction = (function(matrix)
                    local binaryMultiplier = matrixMultiplier(matrix, 2);
                    local recursiveKeyGenerator = createKeyGenerator(function(key1)
                        return createKeyGenerator(function(unknownValue3)
                            return binaryMultiplier(key1, unknownValue3);
                        end);
                    end);
                    return matrixMultiplier(recursiveKeyGenerator, 2 ^ (matrix.n or 1));
                end)({ [0] = { [0] = 0, [1] = 1 }, { [0] = 1, [1] = 0 }, n = 4 });
                local recursiveFunction;
                recursiveFunction = function(unknownValue5, value2, unknownValue6, ...)
                    local unknownValue4 = nil;
                    if value2 then
                        local truncatedValue1 = unknownValue5 % 4294967296;
                        local remainder = value2 % 4294967296;
                        local intermediateResult = magicFunction(truncatedValue1, remainder);
                        if unknownValue6 then
                            intermediateResult = recursiveFunction(intermediateResult, unknownValue6, ...);
                        end;
                        return intermediateResult;
                    end;
                    if unknownValue5 then
                        return unknownValue5 % 4294967296;
                    end;
                    return 0;
                end;
                local bit32BandWrapper = function(unknownValue8, value2, bitmaskValue, ...)
                    local unknownValue7 = nil;
                    if value2 then
                        local truncatedValue1 = unknownValue8 % 4294967296;
                        local truncatedValue2 = value2 % 4294967296;
                        local intermediateValue = (truncatedValue1 + truncatedValue2 - magicFunction(truncatedValue1, truncatedValue2)) / 2;
                        if bitmaskValue then
                            intermediateValue = bit32_band(intermediateValue, bitmaskValue, ...);
                        end;
                        return intermediateValue;
                    end;
                    if unknownValue8 then
                        return unknownValue8 % 4294967296;
                    end;
                    return 4294967295;
                end;
                local bitwiseComplementFunction = function(valueToComplement)
                    return (-1 - valueToComplement) % 4294967296;
                end;
                local bit32ExtractFunction = function(valueToShift, shiftAmount)
                    if shiftAmount < 0 then
                        return lshift(valueToShift, -shiftAmount);
                    end;
                    return math.floor(valueToShift % 4294967296 / 2 ^ shiftAmount);
                end;
                local bit32ExtractBoundedFunction = function(unknownValue9, bitShiftAmount)
                    if 31 < bitShiftAmount or bitShiftAmount < -31 then
                        return 0;
                    end;
                    return bit32ExtractFunction(unknownValue9 % 4294967296, bitShiftAmount);
                end;
                local multiplyModuloFunction = function(baseValue, shiftAmount)
                    if shiftAmount < 0 then
                        return bit32ExtractBoundedFunction(baseValue, -shiftAmount);
                    end;
                    return baseValue * 2 ^ shiftAmount % 4294967296;
                end;
                local combineShiftedBitsFunction = function(unknownValue10, shiftAmount)
                    local valueMasked = unknownValue10 % 4294967296;
                    local shiftAmountModulo32 = shiftAmount % 32;
                    local maskedValue = bit32BandWrapper(valueMasked, 2 ^ shiftAmountModulo32 - 1);
                    return bit32ExtractBoundedFunction(valueMasked, shiftAmountModulo32) + multiplyModuloFunction(maskedValue, 32 - shiftAmountModulo32);
                end;
                local hashConstants = { 1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298 };
                local stringToHexFunction = function(inputString)
                    return string.gsub(inputString, ".", function(char)
                        return string.format("%02x", string.byte(char));
                    end);
                end;
                local numberToStringFunction = function(valueToDivide, numBytes)
                    local charString = "";
                    for i = 1, numBytes, 1 do
                        local byteValue = valueToDivide % 256;
                        charString = string.char(byteValue) .. charString;
                        valueToDivide = (valueToDivide - byteValue) / 256;
                    end;
                    return charString;
                end;
                local bytesToNumberFunction = function(inputString, startIndex)
                    local resultNumber = 0;
                    for byteIndex = startIndex, startIndex + 3, 1 do
                        resultNumber = resultNumber * 256 + string.byte(inputString, byteIndex);
                    end;
                    return resultNumber;
                end;
                local padStringFunction = function(prefixString, stringLength)
                    local paddingLength = 64 - (stringLength + 9) % 64;
                    local encodedLength = numberToStringFunction(8 * stringLength, 8);
                    local paddedString = prefixString .. ("\128" .. (string.rep("\000", paddingLength) .. encodedLength));
                    assertFunction(#paddedString % 64 == 0);
                    return paddedString;
                end;
                local initialHashValuesFunction = function(initialHashValues)
                    initialHashValues[1] = 1779033703;
                    initialHashValues[2] = 3144134277;
                    initialHashValues[3] = 1013904242;
                    initialHashValues[4] = 2773480762;
                    initialHashValues[5] = 1359893119;
                    initialHashValues[6] = 2600822924;
                    initialHashValues[7] = 528734635;
                    initialHashValues[8] = 1541459225;
                    return initialHashValues;
                end;
                local processDataFunction = function(dataBuffer1, offset1, values)
                    local dataArray = {};
                    for i = 1, 16, 1 do
                        dataArray[i] = bytesToNumberFunction(dataBuffer1, offset1 + (i - 1) * 4);
                    end;
                    for j = 17, 64, 1 do
                        local messageScheduleValue1 = dataArray[j - 15];
                        local messageScheduleValue2 = recursiveFunction(combineShiftedBitsFunction(messageScheduleValue1, 7), combineShiftedBitsFunction(messageScheduleValue1, 18), bit32ExtractBoundedFunction(messageScheduleValue1, 3));
                        local messageScheduleValue3 = dataArray[j - 2];
                        dataArray[j] = dataArray[j - 16] + messageScheduleValue2 + dataArray[j - 7] + recursiveFunction(combineShiftedBitsFunction(messageScheduleValue3, 17), combineShiftedBitsFunction(messageScheduleValue3, 19), bit32ExtractBoundedFunction(messageScheduleValue3, 10));
                    end;
                    local value1 = values[1];
                    local value2 = values[2];
                    local value3 = values[3];
                    local value4 = values[4];
                    local value5 = values[5];
                    local value6 = values[6];
                    local L_579 = values[7];
                    local L_580 = values[8];
                    for i = 1, 64, 1 do
                        local L_582 = recursiveFunction(combineShiftedBitsFunction(value1, 2), combineShiftedBitsFunction(value1, 13), combineShiftedBitsFunction(value1, 22)) + recursiveFunction(bit32BandWrapper(value1, value2), bit32BandWrapper(value1, value3), bit32BandWrapper(value2, value3));
                        local L_583 = recursiveFunction(combineShiftedBitsFunction(value5, 6), combineShiftedBitsFunction(value5, 11), combineShiftedBitsFunction(value5, 25));
                        local intermediateHashValue = recursiveFunction(bit32BandWrapper(value5, value6), bit32BandWrapper(bitwiseComplementFunction(value5), L_579));
                        local L_585 = L_580 + L_583 + intermediateHashValue + hashConstants[i] + dataArray[i];
                        local L_586 = value4 + L_585;
                        local L_587 = L_585 + L_582;
                        L_580 = L_579;
                        L_579 = value6;
                        value6 = value5;
                        value5 = L_586;
                        value4 = value3;
                        value3 = value2;
                        value2 = value1;
                        value1 = L_587;
                    end;
                    values[1] = bit32BandWrapper(values[1] + value1);
                    values[2] = bit32BandWrapper(values[2] + value2);
                    values[3] = bit32BandWrapper(values[3] + value3);
                    values[4] = bit32BandWrapper(values[4] + value4);
                    values[5] = bit32BandWrapper(values[5] + value5);
                    values[6] = bit32BandWrapper(values[6] + value6);
                    values[7] = bit32BandWrapper(values[7] + L_579);
                    values[8] = bit32BandWrapper(values[8] + L_580);
                    return ;
                end;
                return (function(inputData)
                    local L_590 = padStringFunction(inputData, #inputData);
                    local L_591 = initialHashValuesFunction({});
                    for i = 1, #L_590, 64 do
                        processDataFunction(L_590, i, L_591);
                    end;
                    return stringToHexFunction(numberToStringFunction(L_591[1], 4) .. (numberToStringFunction(L_591[2], 4) .. (numberToStringFunction(L_591[3], 4) .. (numberToStringFunction(L_591[4], 4) .. (numberToStringFunction(L_591[5], 4) .. (numberToStringFunction(L_591[6], 4) .. (numberToStringFunction(L_591[7], 4) .. numberToStringFunction(L_591[8], 4))))))));
                end)(hashFunction);
            end
        };
    end,
    c = function()
        return {
            ["\000padString"] = function(stringToPad)
                local paddedString = stringToPad:sub(1, math.floor(#stringToPad / 16) * 16);
                local paddingLength = 16 - #paddedString % 16;
                if paddingLength == 16 then
                    paddingLength = 0;
                end;
                return paddedString .. string.rep("0", paddingLength);
            end,
            ["\000strToHex"] = function(stringToHexEncode)
                return stringToHexEncode:gsub(".", function(charToEncode)
                    return string.format("%02x", charToEncode:byte());
                end);
            end,
            ["\000hexToBin"] = function(hexStringToDecode)
                return hexStringToDecode:gsub("..", function(hexPairToDecode)
                    return string.char(tonumber(hexPairToDecode, 16));
                end);
            end,
            ["\000bytesToHex"] = function(byteArray2)
                local hexString = "";
                for i = 0, #byteArray2, 1 do
                    if byteArray2[i] then
                        hexString = hexString .. string.format("%02x", byteArray2[i]);
                    end;
                end;
                return hexString;
            end,
            ["\000hexToBytes"] = function(L_603)
                local L_604 = {};
                local byteIndex = 0;
                for hexIndex = 1, #L_603, 2 do
                    L_604[byteIndex] = tonumber(L_603:sub(hexIndex, hexIndex + 1), 16);
                    byteIndex = byteIndex + 1;
                end;
                return L_604;
            end
        };
    end,
    d = function()
        return function()
            local L_607 = {};
            local L_612 = function(L_608)
                if type(L_608) ~= "table" then
                    return type(L_608);
                end;
                local tableIndex = 1;
                for index, value in pairsFunction(L_608) do
                    if L_608[tableIndex] == nil then
                        return "table";
                    end;
                    tableIndex = tableIndex + 1;
                end;
                if tableIndex == 1 then
                    return "table";
                end;
                return "array";
            end;
            local L_618 = function(stringToEscape)
                local L_614 = { "\\", "\"", "/", "\b", "\f", "\n", "\r", "\t" };
                local escapeCharactersList = { "\\", "\"", "/", "b", "f", "n", "r", "t" };
                for index, L_617 in ipairs(L_614) do
                    stringToEscape = stringToEscape:gsub(L_617, "\\" .. escapeCharactersList[index]);
                end;
                return stringToEscape;
            end;
            local L_624 = function(inputString, L_620, L_621, shouldReportError)
                local L_623 = L_620 + #inputString:match("^%s*", L_620);
                if inputString:sub(L_623, L_623) ~= L_621 then
                    if shouldReportError then
                        errorFunction("Expected " .. (L_621 .. (" near position " .. L_623)));
                    end;
                    return L_623, false;
                end;
                return L_623 + 1, true;
            end;
            local L_625;
            L_625 = function(L_626, L_627, defaultValue)
                local L_629 = defaultValue or "";
                if #L_626 < L_627 then
                    errorFunction("End of input found while parsing string.");
                end;
                local L_630 = L_626:sub(L_627, L_627);
                if L_630 == "\"" then
                    return L_629, L_627 + 1;
                end;
                if L_630 ~= "\\" then
                    return L_625(L_626, L_627 + 1, L_629 .. L_630);
                end;
                local escapeCharacters = { b = "\b", f = "\f", n = "\n", r = "\r", t = "\t" };
                local L_632 = L_626:sub(L_627 + 1, L_627 + 1);
                if not L_632 then
                    errorFunction("End of input found while parsing string.");
                end;
                return L_625(L_626, L_627 + 2, L_629 .. (escapeCharacters[L_632] or L_632));
            end;
            local L_637 = function(L_633, stringPosition)
                local L_635 = L_633:match("^-?%d+%.?%d*[eE]?[+-]?%d*", stringPosition);
                local numberValue = tonumber(L_635);
                if not numberValue then
                    errorFunction("Error parsing number at position " .. (stringPosition .. "."));
                end;
                return numberValue, stringPosition + #L_635;
            end;
            L_607.stringify = function(dataValue, isKey)
                local stringPartsList = {};
                local dataType = L_612(dataValue);
                if dataType == "array" then
                    if isKey then
                        errorFunction("Can't encode array as key.");
                    end;
                    table.insert(stringPartsList, "[");
                    for arrayIndex, arrayValue in ipairs(dataValue) do
                        if 1 < arrayIndex then
                            table.insert(stringPartsList, ",");
                        end;
                        table.insert(stringPartsList, L_607.stringify(arrayValue));
                    end;
                    table.insert(stringPartsList, "]");
                elseif dataType == "table" then
                    if isKey then
                        errorFunction("Can't encode table as key.");
                    end;
                    table.insert(stringPartsList, "{");
                    local isFirstElement = true;
                    for tableKey, tableValue in pairsFunction(dataValue) do
                        if not isFirstElement then
                            table.insert(stringPartsList, ",");
                        end;
                        isFirstElement = false;
                        table.insert(stringPartsList, L_607.stringify(tableKey, true));
                        table.insert(stringPartsList, ":");
                        table.insert(stringPartsList, L_607.stringify(tableValue));
                    end;
                    table.insert(stringPartsList, "}");
                else
                    if dataType == "string" then
                        return "\"" .. (L_618(dataValue) .. "\"");
                    end;
                    if dataType == "number" then
                        return isKey and "\"" .. (tostringFunction(dataValue) .. "\"") or tostringFunction(dataValue);
                    end;
                    if dataType == "boolean" then
                        return tostringFunction(dataValue);
                    end;
                    if dataType == "nil" then
                        return "null";
                    end;
                    if dataType == "userdata" then
                        return "\"" .. (tostringFunction(dataValue) .. "\"");
                    end;
                    errorFunction("Unjsonifiable type: " .. dataType);
                end;
                return (function(dataArray, defaultValue, optionalValue, defaultLength)
                    local separatorString = defaultValue or "";
                    local startIndex = optionalValue or 1;
                    local endIndex = defaultLength or #dataArray;
                    local concatenatedString = "";
                    for index = startIndex, endIndex, 1 do
                        concatenatedString = concatenatedString .. tostring(dataArray[index]);
                        if index < endIndex then
                            concatenatedString = concatenatedString .. separatorString;
                        end;
                    end;
                    return concatenatedString;
                end)(stringPartsList);
            end;
            L_607.null = {};
            L_607.parse = function(inputString, defaultStart, endCharacter)
                local currentIndex = defaultStart or 1;
                if #inputString < currentIndex then
                    errorFunction("Reached unexpected end of input.");
                end;
                local currentCharacter = inputString:sub(currentIndex, currentIndex);
                if currentCharacter == "{" then
                    local objectTable = {};
                    local parsedValue = nil;
                    local commaFound = true;
                    local currentIndex = currentIndex + 1;
                    local colonPosition;
                    while true do
                        local parsedKey, keyEndPosition = L_607.parse(inputString, currentIndex, "}");
                        local key = parsedKey;
                        colonPosition = keyEndPosition;
                        if key == nil then
                            break;
                        end;
                        if not commaFound then
                            errorFunction("Comma missing between object items.");
                        end;
                        local colonResult = L_624(inputString, colonPosition, ":", true);
                        local parsedValue, parsedValueResult = L_607.parse(inputString, colonResult);
                        objectTable[key] = parsedValue;
                        local valueEndPosition, hasMoreValues = L_624(inputString, parsedValueResult, ",");
                        currentIndex = valueEndPosition;
                        commaFound = hasMoreValues;
                    end;
                    return objectTable, colonPosition;
                end;
                if currentCharacter == "[" then
                    local arrayTable = {};
                    local parsedValue = nil;
                    local commaFound = true;
                    local currentIndex = currentIndex + 1;
                    local commaPosition;
                    while true do
                        local parsedArrayValue, arrayValueEndPosition = L_607.parse(inputString, currentIndex, "]");
                        local arrayItem = parsedArrayValue;
                        commaPosition = arrayValueEndPosition;
                        if arrayItem == nil then
                            break;
                        end;
                        if not commaFound then
                            errorFunction("Comma missing between array items.");
                        end;
                        table.insert(arrayTable, arrayItem);
                        local nextIndex, separator = L_624(inputString, commaPosition, ",");
                        currentIndex = nextIndex;
                        commaFound = separator;
                    end;
                    return arrayTable, commaPosition;
                end;
                if currentCharacter == "\"" then
                    return L_625(inputString, currentIndex + 1);
                end;
                if currentCharacter == "-" or currentCharacter:match("%d") then
                    return L_637(inputString, currentIndex);
                end;
                if currentCharacter == endCharacter then
                    return nil, currentIndex + 1;
                end;
                for booleanString, booleanValue in pairsFunction({ ["true"] = true, ["false"] = false, null = L_607.null }) do
                    if inputString:sub(currentIndex, currentIndex + #booleanString - 1) == booleanString then
                        return booleanValue, currentIndex + #booleanString;
                    end;
                end;
                errorFunction("Invalid json syntax at position " .. currentIndex);
                return ;
            end;
            return L_607;
        end;
    end,
    e = function()
        local cacheModule = { cache = {} };
        cacheModule.__index = cacheModule;
        cacheModule.add = function(cacheModule, cacheKey, cacheValue, expirationTime)
            local cacheExpirationTime = expirationTime and os.time() + expirationTime or nil;
            cacheModule.cache[cacheKey] = { value = cacheValue, expiration = cacheExpirationTime };
            return ;
        end;
        cacheModule.get = function(self, cacheKey)
            local cachedValue = self.cache[cacheKey];
            if cachedValue then
                if cachedValue.expiration then
                    local currentTime = os.time();
                    if cachedValue.expiration < currentTime then
                        self.cache[cacheKey] = nil;
                        return nil;
                    end;
                end;
                return cachedValue.value;
            end;
            return nil;
        end;
        cacheModule.remove = function(cacheModule, cacheKey)
            cacheModule.cache[cacheKey] = nil;
            return ;
        end;
        cacheModule.clear = function(moduleCache)
            moduleCache.cache = {};
            return ;
        end;
        cacheModule.new = function()
            local randomModule = setmetatableFunction({}, cacheModule);
            randomModule.cache = {};
            return randomModule;
        end;
        return cacheModule;
    end,
    f = function()
        return {
            ["\000generateSeed"] = function()
                local currentTime = os.time();
                local clockTime = os.clock();
                local randomOffset = math.floor(math.random() * 1000000);
                return (currentTime * 1664525 + clockTime + randomOffset) % 4294967296;
            end,
            ["\000lcg"] = function(inputData, count, minValue, maxValue)
                local randomNumbersList = {};
                local randomNumber = inputData;
                for index = 1, count, 1 do
                    randomNumber = (1664525 * randomNumber + 1013904223) % 4294967296;
                    randomNumbersList[index] = minValue + randomNumber % (maxValue - minValue + 1);
                end;
                return randomNumbersList;
            end,
            ["\000sign"] = function(baseValue, stringToHash)
                return baseValue + (#stringToHash % 1000) ^ 2;
            end
        };
    end,
    g = function()
        return function()
            local stringifier = {};
            local getType = function(value)
                if type(value) ~= "table" then
                    return type(value);
                end;
                local tableIndex2 = 1;
                for index, value in pairsFunction(value) do
                    if value[tableIndex2] == nil then
                        return "table";
                    end;
                    tableIndex2 = tableIndex2 + 1;
                end;
                if tableIndex2 == 1 then
                    return "table";
                end;
                return "array";
            end;
            local escapeString = function(stringToEscape2)
                local escapeCharacters = { "\\", "\"", "/", "\b", "\f", "\n", "\r", "\t" };
                local escapeCharactersList = { "\\", "\"", "/", "b", "f", "n", "r", "t" };
                for index, escapeCharacter in ipairs(escapeCharacters) do
                    stringToEscape2 = stringToEscape2:gsub(escapeCharacter, "\\" .. escapeCharactersList[index]);
                end;
                return stringToEscape2;
            end;
            local expectCharacter = function(inputString, position, expectedCharacter, shouldReportError)
                local positionAfterWhitespace = position + #inputString:match("^%s*", position);
                if inputString:sub(positionAfterWhitespace, positionAfterWhitespace) ~= expectedCharacter then
                    if shouldReportError then
                        errorFunction("Expected " .. (expectedCharacter .. (" near position " .. positionAfterWhitespace)));
                    end;
                    return positionAfterWhitespace, false;
                end;
                return positionAfterWhitespace + 1, true;
            end;
            local parseString;
            parseString = function(inputString, currentIndex, defaultValue)
                local accumulator = defaultValue or "";
                if #inputString < currentIndex then
                    errorFunction("End of input found while parsing string.");
                end;
                local currentCharacter = inputString:sub(currentIndex, currentIndex);
                if currentCharacter == "\"" then
                    return accumulator, currentIndex + 1;
                end;
                if currentCharacter ~= "\\" then
                    return parseString(inputString, currentIndex + 1, accumulator .. currentCharacter);
                end;
                local escapeCharacters2 = { b = "\b", f = "\f", n = "\n", r = "\r", t = "\t" };
                local escapeCode = inputString:sub(currentIndex + 1, currentIndex + 1);
                if not escapeCode then
                    errorFunction("End of input found while parsing string.");
                end;
                return parseString(inputString, currentIndex + 2, accumulator .. (escapeCharacters2[escapeCode] or escapeCode));
            end;
            local parseNumber = function(input, startPosition)
                local numberMatch = input:match("^-?%d+%.?%d*[eE]?[+-]?%d*", startPosition);
                local numberValue = tonumber(numberMatch);
                if not numberValue then
                    errorFunction("Error parsing number at position " .. (startPosition .. "."));
                end;
                return numberValue, startPosition + #numberMatch;
            end;
            stringifier.stringify = function(value, isKey)
                local stringParts = {};
                local dataType = getType(value);
                if dataType == "array" then
                    if isKey then
                        errorFunction("Can't encode array as key.");
                    end;
                    table.insert(stringParts, "[");
                    for arrayIndex, arrayValue in ipairs(value) do
                        if 1 < arrayIndex then
                            table.insert(stringParts, ",");
                        end;
                        table.insert(stringParts, stringifier.stringify(arrayValue));
                    end;
                    table.insert(stringParts, "]");
                elseif dataType == "table" then
                    if isKey then
                        errorFunction("Can't encode table as key.");
                    end;
                    table.insert(stringParts, "{");
                    local isFirstElement2 = true;
                    for dictionaryKey, dictionaryValue in pairsFunction(value) do
                        if not isFirstElement2 then
                            table.insert(stringParts, ",");
                        end;
                        isFirstElement2 = false;
                        table.insert(stringParts, stringifier.stringify(dictionaryKey, true));
                        table.insert(stringParts, ":");
                        table.insert(stringParts, stringifier.stringify(dictionaryValue));
                    end;
                    table.insert(stringParts, "}");
                else
                    if dataType == "string" then
                        return "\"" .. (escapeString(value) .. "\"");
                    end;
                    if dataType == "number" then
                        return isKey and "\"" .. (tostringFunction(value) .. "\"") or tostringFunction(value);
                    end;
                    if dataType == "boolean" then
                        return tostringFunction(value);
                    end;
                    if dataType == "nil" then
                        return "null";
                    end;
                    if dataType == "userdata" then
                        return "\"" .. (tostringFunction(value) .. "\"");
                    end;
                    errorFunction("Unjsonifiable type: " .. dataType);
                end;
                return (function(dataArray, defaultValue, optionalValue2, defaultLength)
                    local separator = defaultValue or "";
                    local startIndex = optionalValue2 or 1;
                    local endIndex = defaultLength or #dataArray;
                    local resultString = "";
                    for index = startIndex, endIndex, 1 do
                        resultString = resultString .. tostring(dataArray[index]);
                        if index < endIndex then
                            resultString = resultString .. separator;
                        end;
                    end;
                    return resultString;
                end)(stringParts);
            end;
            stringifier.null = {};
            stringifier.parse = function(inputString, defaultStart, unknownValue)
                local currentIndex = defaultStart or 1;
                if #inputString < currentIndex then
                    errorFunction("Reached unexpected end of input.");
                end;
                local currentChar = inputString:sub(currentIndex, currentIndex);
                if currentChar == "{" then
                    local resultTable = {};
                    local parsedValue = nil;
                    local commaFound = true;
                    local currentIndex = currentIndex + 1;
                    local colonPosition;
                    while true do
                        local parsedKey, newIndex = stringifier.parse(inputString, currentIndex, "}");
                        local key = parsedKey;
                        colonPosition = newIndex;
                        if key == nil then
                            break;
                        end;
                        if not commaFound then
                            errorFunction("Comma missing between object items.");
                        end;
                        local colonResult = expectCharacter(inputString, colonPosition, ":", true);
                        local parsedValue, parsedValueResult = stringifier.parse(inputString, colonResult);
                        resultTable[key] = parsedValue;
                        local nextIndex, hasComma = expectCharacter(inputString, parsedValueResult, ",");
                        currentIndex = nextIndex;
                        commaFound = hasComma;
                    end;
                    return resultTable, colonPosition;
                end;
                if currentChar == "[" then
                    local resultArray = {};
                    local parsedValue = nil;
                    local commaFound = true;
                    local currentIndex = currentIndex + 1;
                    local commaPosition;
                    while true do
                        local parsedElement, nextArrayIndex = stringifier.parse(inputString, currentIndex, "]");
                        local arrayItem = parsedElement;
                        commaPosition = nextArrayIndex;
                        if arrayItem == nil then
                            break;
                        end;
                        if not commaFound then
                            errorFunction("Comma missing between array items.");
                        end;
                        table.insert(resultArray, arrayItem);
                        local nextElementIndex, hasMoreElements = expectCharacter(inputString, commaPosition, ",");
                        currentIndex = nextElementIndex;
                        commaFound = hasMoreElements;
                    end;
                    return resultArray, commaPosition;
                end;
                if currentChar == "\"" then
                    return parseString(inputString, currentIndex + 1);
                end;
                if currentChar == "-" or currentChar:match("%d") then
                    return parseNumber(inputString, currentIndex);
                end;
                if currentChar == unknownValue then
                    return nil, currentIndex + 1;
                end;
                for booleanString, booleanValue in pairsFunction({ ["true"] = true, ["false"] = false, null = stringifier.null }) do
                    if inputString:sub(currentIndex, currentIndex + #booleanString - 1) == booleanString then
                        return booleanValue, currentIndex + #booleanString;
                    end;
                end;
                errorFunction("Invalid json syntax at position " .. currentIndex);
                return ;
            end;
            return stringifier;
        end;
    end,
    h = function()
        return {
            ["\000AES"] = function(unknownValue)
                local buffer131072 = bufferCreateFunction(131072);
                local buffer65536_1 = bufferCreateFunction(65536);
                local buffer65536_2 = bufferCreateFunction(65536);
                local buffer65536_3 = bufferCreateFunction(65536);
                local buffer65536_4 = bufferCreateFunction(65536);
                local buffer65536_5 = bufferCreateFunction(65536);
                local cipherModes = {
                    FwdMode = function(copyBufferData, L_799, bufferSize, outputBuffer, L_802, optionalBufferSize)
                        local inputLengthMinus16 = bufferLenFunction(bufferSize) - 16;
                        assertFunction(inputLengthMinus16 % 16 == 0, "Input length must be a multiple of 16 bytes");
                        local initializationVector = optionalBufferSize or bufferCreateFunction(16);
                        assertFunction(bufferLenFunction(initializationVector) == 16, "Initialization vector must be 16 bytes long");
                        bufferWriteU32Function(outputBuffer, 0, bit32_bxor(bufferReadU32Function(bufferSize, 0), bufferReadU32Function(initializationVector, 0)));
                        bufferWriteU32Function(outputBuffer, 4, bit32_bxor(bufferReadU32Function(bufferSize, 4), bufferReadU32Function(initializationVector, 4)));
                        bufferWriteU32Function(outputBuffer, 8, bit32_bxor(bufferReadU32Function(bufferSize, 8), bufferReadU32Function(initializationVector, 8)));
                        bufferWriteU32Function(outputBuffer, 12, bit32_bxor(bufferReadU32Function(bufferSize, 12), bufferReadU32Function(initializationVector, 12)));
                        copyBufferData(outputBuffer, 0, outputBuffer, 0);
                        for blockOffset = 16, inputLengthMinus16, 16 do
                            bufferWriteU32Function(outputBuffer, blockOffset, bit32_bxor(bufferReadU32Function(bufferSize, blockOffset), bufferReadU32Function(outputBuffer, blockOffset - 16)));
                            bufferWriteU32Function(outputBuffer, blockOffset + 4, bit32_bxor(bufferReadU32Function(bufferSize, blockOffset + 4), bufferReadU32Function(outputBuffer, blockOffset - 12)));
                            bufferWriteU32Function(outputBuffer, blockOffset + 8, bit32_bxor(bufferReadU32Function(bufferSize, blockOffset + 8), bufferReadU32Function(outputBuffer, blockOffset - 8)));
                            bufferWriteU32Function(outputBuffer, blockOffset + 12, bit32_bxor(bufferReadU32Function(bufferSize, blockOffset + 12), bufferReadU32Function(outputBuffer, blockOffset - 4)));
                            copyBufferData(outputBuffer, blockOffset, outputBuffer, blockOffset);
                        end;
                        return ;
                    end,
                    InvMode = function(L_807, xorBlocks, inputBuffer, outputBufferCBC, L_811, optionalBufferSize2)
                        local inputLengthMinus16_CBC = bufferLenFunction(inputBuffer) - 16;
                        assertFunction(inputLengthMinus16_CBC % 16 == 0, "Input length must be a multiple of 16 bytes");
                        local initializationVectorCBC = optionalBufferSize2 or bufferCreateFunction(16);
                        assertFunction(bufferLenFunction(initializationVectorCBC) == 16, "Initialization vector must be 16 bytes long");
                        local block0 = bufferReadU32Function(inputBuffer, 0);
                        local block4 = bufferReadU32Function(inputBuffer, 4);
                        local block8 = bufferReadU32Function(inputBuffer, 8);
                        local block12 = bufferReadU32Function(inputBuffer, 12);
                        local someValue7 = nil;
                        local someValue8 = nil;
                        local someValue9 = nil;
                        local someValue10 = nil;
                        xorBlocks(inputBuffer, 0, outputBufferCBC, 0);
                        bufferWriteU32Function(outputBufferCBC, 0, bit32_bxor(bufferReadU32Function(outputBufferCBC, 0), bufferReadU32Function(initializationVectorCBC, 0)));
                        bufferWriteU32Function(outputBufferCBC, 4, bit32_bxor(bufferReadU32Function(outputBufferCBC, 4), bufferReadU32Function(initializationVectorCBC, 4)));
                        bufferWriteU32Function(outputBufferCBC, 8, bit32_bxor(bufferReadU32Function(outputBufferCBC, 8), bufferReadU32Function(initializationVectorCBC, 8)));
                        bufferWriteU32Function(outputBufferCBC, 12, bit32_bxor(bufferReadU32Function(outputBufferCBC, 12), bufferReadU32Function(initializationVectorCBC, 12)));
                        for blockOffsetCBC = 16, inputLengthMinus16_CBC, 16 do
                            local inputBlock0 = bufferReadU32Function(inputBuffer, blockOffsetCBC);
                            local inputBlock4 = bufferReadU32Function(inputBuffer, blockOffsetCBC + 4);
                            local inputBlock8 = bufferReadU32Function(inputBuffer, blockOffsetCBC + 8);
                            local inputBlock12 = bufferReadU32Function(inputBuffer, blockOffsetCBC + 12);
                            xorBlocks(inputBuffer, blockOffsetCBC, outputBufferCBC, blockOffsetCBC);
                            bufferWriteU32Function(outputBufferCBC, blockOffsetCBC, bit32_bxor(bufferReadU32Function(outputBufferCBC, blockOffsetCBC), block0));
                            bufferWriteU32Function(outputBufferCBC, blockOffsetCBC + 4, bit32_bxor(bufferReadU32Function(outputBufferCBC, blockOffsetCBC + 4), block4));
                            bufferWriteU32Function(outputBufferCBC, blockOffsetCBC + 8, bit32_bxor(bufferReadU32Function(outputBufferCBC, blockOffsetCBC + 8), block8));
                            bufferWriteU32Function(outputBufferCBC, blockOffsetCBC + 12, bit32_bxor(bufferReadU32Function(outputBufferCBC, blockOffsetCBC + 12), block12));
                            block0 = inputBlock0;
                            block4 = inputBlock4;
                            block8 = inputBlock8;
                            block12 = inputBlock12;
                        end;
                        return ;
                    end
                };
                local paddingFunctions = {
                    Pad = function(inputString, outputBufferPadding, alignment)
                        local inputLength = bufferLenFunction(inputString);
                        local paddedLength = inputLength - inputLength % alignment;
                        if outputBufferPadding then
                            assertFunction(bufferLenFunction(outputBufferPadding) >= inputLength + alignment, "Output buffer out of bounds");
                        else
                            outputBufferPadding = bufferCreateFunction(paddedLength + alignment);
                        end;
                        local padding = alignment - inputLength % alignment;
                        bufferCopyFunction(outputBufferPadding, 0, inputString, 0, inputLength);
                        bufferFillFunction(outputBufferPadding, inputLength, padding, padding);
                        return outputBufferPadding;
                    end,
                    Unpad = function(inputBuffer, outputBuffer, maxPadding)
                        local paddingLength = bufferLenFunction(inputBuffer);
                        local paddingValue = bufferReadU8Function(inputBuffer, paddingLength - 1);
                        local dataLength = paddingLength - paddingValue;
                        assertFunction(0 < paddingValue and paddingValue <= maxPadding, "Got unexpected padding");
                        for paddingIndex = dataLength, paddingLength - 2, 1 do
                            if bufferReadU8Function(inputBuffer, paddingIndex) ~= paddingValue then
                                errorFunction("Got unexpected padding");
                            end;
                        end;
                        if outputBuffer then
                            assertFunction(bufferLenFunction(outputBuffer) >= dataLength, "Output buffer out of bounds");
                        else
                            outputBuffer = bufferCreateFunction(dataLength);
                        end;
                        bufferCopyFunction(outputBuffer, 0, inputBuffer, 0, dataLength);
                        return outputBuffer;
                    end,
                    Overwrite = nil
                };
                local copyData = function(sourceBuffer, offset, destinationBuffer, shouldCopy)
                    if shouldCopy then
                        bufferCopyFunction(destinationBuffer, 0, sourceBuffer, 0, offset);
                    else
                        bufferWriteStringFunction(destinationBuffer, 0, sourceBuffer, offset);
                    end;
                    local offset = bit32_rrotate(bufferReadU32Function(destinationBuffer, offset - 4), 8);
                    local multiplier = 0.5;
                    if offset == 32 then
                        for i = 32, 192, 32 do
                            multiplier = multiplier * 2 % 229;
                            local value1 = bit32_bxor(bufferReadU32Function(destinationBuffer, i - 32), bufferReadU16Function(buffer131072, mathFloor(offset / 65536) * 2) * 65536 + bufferReadU16Function(buffer131072, offset % 65536 * 2), multiplier);
                            bufferWriteU32Function(destinationBuffer, i, value1);
                            local value2 = bit32_bxor(bufferReadU32Function(destinationBuffer, i - 28), value1);
                            bufferWriteU32Function(destinationBuffer, i + 4, value2);
                            local value3 = bit32_bxor(bufferReadU32Function(destinationBuffer, i - 24), value2);
                            bufferWriteU32Function(destinationBuffer, i + 8, value3);
                            local value4 = bit32_bxor(bufferReadU32Function(destinationBuffer, i - 20), value3);
                            bufferWriteU32Function(destinationBuffer, i + 12, value4);
                            local value5 = bit32_bxor(bufferReadU32Function(destinationBuffer, i - 16), bufferReadU16Function(buffer131072, mathFloor(value4 / 65536) * 2) * 65536 + bufferReadU16Function(buffer131072, value4 % 65536 * 2));
                            bufferWriteU32Function(destinationBuffer, i + 16, value5);
                            local value6 = bit32_bxor(bufferReadU32Function(destinationBuffer, i - 12), value5);
                            bufferWriteU32Function(destinationBuffer, i + 20, value6);
                            local value7 = bit32_bxor(bufferReadU32Function(destinationBuffer, i - 8), value6);
                            bufferWriteU32Function(destinationBuffer, i + 24, value7);
                            local value1 = bit32_bxor(bufferReadU32Function(destinationBuffer, i - 4), value7);
                            bufferWriteU32Function(destinationBuffer, i + 28, value1);
                            offset = bit32_rrotate(value1, 8);
                        end;
                        local value2 = bit32_bxor(bufferReadU32Function(destinationBuffer, 192), bufferReadU16Function(buffer131072, mathFloor(offset / 65536) * 2) * 65536 + bufferReadU16Function(buffer131072, offset % 65536 * 2), 64);
                        bufferWriteU32Function(destinationBuffer, 224, value2);
                        local value3 = bit32_bxor(bufferReadU32Function(destinationBuffer, 196), value2);
                        bufferWriteU32Function(destinationBuffer, 228, value3);
                        local value4 = bit32_bxor(bufferReadU32Function(destinationBuffer, 200), value3);
                        bufferWriteU32Function(destinationBuffer, 232, value4);
                        bufferWriteU32Function(destinationBuffer, 236, bit32_bxor(bufferReadU32Function(destinationBuffer, 204), value4));
                    elseif offset == 24 then
                        for j = 24, 168, 24 do
                            multiplier = multiplier * 2 % 229;
                            local value8 = bit32_bxor(bufferReadU32Function(destinationBuffer, j - 24), bufferReadU16Function(buffer131072, mathFloor(offset / 65536) * 2) * 65536 + bufferReadU16Function(buffer131072, offset % 65536 * 2), multiplier);
                            bufferWriteU32Function(destinationBuffer, j, value8);
                            local value9 = bit32_bxor(bufferReadU32Function(destinationBuffer, j - 20), value8);
                            bufferWriteU32Function(destinationBuffer, j + 4, value9);
                            local value10 = bit32_bxor(bufferReadU32Function(destinationBuffer, j - 16), value9);
                            bufferWriteU32Function(destinationBuffer, j + 8, value10);
                            local value11 = bit32_bxor(bufferReadU32Function(destinationBuffer, j - 12), value10);
                            bufferWriteU32Function(destinationBuffer, j + 12, value11);
                            local value12 = bit32_bxor(bufferReadU32Function(destinationBuffer, j - 8), value11);
                            bufferWriteU32Function(destinationBuffer, j + 16, value12);
                            local value5 = bit32_bxor(bufferReadU32Function(destinationBuffer, j - 4), value12);
                            bufferWriteU32Function(destinationBuffer, j + 20, value5);
                            offset = bit32_rrotate(value5, 8);
                        end;
                        local value6 = bit32_bxor(bufferReadU32Function(destinationBuffer, 168), bufferReadU16Function(buffer131072, mathFloor(offset / 65536) * 2) * 65536 + bufferReadU16Function(buffer131072, offset % 65536 * 2), 128);
                        bufferWriteU32Function(destinationBuffer, 192, value6);
                        local value7 = bit32_bxor(bufferReadU32Function(destinationBuffer, 172), value6);
                        bufferWriteU32Function(destinationBuffer, 196, value7);
                        local value8 = bit32_bxor(bufferReadU32Function(destinationBuffer, 176), value7);
                        bufferWriteU32Function(destinationBuffer, 200, value8);
                        bufferWriteU32Function(destinationBuffer, 204, bit32_bxor(bufferReadU32Function(destinationBuffer, 180), value8));
                    else
                        for k = 16, 144, 16 do
                            multiplier = multiplier * 2 % 229;
                            local value13 = bit32_bxor(bufferReadU32Function(destinationBuffer, k - 16), bufferReadU16Function(buffer131072, mathFloor(offset / 65536) * 2) * 65536 + bufferReadU16Function(buffer131072, offset % 65536 * 2), multiplier);
                            bufferWriteU32Function(destinationBuffer, k, value13);
                            local value14 = bit32_bxor(bufferReadU32Function(destinationBuffer, k - 12), value13);
                            bufferWriteU32Function(destinationBuffer, k + 4, value14);
                            local value15 = bit32_bxor(bufferReadU32Function(destinationBuffer, k - 8), value14);
                            bufferWriteU32Function(destinationBuffer, k + 8, value15);
                            local value9 = bit32_bxor(bufferReadU32Function(destinationBuffer, k - 4), value15);
                            bufferWriteU32Function(destinationBuffer, k + 12, value9);
                            offset = bit32_rrotate(value9, 8);
                        end;
                        local value10 = bit32_bxor(bufferReadU32Function(destinationBuffer, 144), bufferReadU16Function(buffer131072, mathFloor(offset / 65536) * 2) * 65536 + bufferReadU16Function(buffer131072, offset % 65536 * 2), 54);
                        bufferWriteU32Function(destinationBuffer, 160, value10);
                        local value11 = bit32_bxor(bufferReadU32Function(destinationBuffer, 148), value10);
                        bufferWriteU32Function(destinationBuffer, 164, value11);
                        local value12 = bit32_bxor(bufferReadU32Function(destinationBuffer, 152), value11);
                        bufferWriteU32Function(destinationBuffer, 168, value12);
                        bufferWriteU32Function(destinationBuffer, 172, bit32_bxor(bufferReadU32Function(destinationBuffer, 156), value12));
                    end;
                    return destinationBuffer;
                end;
                local processData = function(dataArray6, maxOffset, dataArray5, index3, unknownValue1, unknownValue2)
                    local valueA = bit32_bxor(bufferReadU8Function(dataArray5, index3), bufferReadU8Function(dataArray6, 0));
                    local valueB = bit32_bxor(bufferReadU8Function(dataArray5, index3 + 1), bufferReadU8Function(dataArray6, 1));
                    local byte1 = bit32_bxor(bufferReadU8Function(dataArray5, index3 + 2), bufferReadU8Function(dataArray6, 2));
                    local byte2 = bit32_bxor(bufferReadU8Function(dataArray5, index3 + 3), bufferReadU8Function(dataArray6, 3));
                    local byte3 = bit32_bxor(bufferReadU8Function(dataArray5, index3 + 4), bufferReadU8Function(dataArray6, 4));
                    local byte4 = bit32_bxor(bufferReadU8Function(dataArray5, index3 + 5), bufferReadU8Function(dataArray6, 5));
                    local byte5 = bit32_bxor(bufferReadU8Function(dataArray5, index3 + 6), bufferReadU8Function(dataArray6, 6));
                    local byte6 = bit32_bxor(bufferReadU8Function(dataArray5, index3 + 7), bufferReadU8Function(dataArray6, 7));
                    local byte7 = bit32_bxor(bufferReadU8Function(dataArray5, index3 + 8), bufferReadU8Function(dataArray6, 8));
                    local byte8 = bit32_bxor(bufferReadU8Function(dataArray5, index3 + 9), bufferReadU8Function(dataArray6, 9));
                    local byte9 = bit32_bxor(bufferReadU8Function(dataArray5, index3 + 10), bufferReadU8Function(dataArray6, 10));
                    local byte10 = bit32_bxor(bufferReadU8Function(dataArray5, index3 + 11), bufferReadU8Function(dataArray6, 11));
                    local byte11 = bit32_bxor(bufferReadU8Function(dataArray5, index3 + 12), bufferReadU8Function(dataArray6, 12));
                    local byte12 = bit32_bxor(bufferReadU8Function(dataArray5, index3 + 13), bufferReadU8Function(dataArray6, 13));
                    local byte13 = bit32_bxor(bufferReadU8Function(dataArray5, index3 + 14), bufferReadU8Function(dataArray6, 14));
                    local byte14 = bit32_bxor(bufferReadU8Function(dataArray5, index3 + 15), bufferReadU8Function(dataArray6, 15));
                    local value1 = valueA * 256 + byte4;
                    local value2 = byte4 * 256 + byte9;
                    local value3 = byte9 * 256 + byte14;
                    local index1 = byte14 * 256 + valueA;
                    local index2 = byte3 * 256 + byte8;
                    local index3 = byte8 * 256 + byte13;
                    local index4 = byte13 * 256 + byte2;
                    local index5 = byte2 * 256 + byte3;
                    local index6 = byte7 * 256 + byte12;
                    local index7 = byte12 * 256 + byte1;
                    local value1 = byte1 * 256 + byte6;
                    local value2 = byte6 * 256 + byte7;
                    local value3 = byte11 * 256 + valueB;
                    local value4 = valueB * 256 + byte5;
                    local value5 = byte5 * 256 + byte10;
                    local value6 = byte10 * 256 + byte11;
                    for offset = 16, maxOffset, 16 do
                        local value4 = bit32_bxor(bufferReadU8Function(buffer65536_1, value1), bufferReadU8Function(buffer65536_2, value3), bufferReadU8Function(dataArray6, offset));
                        local colorValue2 = bit32_bxor(bufferReadU8Function(buffer65536_1, value2), bufferReadU8Function(buffer65536_2, index1), bufferReadU8Function(dataArray6, offset + 1));
                        local colorValue3 = bit32_bxor(bufferReadU8Function(buffer65536_1, value3), bufferReadU8Function(buffer65536_2, value1), bufferReadU8Function(dataArray6, offset + 2));
                        local colorValue4 = bit32_bxor(bufferReadU8Function(buffer65536_1, index1), bufferReadU8Function(buffer65536_2, value2), bufferReadU8Function(dataArray6, offset + 3));
                        local colorValue5 = bit32_bxor(bufferReadU8Function(buffer65536_1, index2), bufferReadU8Function(buffer65536_2, index4), bufferReadU8Function(dataArray6, offset + 4));
                        local colorValue6 = bit32_bxor(bufferReadU8Function(buffer65536_1, index3), bufferReadU8Function(buffer65536_2, index5), bufferReadU8Function(dataArray6, offset + 5));
                        local colorValue7 = bit32_bxor(bufferReadU8Function(buffer65536_1, index4), bufferReadU8Function(buffer65536_2, index2), bufferReadU8Function(dataArray6, offset + 6));
                        local colorValue8 = bit32_bxor(bufferReadU8Function(buffer65536_1, index5), bufferReadU8Function(buffer65536_2, index3), bufferReadU8Function(dataArray6, offset + 7));
                        local colorValue9 = bit32_bxor(bufferReadU8Function(buffer65536_1, index6), bufferReadU8Function(buffer65536_2, value1), bufferReadU8Function(dataArray6, offset + 8));
                        local colorValue10 = bit32_bxor(bufferReadU8Function(buffer65536_1, index7), bufferReadU8Function(buffer65536_2, value2), bufferReadU8Function(dataArray6, offset + 9));
                        local colorValue11 = bit32_bxor(bufferReadU8Function(buffer65536_1, value1), bufferReadU8Function(buffer65536_2, index6), bufferReadU8Function(dataArray6, offset + 10));
                        local colorValue12 = bit32_bxor(bufferReadU8Function(buffer65536_1, value2), bufferReadU8Function(buffer65536_2, index7), bufferReadU8Function(dataArray6, offset + 11));
                        local colorValue13 = bit32_bxor(bufferReadU8Function(buffer65536_1, value3), bufferReadU8Function(buffer65536_2, value5), bufferReadU8Function(dataArray6, offset + 12));
                        local colorValue14 = bit32_bxor(bufferReadU8Function(buffer65536_1, value4), bufferReadU8Function(buffer65536_2, value6), bufferReadU8Function(dataArray6, offset + 13));
                        local colorValue15 = bit32_bxor(bufferReadU8Function(buffer65536_1, value5), bufferReadU8Function(buffer65536_2, value3), bufferReadU8Function(dataArray6, offset + 14));
                        local colorValue16 = bit32_bxor(bufferReadU8Function(buffer65536_1, value6), bufferReadU8Function(buffer65536_2, value4), bufferReadU8Function(dataArray6, offset + 15));
                        value1, value2, value3, index1, index2, index3, index4, index5, index6, index7, value1, value2, value3, value4, value5, value6 = value4 * 256 + colorValue6, colorValue6 * 256 + colorValue11, colorValue11 * 256 + colorValue16, colorValue16 * 256 + value4, colorValue5 * 256 + colorValue10, colorValue10 * 256 + colorValue15, colorValue15 * 256 + colorValue4, colorValue4 * 256 + colorValue5, colorValue9 * 256 + colorValue14, colorValue14 * 256 + colorValue3, colorValue3 * 256 + colorValue8, colorValue8 * 256 + colorValue9, colorValue13 * 256 + colorValue2, colorValue2 * 256 + colorValue7, colorValue7 * 256 + colorValue12, colorValue12 * 256 + colorValue13;
                    end;
                    bufferWriteU32Function(unknownValue1, unknownValue2, bit32_bxor(bufferReadU16Function(buffer131072, bit32_bxor(bufferReadU8Function(buffer65536_1, value6), bufferReadU8Function(buffer65536_2, value4), bufferReadU8Function(dataArray6, maxOffset + 31)) * 512 + bit32_bxor(bufferReadU8Function(buffer65536_1, value1), bufferReadU8Function(buffer65536_2, index6), bufferReadU8Function(dataArray6, maxOffset + 26)) * 2) * 65536 + bufferReadU16Function(buffer131072, bit32_bxor(bufferReadU8Function(buffer65536_1, index3), bufferReadU8Function(buffer65536_2, index5), bufferReadU8Function(dataArray6, maxOffset + 21)) * 512 + bit32_bxor(bufferReadU8Function(buffer65536_1, value1), bufferReadU8Function(buffer65536_2, value3), bufferReadU8Function(dataArray6, maxOffset + 16)) * 2), bufferReadU32Function(dataArray6, maxOffset + 32)));
                    bufferWriteU32Function(unknownValue1, unknownValue2 + 4, bit32_bxor(bufferReadU16Function(buffer131072, bit32_bxor(bufferReadU8Function(buffer65536_1, index1), bufferReadU8Function(buffer65536_2, value2), bufferReadU8Function(dataArray6, maxOffset + 19)) * 512 + bit32_bxor(bufferReadU8Function(buffer65536_1, value5), bufferReadU8Function(buffer65536_2, value3), bufferReadU8Function(dataArray6, maxOffset + 30)) * 2) * 65536 + bufferReadU16Function(buffer131072, bit32_bxor(bufferReadU8Function(buffer65536_1, index7), bufferReadU8Function(buffer65536_2, value2), bufferReadU8Function(dataArray6, maxOffset + 25)) * 512 + bit32_bxor(bufferReadU8Function(buffer65536_1, index2), bufferReadU8Function(buffer65536_2, index4), bufferReadU8Function(dataArray6, maxOffset + 20)) * 2), bufferReadU32Function(dataArray6, maxOffset + 36)));
                    bufferWriteU32Function(unknownValue1, unknownValue2 + 8, bit32_bxor(bufferReadU16Function(buffer131072, bit32_bxor(bufferReadU8Function(buffer65536_1, index5), bufferReadU8Function(buffer65536_2, index3), bufferReadU8Function(dataArray6, maxOffset + 23)) * 512 + bit32_bxor(bufferReadU8Function(buffer65536_1, value3), bufferReadU8Function(buffer65536_2, value1), bufferReadU8Function(dataArray6, maxOffset + 18)) * 2) * 65536 + bufferReadU16Function(buffer131072, bit32_bxor(bufferReadU8Function(buffer65536_1, value4), bufferReadU8Function(buffer65536_2, value6), bufferReadU8Function(dataArray6, maxOffset + 29)) * 512 + bit32_bxor(bufferReadU8Function(buffer65536_1, index6), bufferReadU8Function(buffer65536_2, value1), bufferReadU8Function(dataArray6, maxOffset + 24)) * 2), bufferReadU32Function(dataArray6, maxOffset + 40)));
                    bufferWriteU32Function(unknownValue1, unknownValue2 + 12, bit32_bxor(bufferReadU16Function(buffer131072, bit32_bxor(bufferReadU8Function(buffer65536_1, value2), bufferReadU8Function(buffer65536_2, index7), bufferReadU8Function(dataArray6, maxOffset + 27)) * 512 + bit32_bxor(bufferReadU8Function(buffer65536_1, index4), bufferReadU8Function(buffer65536_2, index2), bufferReadU8Function(dataArray6, maxOffset + 22)) * 2) * 65536 + bufferReadU16Function(buffer131072, bit32_bxor(bufferReadU8Function(buffer65536_1, value2), bufferReadU8Function(buffer65536_2, index1), bufferReadU8Function(dataArray6, maxOffset + 17)) * 512 + bit32_bxor(bufferReadU8Function(buffer65536_1, value3), bufferReadU8Function(buffer65536_2, value5), bufferReadU8Function(dataArray6, maxOffset + 28)) * 2), bufferReadU32Function(dataArray6, maxOffset + 44)));
                    return ;
                end;
                local processDataFunction = function(dataBuffer2, unknownIndex, dataBuffer1, index1, unknownValue1, offset)
                    local data1 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataBuffer1, index1) * 256 + bufferReadU8Function(dataBuffer2, unknownIndex + 32)), bufferReadU8Function(dataBuffer2, unknownIndex + 16));
                    local data2 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataBuffer1, index1 + 13) * 256 + bufferReadU8Function(dataBuffer2, unknownIndex + 45)), bufferReadU8Function(dataBuffer2, unknownIndex + 17));
                    local data3 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataBuffer1, index1 + 10) * 256 + bufferReadU8Function(dataBuffer2, unknownIndex + 42)), bufferReadU8Function(dataBuffer2, unknownIndex + 18));
                    local data4 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataBuffer1, index1 + 7) * 256 + bufferReadU8Function(dataBuffer2, unknownIndex + 39)), bufferReadU8Function(dataBuffer2, unknownIndex + 19));
                    local data5 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataBuffer1, index1 + 4) * 256 + bufferReadU8Function(dataBuffer2, unknownIndex + 36)), bufferReadU8Function(dataBuffer2, unknownIndex + 20));
                    local data6 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataBuffer1, index1 + 1) * 256 + bufferReadU8Function(dataBuffer2, unknownIndex + 33)), bufferReadU8Function(dataBuffer2, unknownIndex + 21));
                    local data7 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataBuffer1, index1 + 14) * 256 + bufferReadU8Function(dataBuffer2, unknownIndex + 46)), bufferReadU8Function(dataBuffer2, unknownIndex + 22));
                    local data8 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataBuffer1, index1 + 11) * 256 + bufferReadU8Function(dataBuffer2, unknownIndex + 43)), bufferReadU8Function(dataBuffer2, unknownIndex + 23));
                    local data9 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataBuffer1, index1 + 8) * 256 + bufferReadU8Function(dataBuffer2, unknownIndex + 40)), bufferReadU8Function(dataBuffer2, unknownIndex + 24));
                    local data10 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataBuffer1, index1 + 5) * 256 + bufferReadU8Function(dataBuffer2, unknownIndex + 37)), bufferReadU8Function(dataBuffer2, unknownIndex + 25));
                    local data11 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataBuffer1, index1 + 2) * 256 + bufferReadU8Function(dataBuffer2, unknownIndex + 34)), bufferReadU8Function(dataBuffer2, unknownIndex + 26));
                    local value1 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataBuffer1, index1 + 15) * 256 + bufferReadU8Function(dataBuffer2, unknownIndex + 47)), bufferReadU8Function(dataBuffer2, unknownIndex + 27));
                    local value2 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataBuffer1, index1 + 12) * 256 + bufferReadU8Function(dataBuffer2, unknownIndex + 44)), bufferReadU8Function(dataBuffer2, unknownIndex + 28));
                    local value3 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataBuffer1, index1 + 9) * 256 + bufferReadU8Function(dataBuffer2, unknownIndex + 41)), bufferReadU8Function(dataBuffer2, unknownIndex + 29));
                    local value4 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataBuffer1, index1 + 6) * 256 + bufferReadU8Function(dataBuffer2, unknownIndex + 38)), bufferReadU8Function(dataBuffer2, unknownIndex + 30));
                    local value5 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(dataBuffer1, index1 + 3) * 256 + bufferReadU8Function(dataBuffer2, unknownIndex + 35)), bufferReadU8Function(dataBuffer2, unknownIndex + 31));
                    local index1 = data1 * 256 + data2;
                    local index2 = data2 * 256 + data3;
                    local index3 = data3 * 256 + data4;
                    local dataValue2 = data4 * 256 + data1;
                    local dataValue3 = data5 * 256 + data6;
                    local dataValue4 = data6 * 256 + data7;
                    local dataValue5 = data7 * 256 + data8;
                    local dataValue5 = data8 * 256 + data5;
                    local dataValue6 = data9 * 256 + data10;
                    local dataValue7 = data10 * 256 + data11;
                    local dataValue8 = data11 * 256 + value1;
                    local dataValue9 = value1 * 256 + data9;
                    local dataValue10 = value2 * 256 + value3;
                    local dataValue11 = value3 * 256 + value4;
                    local dataValue12 = value4 * 256 + value5;
                    local dataValue13 = value5 * 256 + value2;
                    for bitOffset = unknownIndex, 16, -16 do
                        local lookupValue1 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, index1) * 256 + bufferReadU8Function(buffer65536_5, index3)), bufferReadU8Function(dataBuffer2, bitOffset));
                        local extractedBit1 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, dataValue11) * 256 + bufferReadU8Function(buffer65536_5, dataValue13)), bufferReadU8Function(dataBuffer2, bitOffset + 1));
                        local extractedBit2 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, dataValue8) * 256 + bufferReadU8Function(buffer65536_5, dataValue6)), bufferReadU8Function(dataBuffer2, bitOffset + 2));
                        local extractedBit3 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, dataValue5) * 256 + bufferReadU8Function(buffer65536_5, dataValue4)), bufferReadU8Function(dataBuffer2, bitOffset + 3));
                        local extractedBit4 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, dataValue3) * 256 + bufferReadU8Function(buffer65536_5, dataValue5)), bufferReadU8Function(dataBuffer2, bitOffset + 4));
                        local extractedBit5 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, index2) * 256 + bufferReadU8Function(buffer65536_5, dataValue2)), bufferReadU8Function(dataBuffer2, bitOffset + 5));
                        local extractedBit6 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, dataValue12) * 256 + bufferReadU8Function(buffer65536_5, dataValue10)), bufferReadU8Function(dataBuffer2, bitOffset + 6));
                        local extractedBit7 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, dataValue9) * 256 + bufferReadU8Function(buffer65536_5, dataValue7)), bufferReadU8Function(dataBuffer2, bitOffset + 7));
                        local extractedBit8 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, dataValue6) * 256 + bufferReadU8Function(buffer65536_5, dataValue8)), bufferReadU8Function(dataBuffer2, bitOffset + 8));
                        local extractedBit9 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, dataValue4) * 256 + bufferReadU8Function(buffer65536_5, dataValue5)), bufferReadU8Function(dataBuffer2, bitOffset + 9));
                        local extractedBit10 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, index3) * 256 + bufferReadU8Function(buffer65536_5, index1)), bufferReadU8Function(dataBuffer2, bitOffset + 10));
                        local extractedBit11 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, dataValue13) * 256 + bufferReadU8Function(buffer65536_5, dataValue11)), bufferReadU8Function(dataBuffer2, bitOffset + 11));
                        local extractedBit12 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, dataValue10) * 256 + bufferReadU8Function(buffer65536_5, dataValue12)), bufferReadU8Function(dataBuffer2, bitOffset + 12));
                        local extractedBit13 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, dataValue7) * 256 + bufferReadU8Function(buffer65536_5, dataValue9)), bufferReadU8Function(dataBuffer2, bitOffset + 13));
                        local extractedBit14 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, dataValue5) * 256 + bufferReadU8Function(buffer65536_5, dataValue3)), bufferReadU8Function(dataBuffer2, bitOffset + 14));
                        local extractedBit15 = bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, dataValue2) * 256 + bufferReadU8Function(buffer65536_5, index2)), bufferReadU8Function(dataBuffer2, bitOffset + 15));
                        index1, index2, index3, dataValue2, dataValue3, dataValue4, dataValue5, dataValue5, dataValue6, dataValue7, dataValue8, dataValue9, dataValue10, dataValue11, dataValue12, dataValue13 = lookupValue1 * 256 + extractedBit1, extractedBit1 * 256 + extractedBit2, extractedBit2 * 256 + extractedBit3, extractedBit3 * 256 + lookupValue1, extractedBit4 * 256 + extractedBit5, extractedBit5 * 256 + extractedBit6, extractedBit6 * 256 + extractedBit7, extractedBit7 * 256 + extractedBit4, extractedBit8 * 256 + extractedBit9, extractedBit9 * 256 + extractedBit10, extractedBit10 * 256 + extractedBit11, extractedBit11 * 256 + extractedBit8, extractedBit12 * 256 + extractedBit13, extractedBit13 * 256 + extractedBit14, extractedBit14 * 256 + extractedBit15, extractedBit15 * 256 + extractedBit12;
                    end;
                    bufferWriteU32Function(unknownValue1, offset, bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, dataValue5) * 256 + bufferReadU8Function(buffer65536_5, dataValue4)), bufferReadU8Function(dataBuffer2, 3)) * 16777216 + bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, dataValue8) * 256 + bufferReadU8Function(buffer65536_5, dataValue6)), bufferReadU8Function(dataBuffer2, 2)) * 65536 + bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, dataValue11) * 256 + bufferReadU8Function(buffer65536_5, dataValue13)), bufferReadU8Function(dataBuffer2, 1)) * 256 + bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, index1) * 256 + bufferReadU8Function(buffer65536_5, index3)), bufferReadU8Function(dataBuffer2, 0)));
                    bufferWriteU32Function(unknownValue1, offset + 4, bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, dataValue9) * 256 + bufferReadU8Function(buffer65536_5, dataValue7)), bufferReadU8Function(dataBuffer2, 7)) * 16777216 + bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, dataValue12) * 256 + bufferReadU8Function(buffer65536_5, dataValue10)), bufferReadU8Function(dataBuffer2, 6)) * 65536 + bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, index2) * 256 + bufferReadU8Function(buffer65536_5, dataValue2)), bufferReadU8Function(dataBuffer2, 5)) * 256 + bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, dataValue3) * 256 + bufferReadU8Function(buffer65536_5, dataValue5)), bufferReadU8Function(dataBuffer2, 4)));
                    bufferWriteU32Function(unknownValue1, offset + 8, bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, dataValue13) * 256 + bufferReadU8Function(buffer65536_5, dataValue11)), bufferReadU8Function(dataBuffer2, 11)) * 16777216 + bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, index3) * 256 + bufferReadU8Function(buffer65536_5, index1)), bufferReadU8Function(dataBuffer2, 10)) * 65536 + bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, dataValue4) * 256 + bufferReadU8Function(buffer65536_5, dataValue5)), bufferReadU8Function(dataBuffer2, 9)) * 256 + bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, dataValue6) * 256 + bufferReadU8Function(buffer65536_5, dataValue8)), bufferReadU8Function(dataBuffer2, 8)));
                    bufferWriteU32Function(unknownValue1, offset + 12, bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, dataValue2) * 256 + bufferReadU8Function(buffer65536_5, index2)), bufferReadU8Function(dataBuffer2, 15)) * 16777216 + bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, dataValue5) * 256 + bufferReadU8Function(buffer65536_5, dataValue3)), bufferReadU8Function(dataBuffer2, 14)) * 65536 + bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, dataValue7) * 256 + bufferReadU8Function(buffer65536_5, dataValue9)), bufferReadU8Function(dataBuffer2, 13)) * 256 + bit32_bxor(bufferReadU8Function(buffer65536_3, bufferReadU8Function(buffer65536_4, dataValue10) * 256 + bufferReadU8Function(buffer65536_5, dataValue12)), bufferReadU8Function(dataBuffer2, 12)));
                    return ;
                end;
                local dataBuffer1 = bufferCreateFunction(256);
                local dataBuffer2 = bufferCreateFunction(256);
                local dataBuffer3 = bufferCreateFunction(256);
                local dataBuffer4 = bufferCreateFunction(256);
                local dataBuffer5 = bufferCreateFunction(256);
                local key = 1;
                local seed = 1;
                local someValue1 = nil;
                local calculateChecksum = function(keyByte, data)
                    local hashValue = 0;
                    for bitIndex = 0, 7, 1 do
                        if data % 2 == 1 then
                            hashValue = bit32_bxor(hashValue, keyByte);
                        end;
                        keyByte = if not (128 <= keyByte) then keyByte * 2 % 256 else bit32_bxor(keyByte * 2 % 256, 27);
                        data = mathFloor(data / 2);
                    end;
                    return hashValue;
                end;
                bufferWriteU8Function(dataBuffer1, 0, 99);
                for i = 1, 255, 1 do
                    key = bit32_bxor(key, key * 2, key < 128 and 0 or 27) % 256;
                    local intermediateValue1 = bit32_bxor(seed, seed * 2);
                    local intermediateValue2 = bit32_bxor(intermediateValue1, intermediateValue1 * 4);
                    seed = bit32_bxor(intermediateValue2, intermediateValue2 * 16) % 256;
                    if 128 <= seed then
                        seed = bit32_bxor(seed, 9);
                    end;
                    local combinedValue = bit32_bxor(seed, seed % 128 * 2 + seed / 128, seed % 64 * 4 + seed / 64, seed % 32 * 8 + seed / 32, seed % 16 * 16 + seed / 16, 99);
                    bufferWriteU8Function(dataBuffer1, key, combinedValue);
                    bufferWriteU8Function(dataBuffer2, combinedValue, key);
                    bufferWriteU8Function(dataBuffer3, key, calculateChecksum(3, key));
                    bufferWriteU8Function(dataBuffer4, key, calculateChecksum(9, key));
                    bufferWriteU8Function(dataBuffer5, key, calculateChecksum(11, key));
                end;
                local someValue2 = nil;
                local someValue3 = nil;
                local someValue4 = nil;
                local someValue5 = nil;
                local dataIndex = 0;
                for j = 0, 255, 1 do
                    local valueFromBuffer1 = bufferReadU8Function(dataBuffer1, j);
                    local multipliedValue = valueFromBuffer1 * 256;
                    local colorPalette1, colorPalette2, colorPalette3 = calculateChecksum(2, valueFromBuffer1), calculateChecksum(13, j), calculateChecksum(14, j);
                    for colorIndex = 0, 255, 1 do
                        local valueFromBuffer2 = bufferReadU8Function(dataBuffer1, colorIndex);
                        bufferWriteU16Function(buffer131072, dataIndex * 2, multipliedValue + valueFromBuffer2);
                        bufferWriteU8Function(buffer65536_3, dataIndex, bufferReadU8Function(dataBuffer2, bit32_bxor(j, colorIndex)));
                        bufferWriteU8Function(buffer65536_1, dataIndex, bit32_bxor(colorPalette1, bufferReadU8Function(dataBuffer3, valueFromBuffer2)));
                        bufferWriteU8Function(buffer65536_2, dataIndex, bit32_bxor(valueFromBuffer1, valueFromBuffer2));
                        bufferWriteU8Function(buffer65536_4, dataIndex, bit32_bxor(colorPalette3, bufferReadU8Function(dataBuffer5, colorIndex)));
                        bufferWriteU8Function(buffer65536_5, dataIndex, bit32_bxor(colorPalette2, bufferReadU8Function(dataBuffer4, colorIndex)));
                        dataIndex = dataIndex + 1;
                    end;
                end;
                local newIndexHandler = function(L_1022, target)
                    return errorFunction(string.format("%s cannot be assigned to", tostring(target)));
                end;
                local toStringFunction = function()
                    return "AesCipher";
                end;
                local encryptKey = function(inputKey, offset)
                    local isBuffer = typeofFunction(inputKey) == "buffer";
                    local keyLength = (isBuffer and { [1] = bufferLenFunction(inputKey) } or { [1] = #inputKey })[1];
                    local keyLengthCheck = keyLength == 32 and 240 or keyLength == 16 and 176 or keyLength == 24 and 208 or errorFunction("Key must be either 16, 24 or 32 bytes long");
                    return copyData(inputKey, keyLength, offset or bufferCreateFunction(keyLengthCheck), isBuffer);
                end;
                return (function(unknownValue, padding, initializationVector)
                    local keyData = bufferLenFunction(unknownValue);
                    local blockSize = nil;
                    local keySegment = nil;
                    local roundKeys = bufferToStringFunction(unknownValue);
                    if keyData == 240 then
                        blockSize = 192;
                        keySegment = stringSubFunction(roundKeys, 1, 32);
                    elseif keyData == 208 then
                        blockSize = 160;
                        keySegment = stringSubFunction(roundKeys, 1, 24);
                    elseif keyData == 176 then
                        blockSize = 128;
                        keySegment = stringSubFunction(roundKeys, 1, 16);
                    else
                        errorFunction("Round keys must be either 240, 208 or 128 bytes long");
                    end;
                    local cipherState = unknownValue;
                    local cipherMode = padding or cipherModes;
                    local forwardModeFunction = cipherMode.FwdMode;
                    local inverseModeFunction = cipherMode.InvMode;
                    local segmentSize = cipherMode.SegmentSize or 16;
                    local paddingSettings = initializationVector or paddingFunctions;
                    local padFunction = paddingSettings.Pad;
                    local unpadFunction = paddingSettings.Unpad;
                    local trueValue = newproxyFunction(true);
                    local aesCipherMetatable = getmetatableFunction(trueValue);
                    local encryptBlockFunction = function(arg1, arg2, arg3, arg4)
                        processData(cipherState, blockSize, arg1, arg2, arg3, arg4);
                        return ;
                    end;
                    local decryptBlockFunction = function(arg5, arg6, arg7, arg8)
                        processDataFunction(cipherState, blockSize, arg5, arg6, arg7, arg8);
                        return ;
                    end;
                    local encryptFunction = function(aesCipherObject, inputData, inputBuffer, ...)
                        local inputType = typeofFunction(inputData);
                        local inputBuffer = (inputType == "buffer" and { [1] = inputData } or { [1] = (inputType == "string" and { [1] = bufferFromStringFunction(inputData) } or { [1] = errorFunction(string.format("Unable to cast %s to buffer", tostring(inputType))) })[1] })[1];
                        local initializationVectorBuffer = typeofFunction(inputBuffer) == "buffer" and inputBuffer;
                        if aesCipherObject ~= trueValue then
                            return aesCipherObject:Encrypt(inputBuffer, initializationVectorBuffer, ...);
                        end;
                        if blockSize then
                            local paddedInputBuffer = padFunction(inputBuffer, initializationVectorBuffer, segmentSize);
                            forwardModeFunction(encryptBlockFunction, decryptBlockFunction, (paddingSettings.Overwrite == false and { [1] = inputBuffer } or { [1] = paddedInputBuffer })[1], paddedInputBuffer, cipherMode, ...);
                            return paddedInputBuffer;
                        end;
                        errorFunction("AesCipher object's already destroyed");
                        return bufferCreateFunction(0);
                    end;
                    local encryptBlock = function(aesCipherObject, inputData, outputData, encryptionKey1, encryptionKey2)
                        if aesCipherObject ~= trueValue then
                            aesCipherObject:EncryptBlock(inputData, outputData, encryptionKey1, encryptionKey2);
                        elseif blockSize then
                            processData(cipherState, blockSize, inputData, outputData, encryptionKey1 or inputData, encryptionKey2 or outputData);
                        else
                            errorFunction("AesCipher object's already destroyed");
                        end;
                        return ;
                    end;
                    local decryptFunction = function(aesCipherObject, inputData, inputBuffer2, ...)
                        local inputType = typeofFunction(inputData);
                        local inputBuffer = (inputType == "buffer" and { [1] = inputData } or { [1] = (inputType == "string" and { [1] = bufferFromStringFunction(inputData) } or { [1] = errorFunction(string.format("Unable to cast %s to buffer", tostring(inputType))) })[1] })[1];
                        local initializationVectorBuffer = typeofFunction(inputBuffer2) == "buffer" and inputBuffer2;
                        if aesCipherObject ~= trueValue then
                            return aesCipherObject:Decrypt(inputBuffer, initializationVectorBuffer, ...);
                        end;
                        if blockSize then
                            local isOverwriteEnabled = paddingSettings.Overwrite;
                            local decryptedValue = (isOverwriteEnabled == nil and { [1] = bufferCreateFunction(bufferLenFunction(inputBuffer)) } or { [1] = (isOverwriteEnabled and { [1] = inputBuffer } or { [1] = initializationVectorBuffer or bufferCreateFunction(bufferLenFunction(inputBuffer)) })[1] })[1];
                            inverseModeFunction(encryptBlockFunction, decryptBlockFunction, inputBuffer, decryptedValue, cipherMode, ...);
                            return unpadFunction(decryptedValue, initializationVectorBuffer, segmentSize);
                        end;
                        errorFunction("AesCipher object's already destroyed");
                        return bufferCreateFunction(0);
                    end;
                    local decryptBlock = function(aesCipherObject, encryptedData, decryptedData, decryptionKey1, decryptionKey2)
                        if aesCipherObject ~= trueValue then
                            aesCipherObject:DecryptBlock(encryptedData, decryptedData, decryptionKey1, decryptionKey2);
                        elseif blockSize then
                            processDataFunction(cipherState, blockSize, encryptedData, decryptedData, decryptionKey1 or encryptedData, decryptionKey2 or decryptedData);
                        else
                            errorFunction("AesCipher object's already destroyed");
                        end;
                        return ;
                    end;
                    local destroyCipher = function(cipherObject)
                        if cipherObject ~= trueValue then
                            cipherObject:Destroy();
                        elseif blockSize then
                            roundKeys, cipherState, blockSize, forwardModeFunction, inverseModeFunction, cipherMode, paddingSettings, keySegment, keyData = nil, nil, nil, nil, nil, nil, nil, nil, nil;
                        else
                            errorFunction("AesCipher object's already destroyed");
                        end;
                        return ;
                    end;
                    local aesCipherMethods = { Encrypt = encryptFunction, Decrypt = decryptFunction, EncryptBlock = encryptBlock, DecryptBlock = decryptBlock, Destroy = destroyCipher };
                    local aesCipherProperties = { Key = keySegment, RoundKeys = roundKeys, Mode = cipherMode, Padding = paddingSettings, Length = keyData };
                    aesCipherMetatable.__index = function(L_1092, cipherMemberName)
                        if aesCipherMethods[cipherMemberName] then
                            return aesCipherMethods[cipherMemberName];
                        end;
                        if blockSize and aesCipherProperties[cipherMemberName] then
                            return aesCipherProperties[cipherMemberName];
                        end;
                        if blockSize then
                            errorFunction(("%s is not a valid member of AesCipher"):format(cipherMemberName));
                        else
                            errorFunction("AesCipher object's already destroyed");
                        end;
                        return ;
                    end;
                    aesCipherMetatable.__newindex = newIndexHandler;
                    aesCipherMetatable.__tostring = toStringFunction;
                    aesCipherMetatable.__len = function()
                        return keyData or errorFunction("AesCipher object's destroyed");
                    end;
                    aesCipherMetatable.__metatable = "AesCipher object: Metatable's locked";
                    return trueValue;
                end)(encryptKey(unknownValue), cipherModes, paddingFunctions);
            end,
            ["\000ECC"] = function(L_1094)
                local addConstantToVector = function(vector)
                    for i = 0, 15, 1 do
                        vector[i] = vector[i] + 65536;
                        local integerPart = vector[i] / 65536 - vector[i] / 65536 % 1;
                        if i < 15 then
                            vector[i + 1] = vector[i + 1] + integerPart - 1;
                        else
                            vector[0] = vector[0] + 38 * (integerPart - 1);
                        end;
                        vector[i] = vector[i] - integerPart * 65536;
                    end;
                    return ;
                end;
                local swapVectorElements = function(vectorA, array2, rotationFactor)
                    for i = 0, 15, 1 do
                        vectorA[i], array2[i] = vectorA[i] * ((rotationFactor - 1) % 2) + array2[i] * rotationFactor, array2[i] * ((rotationFactor - 1) % 2) + vectorA[i] * rotationFactor;
                    end;
                    return ;
                end;
                local convertBytesToWords = function(wordVector, array5)
                    for i = 0, 15, 1 do
                        wordVector[i] = array5[2 * i] + array5[2 * i + 1] * 256;
                    end;
                    wordVector[15] = wordVector[15] % 32768;
                    return ;
                end;
                local processVector = function(array8, array9)
                    local vectorA = {};
                    local vectorB = {};
                    for i = 0, 15, 1 do
                        vectorA[i] = array9[i];
                    end;
                    addConstantToVector(vectorA);
                    addConstantToVector(vectorA);
                    addConstantToVector(vectorA);
                    local constants = { [0] = 65517, [15] = 32767 };
                    for index = 1, 14, 1 do
                        constants[index] = 65535;
                    end;
                    for j = 0, 1, 1 do
                        vectorB[0] = vectorA[0] - constants[0];
                        for k = 1, 15, 1 do
                            vectorB[k] = vectorA[k] - constants[k] - (vectorB[k - 1] / 65536 - vectorB[k - 1] / 65536 % 1) % 2;
                            vectorB[k - 1] = (vectorB[k - 1] + 65536) % 65536;
                        end;
                        local bitValue = (vectorB[15] / 65536 - vectorB[15] / 65536 % 1) % 2;
                        swapVectorElements(vectorA, vectorB, 1 - bitValue);
                    end;
                    for l = 0, 15, 1 do
                        array8[2 * l] = vectorA[l] % 256;
                        array8[2 * l + 1] = vectorA[l] / 256 - vectorA[l] / 256 % 1;
                    end;
                    return ;
                end;
                local addVectors = function(resultVector, array11, vectorComponent2)
                    for i = 0, 15, 1 do
                        resultVector[i] = array11[i] + vectorComponent2[i];
                    end;
                    return ;
                end;
                local subtractVectors = function(resultVector, array13, vectorComponent4)
                    for i = 0, 15, 1 do
                        resultVector[i] = array13[i] - vectorComponent4[i];
                    end;
                    return ;
                end;
                local multiplyVectors = function(outputVector, matrixRow1, matrixRow2)
                    local resultVector = {};
                    for m = 0, 31, 1 do
                        resultVector[m] = 0;
                    end;
                    for rowIndex = 0, 15, 1 do
                        for colIndex = 0, 15, 1 do
                            resultVector[rowIndex + colIndex] = resultVector[rowIndex + colIndex] + matrixRow1[rowIndex] * matrixRow2[colIndex];
                        end;
                    end;
                    for index2 = 0, 14, 1 do
                        resultVector[index2] = resultVector[index2] + 38 * resultVector[index2 + 16];
                    end;
                    for index = 0, 15, 1 do
                        outputVector[index] = resultVector[index];
                    end;
                    addConstantToVector(outputVector);
                    addConstantToVector(outputVector);
                    return ;
                end;
                local transformVector = function(destinationTable, sourceTable)
                    local vectorA = {};
                    for i = 0, 15, 1 do
                        vectorA[i] = sourceTable[i];
                    end;
                    for loopIndex = 253, 0, -1 do
                        multiplyVectors(vectorA, vectorA, vectorA);
                        if loopIndex ~= 2 and loopIndex ~= 4 then
                            multiplyVectors(vectorA, vectorA, sourceTable);
                        end;
                    end;
                    for index = 0, 15, 1 do
                        destinationTable[index] = vectorA[index];
                    end;
                    return ;
                end;
                local calculateSharedKey = function(unknownValue, sourceArray, unknownValue)
                    local table1 = {};
                    local table2 = {};
                    local table3 = {};
                    local table4 = {};
                    local table5 = {};
                    local tempTable = {};
                    local table6 = {};
                    local table7 = {};
                    convertBytesToWords(table6, unknownValue);
                    for index = 0, 15, 1 do
                        local value = table6[index];
                        table1[index] = 0;
                        table2[index] = value;
                        table3[index] = 0;
                        table4[index] = 0;
                    end;
                    table1[0] = 1;
                    table4[0] = 1;
                    for index = 0, 30, 1 do
                        table7[index] = sourceArray[index];
                    end;
                    table7[0] = table7[0] - table7[0] % 8;
                    table7[31] = sourceArray[31] % 64 + 64;
                    for bitIndex = 254, 0, -1 do
                        local bitValue = (table7[bitIndex / 8 - bitIndex / 8 % 1] / 2 ^ (bitIndex % 8) - table7[bitIndex / 8 - bitIndex / 8 % 1] / 2 ^ (bitIndex % 8) % 1) % 2;
                        swapVectorElements(table1, table2, bitValue);
                        swapVectorElements(table3, table4, bitValue);
                        addVectors(table5, table1, table3);
                        subtractVectors(table1, table1, table3);
                        addVectors(table3, table2, table4);
                        subtractVectors(table2, table2, table4);
                        multiplyVectors(table4, table5, table5);
                        multiplyVectors(tempTable, table1, table1);
                        multiplyVectors(table1, table3, table1);
                        multiplyVectors(table3, table2, table5);
                        addVectors(table5, table1, table3);
                        subtractVectors(table1, table1, table3);
                        multiplyVectors(table2, table1, table1);
                        subtractVectors(table3, table4, tempTable);
                        multiplyVectors(table1, table3, { [0] = 56129, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 });
                        addVectors(table1, table1, table4);
                        multiplyVectors(table3, table3, table1);
                        multiplyVectors(table1, table4, tempTable);
                        multiplyVectors(table4, table2, table6);
                        multiplyVectors(table2, table5, table5);
                        swapVectorElements(table1, table2, bitValue);
                        swapVectorElements(table3, table4, bitValue);
                    end;
                    transformVector(table3, table3);
                    multiplyVectors(table1, table1, table3);
                    processVector(unknownValue, table1);
                    return ;
                end;
                local generateKeyPair = function(randomFunction)
                    local randomByteGenerator = randomFunction or function()
                        return math.random(0, 255);
                    end;
                    local key1 = {};
                    local tempTable = {};
                    for index = 0, 31, 1 do
                        key1[index] = randomByteGenerator();
                    end;
                    local initialValues = { [0] = 9 };
                    for index3 = 1, 31, 1 do
                        initialValues[index3] = 0;
                    end;
                    calculateSharedKey(tempTable, key1, initialValues);
                    return key1, tempTable;
                end;
                local getSharedKey = function(unknownValue, arg9)
                    local sharedKey = {};
                    calculateSharedKey(sharedKey, unknownValue, arg9);
                    return sharedKey;
                end;
                return { generate_keypair = generateKeyPair, get_shared_key = getSharedKey };
            end,
            ["\000HASH"] = function(hashFunction)
                local createProxy = function(propertyGetter)
                    local proxyTable = {};
                    local metatable = setmetatableFunction({}, proxyTable);
                    proxyTable.__index = function(L_1180, propertyName)
                        local propertyValue = propertyGetter(propertyName);
                        metatable[propertyName] = propertyValue;
                        return propertyValue;
                    end;
                    return metatable;
                end;
                local matrixMultiply = function(dataValues, base)
                    return function(input1, input2)
                        local accumulator = 0;
                        local multiplier = 1;
                        while input1 ~= 0 and input2 ~= 0 do
                            local remainder1 = input1 % base;
                            local remainder = input2 % base;
                            accumulator = accumulator + dataValues[remainder1][remainder] * multiplier;
                            input1 = (input1 - remainder1) / base;
                            input2 = (input2 - remainder) / base;
                            multiplier = multiplier * base;
                        end;
                        return accumulator + (input1 + input2) * multiplier;
                    end;
                end;
                local optimizedMatrixMultiply = (function(exponent)
                    local multiplyByTwo = matrixMultiply(exponent, 2);
                    local curryFunction = createProxy(function(arg1)
                        return createProxy(function(unknownValue)
                            return multiplyByTwo(arg1, unknownValue);
                        end);
                    end);
                    return matrixMultiply(curryFunction, 2 ^ (exponent.n or 1));
                end)({ [0] = { [0] = 0, [1] = 1 }, { [0] = 1, [1] = 0 }, n = 4 });
                local combineValues;
                combineValues = function(inputValue, value2, optionalValue, ...)
                    local localNilValue = nil;
                    if value2 then
                        local value1Mod = inputValue % 4294967296;
                        local remainder2 = value2 % 4294967296;
                        local combinedValue = optimizedMatrixMultiply(value1Mod, remainder2);
                        if optionalValue then
                            combinedValue = combineValues(combinedValue, optionalValue, ...);
                        end;
                        return combinedValue;
                    end;
                    if inputValue then
                        return inputValue % 4294967296;
                    end;
                    return 0;
                end;
                local bitwiseOperation = function(inputValue, value4, bitmaskValue2, ...)
                    local localNilValue = nil;
                    if value4 then
                        local value3Mod = inputValue % 4294967296;
                        local value4Mod = value4 % 4294967296;
                        local bitwiseResult = (value3Mod + value4Mod - optimizedMatrixMultiply(value3Mod, value4Mod)) / 2;
                        if bitmaskValue2 then
                            bitwiseResult = bit32_band(bitwiseResult, bitmaskValue2, ...);
                        end;
                        return bitwiseResult;
                    end;
                    if inputValue then
                        return inputValue % 4294967296;
                    end;
                    return 4294967295;
                end;
                local bitwiseComplementFunction2 = function(valueToComplement2)
                    return (-1 - valueToComplement2) % 4294967296;
                end;
                local rightShift = function(valueToShift, shiftAmount)
                    if shiftAmount < 0 then
                        return lshift(valueToShift, -shiftAmount);
                    end;
                    return math.floor(valueToShift % 4294967296 / 2 ^ shiftAmount);
                end;
                local shiftRightBounded = function(inputValue, shiftAmount)
                    if 31 < shiftAmount or shiftAmount < -31 then
                        return 0;
                    end;
                    return rightShift(inputValue % 4294967296, shiftAmount);
                end;
                local lshift = function(baseValue, shiftValue)
                    if shiftValue < 0 then
                        return shiftRightBounded(baseValue, -shiftValue);
                    end;
                    return baseValue * 2 ^ shiftValue % 4294967296;
                end;
                local extractBits = function(inputValue, shiftAmount2)
                    local value5Mod = inputValue % 4294967296;
                    local bitCount = shiftAmount2 % 32;
                    local maskedValue = bitwiseOperation(value5Mod, 2 ^ bitCount - 1);
                    return shiftRightBounded(value5Mod, bitCount) + lshift(maskedValue, 32 - bitCount);
                end;
                local hashConstants = { 1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298 };
                local bytesToHex = function(inputString)
                    return string.gsub(inputString, ".", function(char)
                        return string.format("%02x", string.byte(char));
                    end);
                end;
                local numberToBytes = function(valueToDivide2, stringLength)
                    local byteString = "";
                    for byteIndex = 1, stringLength, 1 do
                        local byteValue = valueToDivide2 % 256;
                        byteString = string.char(byteValue) .. byteString;
                        valueToDivide2 = (valueToDivide2 - byteValue) / 256;
                    end;
                    return byteString;
                end;
                local bytesToInt = function(inputString2, startIndex2)
                    local intValue = 0;
                    for bytePosition = startIndex2, startIndex2 + 3, 1 do
                        intValue = intValue * 256 + string.byte(inputString2, bytePosition);
                    end;
                    return intValue;
                end;
                local padString = function(prefixString, stringLength)
                    local paddingLength = 64 - (stringLength + 9) % 64;
                    local encodedLength = numberToBytes(8 * stringLength, 8);
                    local combinedString = prefixString .. ("\128" .. (string.rep("\000", paddingLength) .. encodedLength));
                    assertFunction(#combinedString % 64 == 0);
                    return combinedString;
                end;
                local initializeHashes = function(initialHashValues2)
                    initialHashValues2[1] = 1779033703;
                    initialHashValues2[2] = 3144134277;
                    initialHashValues2[3] = 1013904242;
                    initialHashValues2[4] = 2773480762;
                    initialHashValues2[5] = 1359893119;
                    initialHashValues2[6] = 2600822924;
                    initialHashValues2[7] = 528734635;
                    initialHashValues2[8] = 1541459225;
                    return initialHashValues2;
                end;
                local processDataBlock = function(dataBlock1, dataBlockOffset, values)
                    local dataBlock = {};
                    for i = 1, 16, 1 do
                        dataBlock[i] = bytesToInt(dataBlock1, dataBlockOffset + (i - 1) * 4);
                    end;
                    for j = 17, 64, 1 do
                        local messageSchedule = dataBlock[j - 15];
                        local tempValue = combineValues(extractBits(messageSchedule, 7), extractBits(messageSchedule, 18), shiftRightBounded(messageSchedule, 3));
                        local arrayValue = dataBlock[j - 2];
                        dataBlock[j] = dataBlock[j - 16] + tempValue + dataBlock[j - 7] + combineValues(extractBits(arrayValue, 17), extractBits(arrayValue, 19), shiftRightBounded(arrayValue, 10));
                    end;
                    local value1 = values[1];
                    local value2 = values[2];
                    local value3 = values[3];
                    local value4 = values[4];
                    local value5 = values[5];
                    local value6 = values[6];
                    local value7 = values[7];
                    local value8 = values[8];
                    for i = 1, 64, 1 do
                        local intermediateValue1 = combineValues(extractBits(value1, 2), extractBits(value1, 13), extractBits(value1, 22)) + combineValues(bitwiseOperation(value1, value2), bitwiseOperation(value1, value3), bitwiseOperation(value2, value3));
                        local intermediateValue2 = combineValues(extractBits(value5, 6), extractBits(value5, 11), extractBits(value5, 25));
                        local combinedValue = combineValues(bitwiseOperation(value5, value6), bitwiseOperation(bitwiseComplementFunction2(value5), value7));
                        local intermediateValue3 = value8 + intermediateValue2 + combinedValue + hashConstants[i] + dataBlock[i];
                        local intermediateValue4 = value4 + intermediateValue3;
                        local intermediateValue5 = intermediateValue3 + intermediateValue1;
                        value8 = value7;
                        value7 = value6;
                        value6 = value5;
                        value5 = intermediateValue4;
                        value4 = value3;
                        value3 = value2;
                        value2 = value1;
                        value1 = intermediateValue5;
                    end;
                    values[1] = bitwiseOperation(values[1] + value1);
                    values[2] = bitwiseOperation(values[2] + value2);
                    values[3] = bitwiseOperation(values[3] + value3);
                    values[4] = bitwiseOperation(values[4] + value4);
                    values[5] = bitwiseOperation(values[5] + value5);
                    values[6] = bitwiseOperation(values[6] + value6);
                    values[7] = bitwiseOperation(values[7] + value7);
                    values[8] = bitwiseOperation(values[8] + value8);
                    return ;
                end;
                return (function(inputString)
                    local dataString = padString(inputString, #inputString);
                    local outputTable = initializeHashes({});
                    for i = 1, #dataString, 64 do
                        processDataBlock(dataString, i, outputTable);
                    end;
                    return bytesToHex(numberToBytes(outputTable[1], 4) .. (numberToBytes(outputTable[2], 4) .. (numberToBytes(outputTable[3], 4) .. (numberToBytes(outputTable[4], 4) .. (numberToBytes(outputTable[5], 4) .. (numberToBytes(outputTable[6], 4) .. (numberToBytes(outputTable[7], 4) .. numberToBytes(outputTable[8], 4))))))));
                end)(hashFunction);
            end
        };
    end,
    i = function()
        return {
            ["\000padString"] = function(stringToPad2)
                local truncatedString = stringToPad2:sub(1, math.floor(#stringToPad2 / 16) * 16);
                local paddingLength2 = 16 - #truncatedString % 16;
                if paddingLength2 == 16 then
                    paddingLength2 = 0;
                end;
                return truncatedString .. string.rep("0", paddingLength2);
            end,
            ["\000strToHex"] = function(stringToHexEncode2)
                return stringToHexEncode2:gsub(".", function(charToEncode2)
                    return string.format("%02x", charToEncode2:byte());
                end);
            end,
            ["\000hexToBin"] = function(hexStringToDecode2)
                return hexStringToDecode2:gsub("..", function(hexPairToDecode2)
                    return string.char(tonumber(hexPairToDecode2, 16));
                end);
            end,
            ["\000bytesToHex"] = function(byteArray)
                local hexString = "";
                for i = 0, #byteArray, 1 do
                    if byteArray[i] then
                        hexString = hexString .. string.format("%02x", byteArray[i]);
                    end;
                end;
                return hexString;
            end,
            ["\000hexToBytes"] = function(hexString)
                local hexValues = {};
                local byteIndex = 0;
                for i = 1, #hexString, 2 do
                    hexValues[byteIndex] = tonumber(hexString:sub(i, i + 1), 16);
                    byteIndex = byteIndex + 1;
                end;
                return hexValues;
            end
        };
    end,
    j = function()
        return {
            ["\000generateNonce"] = function()
                local randomString = "";
                for i = 1, 16, 1 do
                    randomString = randomString .. string.char(math.random(97, 122));
                end;
                return randomString;
            end
        };
    end
};
moduleCache.k = function()
    local loadedModule = moduleCache.load("a");
    local moduleB = loadFunction(moduleCache.load("b"));
    local moduleC = loadFunction(moduleCache.load("c"));
    local moduleD = moduleCache.load("d");
    return function(webhookUrl, payloadData)
        local environment = getfenv(2);
        local keyInfo = environment["KEY_INFO\000"];
        local signedValue = loadedModule["\000sign"](loadedModule["\000lcg"](loadedModule["\000generateSeed"](), 1, 1000000, 9000000000)[1], webhookUrl);
        local hash1 = moduleB.__index()["\000HASH"](16 .. signedValue);
        local hashValue1 = moduleB.__index()["\000HASH"](16 .. signedValue * 2.14);
        local hashValue2 = moduleB.__index()["\000HASH"](hash1 .. hashValue1);
        local encryptedWebhookUrl = moduleC.__index()["\000strToHex"](bufferToStringFunction(moduleB.__index()["\000AES"](moduleC.__index()["\000hexToBin"](hashValue2)):Encrypt(moduleD().stringify({ webhookUrl = webhookUrl, timestamp = os.time() }))));
        local encryptedPayload = moduleC.__index()["\000strToHex"](bufferToStringFunction(moduleB.__index()["\000AES"](moduleC.__index()["\000hexToBin"](hashValue2)):Encrypt(moduleD().stringify({ payload = payloadData, timestamp = os.time(), key = environment["\000\001"], serviceId = environment["\000\002"] }))));
        local webhookRequest = { Url = ("https://api.authguard.org/wb/"):gsub("\000", "") .. encryptedWebhookUrl, Method = "POST", Headers = { ["Content-Type"] = "application/json", X = tostring(signedValue) }, Body = moduleD().stringify({ payload = encryptedPayload, secret = hash1 }) };
        local webhookResponse = httpRequestFunction(webhookRequest);
        if webhookResponse.StatusCode ~= 201 then
            return nil, "Failed to send webhook: " .. tostring(webhookResponse.StatusCode);
        end;
        local parsedBody = moduleD().parse(webhookResponse.Body);
        return ;
    end;
end;
moduleCache.l = function()
    wrap = function(sanitizeValue, sanitizeType)
        return ("<SANITIZE:%s|%s>"):format(sanitizeType, tostring(sanitizeValue));
    end;
    return wrap;
end;
local authGuardModule = {};
authGuardModule.__index = authGuardModule;
authGuardModule.GetKeyLink = function(keyLinkParameters)
    ___SERVICE__ = keyLinkParameters.Service or (function()
        crashHandlerFunction(6);
        while true do
        end;
    end)(___SERVICE__, createTable("table"));
    return "https://authguard.org/a/" .. ___SERVICE__;
end;
authGuardModule.GetFlag = function(flagParameters)
    ___SERVICE__ = flagParameters.Service or (function()
        crashHandlerFunction(6);
        while true do
        end;
    end)(___SERVICE__, createTable("table"));
    __FLAG__ = flagParameters.Flag or (function()
        crashHandlerFunction(15);
        while true do
        end;
    end)(__FLAG__, createTable("table"));
    local loadedModule2 = moduleCache.load("a");
    local hashModuleB = loadFunction(moduleCache.load("b"));
    local hashModuleC = loadFunction(moduleCache.load("c"));
    local jsonModule = moduleCache.load("d");
    local flagCache = moduleCache.load("e");
    local flagCacheKey = "flag:" .. (___SERVICE__ .. (":" .. __FLAG__));
    local cachedFlagValue = flagCache.get(flagCacheKey);
    if cachedFlagValue then
        logFlagMessage("Using cached flag value!");
        return cachedFlagValue;
    end;
    local currentTime = osTimeFunction();
    local signatureSeed = loadedModule2["\000sign"](loadedModule2["\000lcg"](loadedModule2["\000generateSeed"](), 1, 1000000, 9000000000)[1], ___SERVICE__);
    local hashValue1 = hashModuleB.__index()["\000HASH"](16 .. signatureSeed);
    local hashValue3 = hashModuleB.__index()["\000HASH"](16 .. signatureSeed * 2.14);
    local payloadData = { serviceId = ___SERVICE__, flag = __FLAG__, timestamp = currentTime };
    local hashValue4 = hashModuleB.__index()["\000HASH"](hashValue1 .. hashValue3);
    local flagRequest = { Method = "POST", Url = ("https://api.authguard.org/flags/payload\000"):gsub("\000", ""), Body = jsonModule().stringify({ payload = hashModuleC.__index()["\000strToHex"](bufferToStringFunction(hashModuleB.__index()["\000AES"](hashModuleC.__index()["\000hexToBin"](hashValue4)):Encrypt(jsonModule().stringify(payloadData)))), secret = hashValue1 }), Headers = { ["content-type"] = "application/json", ["X-Signature"] = hashModuleB.__index()["\000HASH"](osTimeFunction() .. hashValue1), X = signatureSeed } };
    local flagResponse = httpRequestFunction(flagRequest);
    local flagData = jsonModule().parse(flagResponse.Body);
    if not flagData.success then
        logFlagMessage("Failed to retrieve flag!");
        return nil;
    end;
    if 60 < math.abs(osTimeFunction() - flagData.exp) then
        logFlagMessage("Flag expired!");
        return nil;
    end;
    local decryptedPayload = hashModuleB.__index()["\000AES"](hashModuleC.__index()["\000hexToBin"](hashModuleB.__index()["\000HASH"](tostring(flagData.exp * 3.14) .. (___SERVICE__ .. __FLAG__)))):Decrypt(hashModuleC.__index()["\000hexToBin"](flagData.payload));
    local decryptedFlagData = jsonModule().parse(bufferToStringFunction(decryptedPayload));
    if decryptedFlagData.timestamp == flagData.exp then
        logFlagMessage("Flag retrieved successfully!");
        if type(decryptedFlagData.value) ~= decryptedFlagData.type then
            logFlagMessage("Type mismatch in flag value!");
            return nil;
        end;
        flagCache.add(flagCacheKey, decryptedFlagData.value, 60);
        return decryptedFlagData.value;
    end;
    logFlagMessage("Invalid flag response!");
    return nil;
end;
authGuardModule.ValidateKey = function(inputData2)
    local taskScheduler = task;
    local tempTable = createTable("table");
    local validationParameters = inputData2;
    local securityLevel = validationParameters.SecurityLevel or 1;
    validationParameters.Callback = function()
        crashHandlerFunction(7);
        while true do
        end;
    end;
    local inputType = type(isFlagEnabled);
    serviceId = validationParameters.Service or (function()
        crashHandlerFunction(9);
        while true do
        end;
    end)(serviceId, createTable("table"));
    isFlagEnabled = true;
    __LICENSE_KEY__ = validationParameters.Key or (function()
        crashHandlerFunction(11);
        while true do
        end;
    end)(__LICENSE_KEY__, createTable("table"));
    local environment = getfenv(2);
    return setmetatableFunction({ Validated = createTable("table"), APIKey = mathRandomFunction(1000000, 2000000) }, {
        __index = function(L_1347, L_1348)
            local tableType = createTable("table");
            crashHandlerFunction(12);
            while true do
            end;
        end,
        __newindex = function(L_1350, L_1351)
            local tableLibrary = createTable("table");
            crashHandlerFunction(13);
            while true do
            end;
        end,
        __tostring = function(L_1353, L_1354)
            crashHandlerFunction(14);
            while true do
            end;
        end,
        __call = transformFunction(function()
            local hashModuleF = moduleCache.load("f");
            local jsonModuleG = moduleCache.load("g");
            local hashModuleH = loadFunction(moduleCache.load("h"));
            local hashModuleI = loadFunction(moduleCache.load("i"));
            local generateNonceFunction = loadFunction(moduleCache.load("j")).__index()["\000generateNonce"];
            return transformFunction(function()
                local signatureSeed2 = hashModuleF["\000sign"](hashModuleF["\000lcg"](hashModuleF["\000generateSeed"](), 1, 1000000, 9000000000)[1], serviceId);
                local randomState = { rng = signatureSeed2, iv = 16 };
                local hashValue2 = hashModuleH.__index()["\000HASH"](16 .. signatureSeed2);
                local hashValue3 = hashModuleH.__index()["\000HASH"](16 .. signatureSeed2 * 2.14);
                local nonce = generateNonceFunction();
                local validationData = { hwid = hardwareIdFunction(), key = __LICENSE_KEY__, timestamp = osTimeFunction(), serviceId = serviceId };
                local hashValue5 = hashModuleH.__index()["\000HASH"](hashValue2 .. hashValue3);
                local requestBody = { payload = hashModuleI.__index()["\000strToHex"](bufferToStringFunction(hashModuleH.__index()["\000AES"](hashModuleI.__index()["\000hexToBin"](hashValue5)):Encrypt(jsonModuleG().stringify(validationData)))), secret = hashValue2 };
                local validationRequest = { Url = ("https://api.authguard.org/validate/v2\000"):gsub("\000", ""), Method = "POST", Headers = { ["content-type"] = "application/json", ["X-Signature"] = signature, ["X-Nonce"] = nonce, ["X-Executor"] = identifyexecutor and identifyexecutor(), X = tostring(signatureSeed2) }, Body = jsonModuleG().stringify(requestBody) };
                local validationResponseBody = httpRequestFunction(validationRequest).Body;
                local parsedKeyData = jsonModuleG().parse(validationResponseBody);
                if not parsedKeyData.success then
                    logFlagMessage("Incorrect key!");
                    if securityLevel == 1 then
                        return "invalid";
                    end;
                    if securityLevel == 2 then
                        game.Players.LocalPlayer:Kick("Incorrect key!");
                        return "invalid";
                    end;
                    if securityLevel == 3 then
                        game.Players.LocalPlayer:Kick("Incorrect key!");
                        while true do
                        end;
                    end;
                    return "invalid";
                end;
                if parsedKeyData.secret ~= hashValue3 then
                    crashHandlerFunction(16);
                    while true do
                    end;
                end;
                local decryptedKeyData = jsonModuleG().parse(bufferToStringFunction(hashModuleH.__index()["\000AES"](hashModuleI.__index()["\000hexToBin"](hashValue5)):Decrypt(bufferFromStringFunction(hashModuleI.__index()["\000hexToBin"](parsedKeyData.payload)))));
                if decryptedKeyData.status ~= "success" then
                    crashHandlerFunction(17);
                    while true do
                    end;
                end;
                environment.AG_ExpiredAt = decryptedKeyData.keyInfo.expiredAt;
                environment.AG_Hwid = decryptedKeyData.keyInfo.hwid;
                environment.AG_IsPremium = decryptedKeyData.keyInfo.isPremium;
                environment.AG_DiscordId = #decryptedKeyData.keyInfo.discordId > 0 and decryptedKeyData.keyInfo.discordId or nil;
                environment.AG_IsKeyless = decryptedKeyData.keyInfo.keyless;
                environment.AG_ExecutedCount = decryptedKeyData.keyInfo.executedCount;
                environment.AG_SecondsLeft = decryptedKeyData.keyInfo.expiredAt - osTimeFunction();
                environment.AG_UserNote = decryptedKeyData.keyInfo.note;
                environment.LRM_ScriptName = "None";
                environment.LRM_LinkedDiscordId = environment.AG_DiscordId;
                environment.LRM_TotalExecutions = environment.AG_ExecutedCount;
                environment.LRM_SecondsLeft = environment.AG_SecondsLeft;
                environment.LRM_UserNote = environment.AG_UserNote;
                environment.LRM_IsUserPremium = environment.AG_IsPremium;
                environment.LRM_ScriptVersion = "1.0.0";
                environment["\000\001"] = decryptedKeyData.keyInfo.key;
                environment["\000\002"] = decryptedKeyData.serviceId;
                local startTime = osClock();
                logFlagMessage(stringFormat("[AuthGuard] Validated in %f seconds", startTime - startTime));
                return "validated";
            end)();
        end)
    })();
end;
local moduleK, moduleL = moduleCache.load("k"), moduleCache.load("l");
if authGuardModule.ValidateKey({ Service = "1314", Key = script_key }) == "invalid" then
    warn("Invalid Key");
    return ;
end;
local instanceCache = {};
local moduleCache = {};
local parentCache = {};
local resolveCircularDependency = function(parentInstance, childInstance)
    parentCache[childInstance] = parentInstance;
    local currentInstance = parentInstance;
    local loopCount = 0;
    while currentInstance do
        loopCount = loopCount + 1;
        currentInstance = parentCache[currentInstance];
        if currentInstance == parentInstance then
            local dependencyChain = currentInstance.Name;
            for i = 1, loopCount, 1 do
                currentInstance = parentCache[currentInstance];
                dependencyChain = dependencyChain .. ("  \226\135\146 " .. currentInstance.Name);
            end;
            errorFunction("Failed to load '" .. (parentInstance.Name .. ("'; Detected a circular dependency chain: " .. dependencyChain)), 2);
        end;
    end;
    local callbackResult = moduleCache[parentInstance].callback();
    if parentCache[childInstance] == parentInstance then
        parentCache[childInstance] = nil;
    end;
    return callbackResult;
end;
local loadModule = function(moduleName, arg10)
    local cachedModule = moduleCache[moduleName];
    if cachedModule.loaded then
        return cachedModule.result;
    end;
    cachedModule.result = resolveCircularDependency(moduleName, arg10);
    cachedModule.loaded = true;
    return cachedModule.result;
end;
local createInstance = function(nameValue, instanceClassName, childIndex, parentIndex)
    local newObject = Instance.new(instanceClassName);
    newObject.Name = nameValue;
    newObject.Parent = instanceCache[parentIndex];
    instanceCache[childIndex] = newObject;
    return newObject;
end;
local registerModule = function(arg1, arg11, arg12, arg13, callbackFunction)
    local newModule = createInstance(arg1, arg11, arg12, arg13);
    moduleCache[newModule] = {
        callback = callbackFunction,
        result = nil,
        loaded = false,
        globals = {
            script = newModule,
            require = function(requiredModuleName)
                if moduleCache[requiredModuleName] then
                    return loadModule(requiredModuleName, newModule);
                end;
                return require(requiredModuleName);
            end
        }
    };
    return ;
end;
local getModuleGlobals = function(moduleIndex)
    return moduleCache[instanceCache[moduleIndex]].globals;
end;
local initializeLocalScripts = function()
    for moduleKey, moduleValue in pairsFunction(moduleCache) do
        if moduleKey.ClassName == "LocalScript" and not moduleKey.Disabled then
            task.spawn(moduleValue.callback);
        end;
    end;
    return ;
end;
createInstance("rbxts-bundle-example", "Folder", "rbxts-bundle-example", nil);
createInstance("DeathBall", "Folder", "rbxts-bundle-example.DeathBall", "rbxts-bundle-example");
registerModule("AutoAbilityService", "ModuleScript", "rbxts-bundle-example.DeathBall.AutoAbilityService", "rbxts-bundle-example.DeathBall", function()
    local autoAbilityServiceGlobals = getModuleGlobals("rbxts-bundle-example.DeathBall.AutoAbilityService");
    local autoAbilityServiceScript = autoAbilityServiceGlobals.script;
    local runtimeLib = autoAbilityServiceGlobals.require(autoAbilityServiceScript.Parent.Parent.include.RuntimeLib);
    local services = runtimeLib.import(autoAbilityServiceScript, autoAbilityServiceScript.Parent.Parent, "LKHUB", "Services");
    local playersService = services.Players;
    local runService = services.RunService;
    local uncGlobalsCloneref = runtimeLib.import(autoAbilityServiceScript, autoAbilityServiceScript.Parent.Parent, "LKHUB", "UNCGlobals").cloneref;
    local library = runtimeLib.import(autoAbilityServiceScript, autoAbilityServiceScript.Parent.Parent, "LKHUB", "Library", "Library");
    local guiServiceInset = uncGlobalsCloneref(game:GetService("GuiService"));
    local virtualInputManager = uncGlobalsCloneref(game:GetService("VirtualInputManager"));
    local localPlayer = playersService.LocalPlayer;
    local abilityWhitelistMap = { ["FAKE BALL"] = true, ["ASTRAL PORTAL"] = true, ["CURSED BLUE"] = true, ["EXTEND-O ARM"] = true, ["GLASS WALL"] = true, ["UPPER CUT"] = true, ["SONIC SLIDE"] = true, ["GROUND WALLS"] = true, ["ZAP FREEZE"] = true, ["ZAP DEFLECT"] = true, ["GOD SPEED"] = true, ["ASSASSIN INVISIBILITY"] = true, ["LIGHTNING INTERCEPT"] = true, ["CHARGED KICK"] = true, ["JUGGLING BLAST"] = true, ["LEAP STRIKE"] = true, ["CHAIN SPEAR"] = true, HANDGUN = true, ["DRAGON RUSH"] = true, ["INSTANT TRAVEL"] = true, ["KI BLAST"] = true, ["ICE SLIDE"] = true, ["ICE SHIELD"] = true, ["FIRE DASH"] = true, ["FIRE BALL"] = true, BONK = true, ["SIDE STEP"] = true, BUNGEE = true, ["SHADOW RAMPAGE"] = true, ["DREAD SPHERE"] = true, ["PHANTOM GASP"] = true, ["ORBITAL CANNON"] = true, ["RULERS HOLD"] = true, ["DAGGER DASH"] = true };
    local isAbilityActive = false;
    local lastBackgroundTransparency = 0;
    local isCooldownActive = false;
    local lastUpdateTime = 0;
    local abilityActivated = false;
    local heartbeatConnection = nil;
    local getCharacter = function()
        return localPlayer.Character;
    end;
    local getDeflectButton = function()
        local success, results = runtimeLib.try(function()
            local playerGui = localPlayer:WaitForChild("PlayerGui");
            if game:GetService("UserInputService").TouchEnabled then
                local mobileButtonsGUI = playerGui:FindFirstChild("MobileButtonsGUI");
                if mobileButtonsGUI then
                    local mobileButtonHolder = mobileButtonsGUI:FindFirstChild("MobileButtonHolder");
                    if mobileButtonHolder then
                        return runtimeLib.TRY_RETURN, { mobileButtonHolder:FindFirstChild("DeflectButton") };
                    end;
                end;
            else
                local hudGUI = playerGui:FindFirstChild("HUD");
                if hudGUI then
                    local holderBottom = hudGUI:FindFirstChild("HolderBottom");
                    if holderBottom then
                        local toolbarButtons = holderBottom:FindFirstChild("ToolbarButtons");
                        if toolbarButtons then
                            return runtimeLib.TRY_RETURN, { toolbarButtons:FindFirstChild("DeflectButton") };
                        end;
                    end;
                end;
            end;
            return ;
        end, function()
            return ;
        end);
        if success then
            return unpack(results);
        end;
        return nil;
    end;
    local isBackgroundColorBlack = function(guiObject)
        local blackColor = Color3.new(0, 0, 0);
        local backgroundColor = guiObject.BackgroundColor3;
        return math.abs(backgroundColor.R - blackColor.R) < 0.01 and math.abs(backgroundColor.G - blackColor.G) < 0.01 and math.abs(backgroundColor.B - blackColor.B) < 0.01;
    end;
    local simulateClick = function(guiElement)
        local elementAbsolutePosition = guiElement.AbsolutePosition;
        local elementAbsoluteSize = guiElement.AbsoluteSize;
        local guiInset = guiServiceInset:GetGuiInset();
        local clickX = elementAbsolutePosition.X + elementAbsoluteSize.X / 2;
        local clickY = elementAbsolutePosition.Y + elementAbsoluteSize.Y / 2 + guiInset.Y;
        if not pcall(function()
            virtualInputManager:SendMouseButtonEvent(clickX, clickY, 0, true, game, 0);
            return ;
        end) then
            warn("VIM click down failed");
        end;
        if not pcall(function()
            virtualInputManager:SendMouseButtonEvent(clickX, clickY, 0, false, game, 0);
            return ;
        end) then
            warn("VIM click up failed");
        end;
        return ;
    end;
    local isHighlightActive = function()
        local character = getCharacter();
        if not character then
            return false;
        end;
        local highlightEffect = character:FindFirstChild("Highlight");
        if highlightEffect and highlightEffect:IsA("Highlight") then
            return math.abs(highlightEffect.FillTransparency - 0.34) <= 0.001;
        end;
        return false;
    end;
    local getAbilityButtons = function()
        local abilityButtonsList = {};
        runtimeLib.try(function()
            local playerGuiMobile = localPlayer:WaitForChild("PlayerGui");
            if game:GetService("UserInputService").TouchEnabled then
                local mobileButtonsGUI2 = playerGuiMobile:FindFirstChild("MobileButtonsGUI");
                if mobileButtonsGUI2 then
                    local mobileButtonHolder = mobileButtonsGUI2:FindFirstChild("MobileButtonHolder");
                    if mobileButtonHolder then
                        for abilityButtonIndex = 1, 4, 1 do
                            local abilityButton = mobileButtonHolder:FindFirstChild((("AbilityButton%*"):format(abilityButtonIndex)));
                            if abilityButton then
                                table.insert(abilityButtonsList, abilityButton);
                            end;
                        end;
                    end;
                end;
            else
                local hudGUI2 = playerGuiMobile:FindFirstChild("HUD");
                if hudGUI2 then
                    local holderBottom2 = hudGUI2:FindFirstChild("HolderBottom");
                    if holderBottom2 then
                        local toolbarButtons = holderBottom2:FindFirstChild("ToolbarButtons");
                        if toolbarButtons then
                            for abilityButtonIndex2 = 1, 4, 1 do
                                local abilityButtonToolbar = toolbarButtons:FindFirstChild((("AbilityButton%*"):format(abilityButtonIndex2)));
                                if abilityButtonToolbar then
                                    table.insert(abilityButtonsList, abilityButtonToolbar);
                                end;
                            end;
                        end;
                    end;
                end;
            end;
            return ;
        end, function()
            return ;
        end);
        return abilityButtonsList;
    end;
    local updateCooldown = function()
        if not isAbilityActive or not library.IsRunning then
            return nil;
        end;
        local abilityButton = getDeflectButton();
        if not abilityButton then
            return nil;
        end;
        local backgroundTransparency = abilityButton.BackgroundTransparency;
        local currentTime = tick();
        if backgroundTransparency ~= lastBackgroundTransparency then
            if not isCooldownActive then
                lastUpdateTime = currentTime;
                isCooldownActive = true;
                abilityActivated = false;
            else
                isCooldownActive = false;
            end;
            lastBackgroundTransparency = backgroundTransparency;
        end;
        if isCooldownActive and not abilityActivated and 0.8 <= currentTime - lastUpdateTime then
            if isHighlightActive() then
                for abilityIndex, abilityButton in getAbilityButtons(), nil, nil do
                    local abilityNameLabel = abilityButton:FindFirstChild("AbilityNameLabel");
                    if abilityNameLabel and abilityWhitelistMap[abilityNameLabel.Text] and not isBackgroundColorBlack(abilityButton) then
                        simulateClick(abilityButton);
                        break;
                    end;
                end;
            end;
            abilityActivated = true;
        end;
        return ;
    end;
    local setAutoAbilityEnabled = function(isEnabled)
        if isEnabled and not library.IsRunning then
            return nil;
        end;
        isAbilityActive = isEnabled;
        if isEnabled then
            if not heartbeatConnection or not heartbeatConnection.Connected then
                local abilityBackground = getDeflectButton();
                if abilityBackground then
                    lastBackgroundTransparency = abilityBackground.BackgroundTransparency;
                end;
                isCooldownActive = false;
                lastUpdateTime = 0;
                abilityActivated = false;
                heartbeatConnection = runService.Heartbeat:Connect(updateCooldown);
            end;
        else
            if heartbeatConnection and heartbeatConnection.Connected then
                heartbeatConnection:Disconnect();
            end;
            heartbeatConnection = nil;
        end;
        return ;
    end;
    local isAutoAbilityEnabled = function()
        return isAbilityActive;
    end;
    local getAvailableAbilities = function()
        local abilityList = {};
        for abilityName, abilityName in pairsFunction(abilityWhitelistMap) do
            table.insert(abilityList, abilityName);
        end;
        return abilityList;
    end;
    return { setAutoAbilityEnabled = setAutoAbilityEnabled, isAutoAbilityEnabled = isAutoAbilityEnabled, getAvailableAbilities = getAvailableAbilities };
end);
registerModule("AutoParry", "ModuleScript", "rbxts-bundle-example.DeathBall.AutoParry", "rbxts-bundle-example.DeathBall", function()
    local autoParryModule = getModuleGlobals("rbxts-bundle-example.DeathBall.AutoParry");
    local autoParryScript = autoParryModule.script;
    local runtimeLib = autoParryModule.require(autoParryScript.Parent.Parent.include.RuntimeLib);
    local services = runtimeLib.import(autoParryScript, autoParryScript.Parent.Parent, "LKHUB", "Services");
    local playersService = services.Players;
    local workspaceService = services.Workspace;
    local runService = services.RunService;
    local uncGlobalsCloneRef = runtimeLib.import(autoParryScript, autoParryScript.Parent.Parent, "LKHUB", "UNCGlobals").cloneref;
    local ballService = runtimeLib.import(autoParryScript, autoParryScript.Parent, "BallService");
    local getClosestBall = ballService.getClosestBall;
    local startBallTrackingFunction = ballService.startBallTracking;
    local library = runtimeLib.import(autoParryScript, autoParryScript.Parent.Parent, "LKHUB", "Library", "Library");
    local virtualInputManager = uncGlobalsCloneRef(game:GetService("VirtualInputManager"));
    local userInputService = uncGlobalsCloneRef(game:GetService("UserInputService"));
    local guiInset = uncGlobalsCloneRef(game:GetService("GuiService"));
    local localPlayer = playersService.LocalPlayer;
    local isTracking = false;
    local lerpSpeed = 0.1;
    local character = localPlayer.Character;
    local humanoidRootPart = character;
    if humanoidRootPart ~= nil then
        humanoidRootPart = humanoidRootPart:FindFirstChild("HumanoidRootPart");
    end;
    local target = humanoidRootPart;
    local lastTarget = nil;
    local abilityType = nil;
    local lastTime = 0;
    local lastPosition = nil;
    local heartbeatConnection = nil;
    local isDeflectAbilityActiveFunction = function()
        local deflectBillboardGui = target;
        if deflectBillboardGui ~= nil then
            deflectBillboardGui = deflectBillboardGui:FindFirstChild("DeflectBillboardGui");
        end;
        local deflectBillboardGui = deflectBillboardGui;
        if not deflectBillboardGui then
            return false;
        end;
        local activeAbilityLabel = deflectBillboardGui:FindFirstChild("ActiveAbilityLabel");
        if not activeAbilityLabel then
            return false;
        end;
        return activeAbilityLabel.Visible;
    end;
    local getDeflectButtonFunction = function()
        local success, deflectButtonArray = runtimeLib.try(function()
            local playerGui = localPlayer:WaitForChild("PlayerGui");
            if userInputService.TouchEnabled then
                local mobileButtonsGui = playerGui:FindFirstChild("MobileButtonsGUI");
                if mobileButtonsGui then
                    local mobileButtonHolderFrame = mobileButtonsGui:FindFirstChild("MobileButtonHolder");
                    if mobileButtonHolderFrame then
                        return runtimeLib.TRY_RETURN, { mobileButtonHolderFrame:FindFirstChild("DeflectButton") };
                    end;
                end;
            else
                local hudGui = playerGui:FindFirstChild("HUD");
                if hudGui then
                    local holderBottomFrame = hudGui:FindFirstChild("HolderBottom");
                    if holderBottomFrame then
                        local toolbarButtonsFrame = holderBottomFrame:FindFirstChild("ToolbarButtons");
                        if toolbarButtonsFrame then
                            return runtimeLib.TRY_RETURN, { toolbarButtonsFrame:FindFirstChild("DeflectButton") };
                        end;
                    end;
                end;
            end;
            return ;
        end, function()
            return ;
        end);
        if success then
            return unpack(deflectButtonArray);
        end;
        return nil;
    end;
    local simulateDeflectButtonPress = function(buttonGuiObject)
        local buttonAbsolutePosition = buttonGuiObject.AbsolutePosition;
        local buttonAbsoluteSize = buttonGuiObject.AbsoluteSize;
        local guiInsetValue = guiInset:GetGuiInset();
        local buttonCenterX = buttonAbsolutePosition.X + buttonAbsoluteSize.X / 2;
        local buttonCenterY = buttonAbsolutePosition.Y + buttonAbsoluteSize.Y / 2 + guiInsetValue.Y;
        if not pcall(function()
            virtualInputManager:SendMouseButtonEvent(buttonCenterX, buttonCenterY, 0, true, game, 0);
            return ;
        end) then
            warn("Deflect button click down failed");
        end;
        if not pcall(function()
            virtualInputManager:SendMouseButtonEvent(buttonCenterX, buttonCenterY, 0, false, game, 0);
            return ;
        end) then
            warn("Deflect button click up failed");
        end;
        return ;
    end;
    local simulateDeflectButtonTouch = function()
        local deflectButton = getDeflectButtonFunction();
        if deflectButton then
            simulateDeflectButtonPress(deflectButton);
            return nil;
        end;
        if userInputService.TouchEnabled then
            local touchPosition = Vector3.new(0, 0, 0);
            local touchBeginSuccess, touchBeginError = pcall(function()
                virtualInputManager:SendTouchEvent(Enum.UserInputType.Touch, Enum.UserInputState.Begin, touchPosition);
                return ;
            end);
            task.wait(0.1);
            local touchEndSuccess, touchEndError = pcall(function()
                virtualInputManager:SendTouchEvent(Enum.UserInputType.Touch, Enum.UserInputState.End, touchPosition);
                return ;
            end);
            if not touchBeginSuccess or not touchEndSuccess then
                local touchError = touchBeginError;
                if touchError == nil then
                    touchError = touchEndError;
                end;
                warn("Touch event failed", touchError);
            end;
        else
            local mouseButtonDownSuccess, mouseButtonDownError = pcall(function()
                virtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0);
                return ;
            end);
            local mouseButtonUpSuccess, mouseButtonUpError = pcall(function()
                virtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0);
                return ;
            end);
            if not mouseButtonDownSuccess or not mouseButtonUpSuccess then
                local mouseClickError = mouseButtonDownError;
                if mouseClickError == nil then
                    mouseClickError = mouseButtonUpError;
                end;
                warn("Mouse click failed", mouseClickError);
            end;
        end;
        return ;
    end;
    local heartbeatUpdateFunction = function(deltaTime)
        if not isTracking or (deltaTime <= 0 or not library.IsRunning) then
            return nil;
        end;
        local characterModel = localPlayer.Character;
        local humanoidRootPart = characterModel;
        if humanoidRootPart ~= nil then
            humanoidRootPart = humanoidRootPart:FindFirstChild("HumanoidRootPart");
        end;
        local humanoidRootPart = humanoidRootPart;
        if not characterModel or not humanoidRootPart then
            return nil;
        end;
        character = characterModel;
        target = humanoidRootPart;
        if isDeflectAbilityActiveFunction() then
            return nil;
        end;
        local rootPartPosition = target.Position;
        local ballData = getClosestBall(rootPartPosition);
        if not ballData then
            lastTarget = nil;
            abilityType = nil;
            lastPosition = nil;
            return nil;
        end;
        local currentBall = ballData.ball;
        local abilityType = ballData.type;
        local currentPosition = ballData.position;
        if lastTarget ~= currentBall then
            lastPosition = currentPosition;
        end;
        lastTarget = currentBall;
        abilityType = abilityType;
        if not lastTarget then
            return nil;
        end;
        local highlightInstance = workspaceService:FindFirstChild(localPlayer.Name);
        if highlightInstance ~= nil then
            highlightInstance = highlightInstance:FindFirstChildWhichIsA("Highlight");
        end;
        local highlight = highlightInstance;
        local abilityEnabled = highlight;
        if abilityEnabled ~= nil then
            abilityEnabled = abilityEnabled.Enabled;
        end;
        local isFillTransparent = abilityEnabled and math.abs(highlight.FillTransparency - 0.34) < 0.001;
        local targetPosition = currentPosition;
        local distanceToTarget = (target.Position - targetPosition).Magnitude;
        local speedRatio = 0;
        local positionDifference = Vector3.zero;
        if lastPosition then
            positionDifference = targetPosition - lastPosition;
            local positionDifferenceMagnitude = positionDifference.Magnitude;
            if 1E-05 < deltaTime and positionDifferenceMagnitude / deltaTime < 5000 then
                speedRatio = positionDifferenceMagnitude / deltaTime;
            end;
        end;
        lastPosition = targetPosition;
        if speedRatio < 0.05 then
            return nil;
        end;
        local someValue6 = nil;
        local maxDistance;
        if abilityType == "Toro" then
            maxDistance = 20;
        else
            maxDistance = 15;
            if 40 <= speedRatio then
                local distanceIncrease = speedRatio * lerpSpeed;
                maxDistance = math.min(maxDistance + distanceIncrease, 50);
            end;
        end;
        local currentTime = tick();
        if currentTime - lastTime < 0.1 then
            return nil;
        end;
        local targetReached = false;
        if abilityType == "Normal" then
            if isFillTransparent then
                if distanceToTarget <= maxDistance then
                    local isBallTracked = true;
                    local directionToBall = (target.Position - targetPosition).Unit;
                    local unitVector1 = positionDifference.Unit;
                    if 0.01 < positionDifference.Magnitude and 0.99 < unitVector1.Magnitude and unitVector1:Dot(directionToBall) > 0.707 then
                        targetReached = true;
                    end;
                end;
                if not targetReached and distanceToTarget <= 10 then
                    targetReached = true;
                end;
            end;
        elseif abilityType == "Toro" then
            if distanceToTarget <= math.min(10, 10) then
                local isToroBallTracked = true;
                local directionToTarget = (target.Position - targetPosition).Unit;
                local unitVector2 = positionDifference.Unit;
                if 0.01 < positionDifference.Magnitude and 0.99 < unitVector2.Magnitude and unitVector2:Dot(directionToTarget) > 0.3535 then
                    targetReached = true;
                end;
            elseif distanceToTarget <= maxDistance then
                local isEnabled = true;
                local directionToToroBall = (target.Position - targetPosition).Unit;
                local unitVector3 = positionDifference.Unit;
                if 0.01 < positionDifference.Magnitude and 0.99 < unitVector3.Magnitude and unitVector3:Dot(directionToToroBall) > 0.707 then
                    targetReached = true;
                end;
            end;
        end;
        if targetReached then
            simulateDeflectButtonTouch();
            lastTime = currentTime;
        end;
        return ;
    end;
    local setAutoParryEnabled = function(isEnabled)
        if isEnabled and not library.IsRunning then
            return nil;
        end;
        isTracking = isEnabled;
        if isTracking then
            if not heartbeatConnection or not heartbeatConnection.Connected then
                startBallTrackingFunction();
                lastTarget = nil;
                abilityType = nil;
                lastPosition = nil;
                heartbeatConnection = runService.Heartbeat:Connect(heartbeatUpdateFunction);
            end;
        else
            if heartbeatConnection and heartbeatConnection.Connected then
                heartbeatConnection:Disconnect();
            end;
            heartbeatConnection = nil;
            lastTarget = nil;
            abilityType = nil;
            lastPosition = nil;
        end;
        return ;
    end;
    local setParryAccuracy = function(value)
        if not library.IsRunning then
            return nil;
        end;
        lerpSpeed = value;
        return ;
    end;
    local isAutoParryEnabled = function()
        return isTracking;
    end;
    return { setAutoParryEnabled = setAutoParryEnabled, setParryAccuracy = setParryAccuracy, isAutoParryEnabled = isAutoParryEnabled };
end);
registerModule("BallService", "ModuleScript", "rbxts-bundle-example.DeathBall.BallService", "rbxts-bundle-example.DeathBall", function()
    local ballServiceModule = getModuleGlobals("rbxts-bundle-example.DeathBall.BallService");
    local ballServiceScript = ballServiceModule.script;
    local runtimeLib = ballServiceModule.require(ballServiceScript.Parent.Parent.include.RuntimeLib);
    local services = runtimeLib.import(ballServiceScript, ballServiceScript.Parent.Parent, "LKHUB", "Services");
    local workspaceService = services.Workspace;
    local runService = services.RunService;
    local library = runtimeLib.import(ballServiceScript, ballServiceScript.Parent.Parent, "LKHUB", "Library", "Library");
    local greyColor = Color3.fromRGB(111, 111, 111);
    local shadowFound = false;
    local ballShadow = nil;
    local ballShadowDecal = nil;
    local toroBall = nil;
    local renderSteppedConnection = nil;
    local destroyToroBall = nil;
    local createToroBall = function(part1, part2)
        if shadowFound or renderSteppedConnection then
            return nil;
        end;
        if not part1 or not part2 then
            return nil;
        end;
        shadowFound = true;
        ballShadow = part1;
        ballShadowDecal = part2;
        ballShadow.Color = greyColor;
        local toroBallInstance = workspaceService:FindFirstChild("ToroBall");
        if toroBallInstance then
            toroBallInstance:Destroy();
        end;
        toroBall = Instance.new("Part");
        toroBall.Name = "ToroBall";
        toroBall.Shape = Enum.PartType.Ball;
        toroBall.Size = Vector3.new(4, 4, 4);
        toroBall.Color = Color3.fromRGB(255, 0, 0);
        toroBall.Material = Enum.Material.Neon;
        toroBall.Anchored = true;
        toroBall.CanCollide = false;
        toroBall.Transparency = 1;
        toroBall.Parent = workspaceService;
        local part2Transparency = ballShadowDecal.Transparency;
        local heightOffset1 = 2 + 278 * math.clamp((part2Transparency - 0.3) / 0.7, 0, 1);
        local part1Position = ballShadow.Position;
        toroBall.Position = Vector3.new(part1Position.X, part1Position.Y + heightOffset1, part1Position.Z);
        renderSteppedConnection = runService.RenderStepped:Connect(function()
            if not library.IsRunning then
                destroyToroBall();
                return nil;
            end;
            if not ballShadow or not ballShadow.Parent or not ballShadowDecal or not ballShadowDecal.Parent or ballShadowDecal.Parent ~= ballShadow or not toroBall or not toroBall.Parent then
                destroyToroBall();
                return nil;
            end;
            local part2Transparency = ballShadowDecal.Transparency;
            local heightOffset2 = 2 + 278 * math.clamp((part2Transparency - 0.3) / 0.7, 0, 1);
            local part1Position = ballShadow.Position;
            local newPosition = Vector3.new(part1Position.X, part1Position.Y + heightOffset2, part1Position.Z);
            toroBall.Position = toroBall.Position:Lerp(newPosition, 1);
            return ;
        end);
        return ;
    end;
    destroyToroBall = function()
        if not shadowFound then
            return nil;
        end;
        if renderSteppedConnection then
            renderSteppedConnection:Disconnect();
            renderSteppedConnection = nil;
        end;
        local toroBall = toroBall or workspaceService:FindFirstChild("ToroBall");
        if toroBall and toroBall.Parent then
            toroBall:Destroy();
        end;
        toroBall = nil;
        ballShadow = nil;
        ballShadowDecal = nil;
        shadowFound = false;
        return ;
    end;
    local onFXChildAdded = function()
        local fxFolder = workspaceService:WaitForChild("FX", 30);
        if fxFolder then
            fxFolder.ChildAdded:Connect(function(ballShadowPart)
                if ballShadowPart.Name == "BallShadow" and (ballShadowPart:IsA("BasePart") and not shadowFound) then
                    task.wait(0.1);
                    local ballShadowDecal = ballShadowPart:FindFirstChild("Decal");
                    if ballShadowDecal and ballShadowDecal:IsA("Decal") and not shadowFound then
                        createToroBall(ballShadowPart, ballShadowDecal);
                    end;
                end;
                return ;
            end);
            fxFolder.ChildRemoved:Connect(function(removedChild)
                if removedChild == ballShadow then
                    destroyToroBall();
                end;
                return ;
            end);
            if not shadowFound then
                local existingBallShadow = fxFolder:FindFirstChild("BallShadow");
                if existingBallShadow and existingBallShadow:IsA("BasePart") then
                    local existingBallShadowDecal = existingBallShadow:FindFirstChild("Decal");
                    if existingBallShadowDecal and existingBallShadowDecal:IsA("Decal") and not shadowFound then
                        createToroBall(existingBallShadow, existingBallShadowDecal);
                    end;
                end;
            end;
        end;
        return ;
    end;
    local getBall = function()
        if toroBall and toroBall.Parent then
            return toroBall;
        end;
        return workspaceService:FindFirstChild("Ball");
    end;
    local getToroBall = function()
        return workspaceService:FindFirstChild("ToroBall");
    end;
    local getTrackedBallPosition = function()
        if toroBall and toroBall.Parent then
            return toroBall.Position;
        end;
        local ballInstance = workspaceService:FindFirstChild("Ball");
        if ballInstance then
            return ballInstance.Position;
        end;
        return nil;
    end;
    local getClosestBallFunction = function(position)
        local trackedBallPosition = getTrackedBallPosition();
        local toroBall = getToroBall();
        if trackedBallPosition and toroBall then
            if (trackedBallPosition - position).Magnitude <= (toroBall.Position - position).Magnitude then
                local ball = getBall();
                return if not ball then nil else { ball = ball, position = trackedBallPosition, type = "Normal" };
            end;
            return { ball = toroBall, position = toroBall.Position, type = "Toro" };
        end;
        if trackedBallPosition then
            local ball = getBall();
            return if not ball then nil else { ball = ball, position = trackedBallPosition, type = "Normal" };
        end;
        if toroBall then
            return { ball = toroBall, position = toroBall.Position, type = "Toro" };
        end;
        return nil;
    end;
    local startBallTrackingFunction = function()
        if not library.IsRunning then
            return nil;
        end;
        onFXChildAdded();
        return ;
    end;
    local stopBallTracking = function()
        destroyToroBall();
        return ;
    end;
    local isBallTracking = function()
        return shadowFound;
    end;
    return { getBall = getBall, getToroBall = getToroBall, getTrackedBallPosition = getTrackedBallPosition, getClosestBall = getClosestBallFunction, startBallTracking = startBallTrackingFunction, stopBallTracking = stopBallTracking, isBallTracking = isBallTracking };
end);
registerModule("BossFarmService", "ModuleScript", "rbxts-bundle-example.DeathBall.BossFarmService", "rbxts-bundle-example.DeathBall", function()
    local bossFarmServiceModule = getModuleGlobals("rbxts-bundle-example.DeathBall.BossFarmService");
    local bossFarmServiceScript = bossFarmServiceModule.script;
    local runtimeLib = bossFarmServiceModule.require(bossFarmServiceScript.Parent.Parent.include.RuntimeLib);
    local services = runtimeLib.import(bossFarmServiceScript, bossFarmServiceScript.Parent.Parent, "LKHUB", "Services");
    local playersService = services.Players;
    local workspaceService = services.Workspace;
    local runService = services.RunService;
    local library = runtimeLib.import(bossFarmServiceScript, bossFarmServiceScript.Parent.Parent, "LKHUB", "Library", "Library");
    local localPlayer = playersService.LocalPlayer;
    local configuration = { REVIVE_FOLDER_NAME = "ReviveParts", TELEPORT_Y_OFFSET = 3, TELEPORT_TIMEOUT = 1.8, WAIT_AFTER_TP = 0.15, WAIT_AFTER_CLICK = 0.2, ALIGN_MAX_FORCE = 200000, ALIGN_RESPONSIVENESS = 180, BOSS_CHECK_INTERVAL = 0.8, INITIAL_BOSS_DETECT_DELAY = 3 };
    local bossNames = { "VillainMech", "TheStatue", "CursedSpirit" };
    local teleportYOffset = 50;
    local isBossActive = false;
    local activeBossName = nil;
    local isReviving = false;
    local reviveCFrame = nil;
    local lastCharacterName = nil;
    local initialBossDetectDelayComplete = false;
    local alignPosition = nil;
    local attachment = nil;
    local heartbeatConnection = nil;
    local childRemovedConnection = nil;
    local getCharacterParts = function()
        local character = localPlayer.Character;
        local humanoidRootPart = character;
        if humanoidRootPart ~= nil then
            humanoidRootPart = humanoidRootPart:FindFirstChild("HumanoidRootPart");
        end;
        local humanoidRootPart = humanoidRootPart;
        local humanoid = character;
        if humanoid ~= nil then
            humanoid = humanoid:FindFirstChild("Humanoid");
        end;
        local humanoid = humanoid;
        if not character or not humanoidRootPart or not humanoid or humanoid.Health <= 0 then
            return nil, nil, nil;
        end;
        return character, humanoidRootPart, humanoid;
    end;
    local resetBossFight = function()
        if not isReviving then
            return nil;
        end;
        isReviving = false;
        local destroyCall1 = pcall(function()
            if alignPosition and alignPosition.Parent then
                alignPosition:Destroy();
            end;
            return ;
        end);
        local destroyCall2 = pcall(function()
            if attachment and attachment.Parent then
                attachment:Destroy();
            end;
            return ;
        end);
        alignPosition = nil;
        attachment = nil;
        local success, rootPart = getCharacterParts();
        if rootPart then
            local anchoredCall = pcall(function()
                rootPart.Anchored = false;
                return ;
            end);
        end;
        return ;
    end;
    local getBossSpawnPosition = function(childName)
        local activeMap = workspaceService:FindFirstChild("ActiveMap");
        if not activeMap then
            return nil;
        end;
        local bossArea = activeMap:FindFirstChild(childName);
        if not bossArea then
            return nil;
        end;
        local bossSpawnPart = bossArea:FindFirstChild("BossSpawn");
        if not bossSpawnPart or not bossSpawnPart:IsA("BasePart") then
            return nil;
        end;
        return bossSpawnPart.Position;
    end;
    local spawnBoss = function(bossName)
        if not isBossActive or not library.IsRunning then
            resetBossFight();
            return nil;
        end;
        local success, characterRootPart = getCharacterParts();
        if not characterRootPart then
            resetBossFight();
            return nil;
        end;
        local bossSpawnPosition = getBossSpawnPosition(bossName);
        if not bossSpawnPosition then
            warn((("BossSpawn not found for %*"):format(bossName)));
            resetBossFight();
            return nil;
        end;
        local spawnPosition = Vector3.new(bossSpawnPosition.X, bossSpawnPosition.Y + teleportYOffset, bossSpawnPosition.Z);
        reviveCFrame = characterRootPart.CFrame;
        activeBossName = bossName;
        resetBossFight();
        if not pcall(function()
            characterRootPart.Anchored = false;
            characterRootPart.Velocity = Vector3.zero;
            characterRootPart.RotVelocity = Vector3.zero;
            characterRootPart.CFrame = CFrame.new(spawnPosition);
            task.wait(0.05);
            local success, characterModel = getCharacterParts();
            if not characterModel then
                errorFunction("Character invalid post TP");
            end;
            attachment = Instance.new("Attachment");
            attachment.Parent = characterModel;
            alignPosition = Instance.new("AlignPosition");
            alignPosition.Parent = characterModel;
            alignPosition.Attachment0 = attachment;
            alignPosition.Mode = Enum.PositionAlignmentMode.OneAttachment;
            alignPosition.ApplyAtCenterOfMass = true;
            alignPosition.MaxForce = configuration.ALIGN_MAX_FORCE;
            alignPosition.Responsiveness = configuration.ALIGN_RESPONSIVENESS;
            alignPosition.Position = spawnPosition;
            isReviving = true;
            return ;
        end) then
            resetBossFight();
            activeBossName = nil;
            reviveCFrame = nil;
        end;
        return ;
    end;
    local resetCharacterPosition = function(isTeleportEnabled)
        local lastCharacterCFrame = reviveCFrame;
        resetBossFight();
        activeBossName = nil;
        if isTeleportEnabled and lastCharacterCFrame then
            local tempCharacterParts, tempCharacterRootPart = getCharacterParts();
            if tempCharacterRootPart then
                local cframeCall = pcall(function()
                    tempCharacterRootPart.Anchored = false;
                    tempCharacterRootPart.CFrame = lastCharacterCFrame;
                    task.wait(0.1);
                    tempCharacterRootPart.Anchored = false;
                    return ;
                end);
            end;
        end;
        reviveCFrame = nil;
        return ;
    end;
    local setAutoFarmEnabled = nil;
    local heartbeatConnectionFunction = function()
        if heartbeatConnection and heartbeatConnection.Connected then
            heartbeatConnection:Disconnect();
        end;
        heartbeatConnection = runService.Heartbeat:Connect(function()
            if not library.IsRunning then
                if isBossActive then
                    setAutoFarmEnabled(false);
                end;
                return nil;
            end;
            task.wait(configuration.BOSS_CHECK_INTERVAL);
            if not getCharacterParts() then
                if activeBossName ~= "" and activeBossName then
                    resetCharacterPosition(false);
                end;
                lastCharacterName = nil;
                return nil;
            end;
            local activeMapContainer = workspaceService:FindFirstChild("ActiveMap");
            local currentBossName = nil;
            if activeMapContainer then
                for bossIndex, bossAreaName in bossNames, nil, nil do
                    local bossAreaInstance = activeMapContainer:FindFirstChild(bossAreaName);
                    if bossAreaInstance and bossAreaInstance:FindFirstChild("BossSpawn") then
                        currentBossName = bossAreaName;
                        break;
                    end;
                end;
            end;
            if currentBossName ~= lastCharacterName then
                if currentBossName ~= "" and currentBossName then
                    if isBossActive then
                        initialBossDetectDelayComplete = true;
                    else
                        resetBossFight();
                        activeBossName = nil;
                    end;
                elseif activeBossName ~= "" and activeBossName then
                    resetCharacterPosition(false);
                end;
                lastCharacterName = currentBossName;
            end;
            local isBossFightActive = isBossActive and currentBossName;
            if isBossFightActive ~= "" and isBossFightActive then
                if activeBossName ~= currentBossName or not isReviving then
                    if initialBossDetectDelayComplete then
                        task.wait(configuration.INITIAL_BOSS_DETECT_DELAY);
                        initialBossDetectDelayComplete = false;
                        if not isBossActive or not library.IsRunning then
                            return nil;
                        end;
                        local success, characterExists = getCharacterParts();
                        if not characterExists then
                            return nil;
                        end;
                        local activeMapChild = workspaceService:FindFirstChild("ActiveMap");
                        if activeMapChild ~= nil then
                            activeMapChild = activeMapChild:FindFirstChild(currentBossName);
                        end;
                        if not activeMapChild then
                            lastCharacterName = nil;
                            return nil;
                        end;
                        spawnBoss(currentBossName);
                    else
                        spawnBoss(currentBossName);
                    end;
                end;
            else
                local isStringEmptyAndConditionTrue = not (currentBossName ~= "" and currentBossName) and activeBossName;
                if isStringEmptyAndConditionTrue ~= "" and isStringEmptyAndConditionTrue then
                    resetCharacterPosition(false);
                end;
            end;
            if not isBossActive or currentBossName == "" or not currentBossName then
                initialBossDetectDelayComplete = false;
            end;
            return ;
        end);
        return ;
    end;
    local childRemovedConnectionFunction = function()
        if childRemovedConnection and childRemovedConnection.Connected then
            childRemovedConnection:Disconnect();
        end;
        childRemovedConnection = workspaceService.ChildRemoved:Connect(function(ballInstance)
            if ballInstance.Name == "Ball" and isBossActive then
                setAutoFarmEnabled(false);
                resetCharacterPosition(true);
            end;
            return ;
        end);
        return ;
    end;
    setAutoFarmEnabled = function(autoFarmEnabled)
        if isBossActive == autoFarmEnabled then
            return nil;
        end;
        if autoFarmEnabled and not library.IsRunning then
            return nil;
        end;
        isBossActive = autoFarmEnabled;
        if autoFarmEnabled then
            local success, characterModel = getCharacterParts();
            if not characterModel then
                isBossActive = false;
                return nil;
            end;
            heartbeatConnectionFunction();
            childRemovedConnectionFunction();
            local activeMapFolder = workspaceService:FindFirstChild("ActiveMap");
            local bossSpawnName = nil;
            if activeMapFolder then
                for index, mapName in bossNames, nil, nil do
                    local mapInstance = activeMapFolder:FindFirstChild(mapName);
                    if mapInstance and mapInstance:FindFirstChild("BossSpawn") then
                        bossSpawnName = mapName;
                        break;
                    end;
                end;
            end;
            if bossSpawnName ~= "" and bossSpawnName then
                spawnBoss(bossSpawnName);
            else
                resetBossFight();
                activeBossName = nil;
            end;
        else
            if heartbeatConnection and heartbeatConnection.Connected then
                heartbeatConnection:Disconnect();
            end;
            if childRemovedConnection and childRemovedConnection.Connected then
                childRemovedConnection:Disconnect();
            end;
            resetCharacterPosition(true);
        end;
        return ;
    end;
    local setFarmHeight = function(valueToFloor)
        if not library.IsRunning then
            return nil;
        end;
        teleportYOffset = math.floor(valueToFloor + 0.5);
        local farmHeightString = isReviving;
        if farmHeightString then
            farmHeightString = activeBossName;
            if farmHeightString ~= "" and farmHeightString then
                farmHeightString = alignPosition;
            end;
        end;
        if farmHeightString ~= "" and farmHeightString then
            local farmPosition = getBossSpawnPosition(activeBossName);
            if farmPosition then
                local newFarmPosition = Vector3.new(farmPosition.X, farmPosition.Y + teleportYOffset, farmPosition.Z);
                local positionCall = pcall(function()
                    if alignPosition then
                        alignPosition.Position = newFarmPosition;
                    end;
                    return ;
                end);
                local success, characterHumanoid = getCharacterParts();
                if characterHumanoid then
                    local cframeYCall = pcall(function()
                        characterHumanoid.CFrame = CFrame.new(characterHumanoid.Position.X, newFarmPosition.Y, characterHumanoid.Position.Z);
                        return ;
                    end);
                end;
            end;
        end;
        return ;
    end;
    local isAutoFarmEnabled = function()
        return isBossActive;
    end;
    local getCurrentFarmHeight = function()
        return teleportYOffset;
    end;
    local alignPosition = nil;
    local attachment = nil;
    local resetCharacterState = function()
        local destroyAlignPositionCallSuccess = pcall(function()
            if alignPosition and alignPosition.Parent then
                alignPosition:Destroy();
            end;
            return ;
        end);
        local destroyCall3 = pcall(function()
            if attachment and attachment.Parent then
                attachment:Destroy();
            end;
            return ;
        end);
        alignPosition = nil;
        attachment = nil;
        local success, characterRootPart = getCharacterParts();
        if characterRootPart then
            local anchorSuccess = pcall(function()
                characterRootPart.Anchored = false;
                return ;
            end);
        end;
        return ;
    end;
    local teleportCharacter = function(targetPosition)
        local success, characterModel = getCharacterParts();
        if not characterModel then
            return false;
        end;
        resetBossFight();
        resetCharacterState();
        local success, alignPositionSetupSuccess = pcall(function()
            characterModel.Anchored = false;
            characterModel.Velocity = Vector3.zero;
            characterModel.RotVelocity = Vector3.zero;
            attachment = Instance.new("Attachment");
            attachment.Parent = characterModel;
            alignPosition = Instance.new("AlignPosition");
            alignPosition.Parent = characterModel;
            alignPosition.Attachment0 = attachment;
            alignPosition.Mode = Enum.PositionAlignmentMode.OneAttachment;
            alignPosition.ApplyAtCenterOfMass = true;
            alignPosition.MaxForce = configuration.ALIGN_MAX_FORCE;
            alignPosition.Responsiveness = configuration.ALIGN_RESPONSIVENESS;
            alignPosition.Position = targetPosition;
            characterModel.CFrame = CFrame.new(targetPosition);
            local startTime = tick();
            local distance = (characterModel.Position - targetPosition).Magnitude;
            while 4 < distance and tick() - startTime < configuration.TELEPORT_TIMEOUT do
                task.wait();
                local success, characterModel = getCharacterParts();
                if not characterModel then
                    errorFunction("Character invalid during revive TP wait");
                end;
                distance = (characterModel.Position - targetPosition).Magnitude;
            end;
            resetCharacterState();
            return distance <= 4;
        end);
        if not success then
            resetCharacterState();
            return false;
        end;
        return alignPositionSetupSuccess;
    end;
    local revivePlayers = function()
        if not library.IsRunning then
            return nil;
        end;
        local success, characterModel = getCharacterParts();
        if not characterModel then
            return nil;
        end;
        local reviveFolder = workspaceService:FindFirstChild(configuration.REVIVE_FOLDER_NAME);
        if not reviveFolder then
            return nil;
        end;
        local proximityPromptDataList = {};
        for descendantIndex, proximityPrompt in reviveFolder:GetDescendants() do
            if proximityPrompt:IsA("ProximityPrompt") then
                local proximityPromptParent = proximityPrompt.Parent;
                if proximityPromptParent and proximityPromptParent:IsA("BasePart") then
                    local proximityPromptData = { prompt = proximityPrompt, pos = proximityPromptParent.Position };
                    table.insert(proximityPromptDataList, proximityPromptData);
                    local holdDurationSuccess = pcall(function()
                        proximityPrompt.HoldDuration = 0;
                        return ;
                    end);
                end;
            end;
        end;
        if #proximityPromptDataList == 0 then
            return nil;
        end;
        local originalCFrame = characterModel.CFrame;
        local spawnLocationPart = isBossActive and reviveCFrame or originalCFrame;
        for teleportTargetIndex, proximityPromptDataEntry in proximityPromptDataList, nil, nil do
            if not library.IsRunning then
                resetCharacterState();
                return nil;
            end;
            local teleportPosition = proximityPromptDataEntry.pos + Vector3.new(0, configuration.TELEPORT_Y_OFFSET, 0);
            if teleportCharacter(teleportPosition) then
                task.wait(configuration.WAIT_AFTER_TP);
                local proximityPromptSuccess = pcall(function()
                    local fireProximityPromptFunction = getgenv().fireproximityprompt;
                    if type(fireProximityPromptFunction) == "function" then
                        fireProximityPromptFunction(proximityPromptDataEntry.prompt);
                    else
                        proximityPromptDataEntry.prompt:InputHoldBegin();
                        task.wait(0.05);
                        proximityPromptDataEntry.prompt:InputHoldEnd();
                    end;
                    return ;
                end);
                task.wait(configuration.WAIT_AFTER_CLICK);
            end;
            local success, success = getCharacterParts();
            if not success then
                resetCharacterState();
                return nil;
            end;
        end;
        if spawnLocationPart then
            if teleportCharacter(spawnLocationPart.Position) then
                task.wait(0.1);
                local success, characterModel = getCharacterParts();
                if characterModel then
                    local cframeUpdateSuccess = pcall(function()
                        characterModel.CFrame = spawnLocationPart;
                        return ;
                    end);
                end;
                resetCharacterState();
                local teleportSoundId = isBossActive and activeBossName;
                if teleportSoundId ~= "" and teleportSoundId then
                    task.spawn(function()
                        return spawnBoss(activeBossName);
                    end);
                end;
            else
                resetCharacterState();
            end;
        else
            resetCharacterState();
        end;
        return ;
    end;
    local reviveAllPlayers = function()
        if not library.IsRunning then
            return nil;
        end;
        local success, success, humanoidExists = getCharacterParts();
        if success and success and humanoidExists then
            task.spawn(revivePlayers);
        else
            local characterAddedConnection = localPlayer.CharacterAdded:Once(function(character)
                local humanoid = character:WaitForChild("Humanoid", 5);
                if humanoid then
                    task.wait(0.5);
                    if 0 < humanoid.Health then
                        task.spawn(revivePlayers);
                    end;
                end;
                return ;
            end);
            task.delay(20, function()
                if characterAddedConnection and characterAddedConnection.Connected then
                    characterAddedConnection:Disconnect();
                end;
                return ;
            end);
        end;
        return ;
    end;
    return { setAutoFarmEnabled = setAutoFarmEnabled, setFarmHeight = setFarmHeight, isAutoFarmEnabled = isAutoFarmEnabled, getCurrentFarmHeight = getCurrentFarmHeight, reviveAllPlayers = reviveAllPlayers };
end);
registerModule("SkinService", "ModuleScript", "rbxts-bundle-example.DeathBall.SkinService", "rbxts-bundle-example.DeathBall", function()
    local skinServiceModule = getModuleGlobals("rbxts-bundle-example.DeathBall.SkinService");
    local skinServiceScript = skinServiceModule.script;
    local requireFunction = skinServiceModule.require;
    local runtimeLib = requireFunction(skinServiceScript.Parent.Parent.include.RuntimeLib);
    local services = runtimeLib.import(skinServiceScript, skinServiceScript.Parent.Parent, "LKHUB", "Services");
    local playersService = services.Players;
    local workspaceService = services.Workspace;
    local replicatedStorageService = services.ReplicatedStorage;
    local runService = services.RunService;
    local library = runtimeLib.import(skinServiceScript, skinServiceScript.Parent.Parent, "LKHUB", "Library", "Library");
    local localPlayer = playersService.LocalPlayer;
    local animationTrack = nil;
    local runningConnection = nil;
    local heartbeatConnection = nil;
    local currentSword = "Default";
    local currentAnimation = "Default";
    local getSwordData = function()
        local swordNameList = {};
        local assetsFolder = replicatedStorageService:FindFirstChild("Assets");
        if assetsFolder then
            local swordsFolder = assetsFolder:FindFirstChild("Swords");
            if swordsFolder then
                for childIndex, swordModel in swordsFolder:GetChildren() do
                    if swordModel:IsA("Model") then
                        local modelName = swordModel.Name;
                        table.insert(swordNameList, modelName);
                    end;
                end;
            end;
        end;
        return swordNameList;
    end;
    local selectSword = function(swordName)
        if not library.IsRunning then
            return nil;
        end;
        currentSword = swordName;
        local player = localPlayer;
        local character = player.Character or player.CharacterAdded:Wait();
        local playerName = player.Name;
        printFunction((("%* SwordWelds"):format(playerName)));
        for childIndex, swordWeldFolder in workspaceService:GetChildren() do
            if swordWeldFolder:IsA("Folder") and swordWeldFolder.Name == ("%* SwordWelds"):format(playerName) then
                swordWeldFolder:Destroy();
            end;
        end;
        if swordName == "Default" then
            for i, swordPart in character:GetChildren() do
                if swordPart:IsA("Part") and swordPart.Name == "Sword" then
                    swordPart:Destroy();
                end;
            end;
            return nil;
        end;
        local assetsFolder = replicatedStorageService:FindFirstChild("Assets");
        if not assetsFolder then
            return nil;
        end;
        local swordsFolder = assetsFolder:FindFirstChild("Swords");
        if not swordsFolder then
            return nil;
        end;
        local swordDataFolder = swordsFolder:FindFirstChild(swordName);
        for childIndex, swordPart in character:GetChildren() do
            if swordPart:IsA("Part") and swordPart.Name == "Sword" then
                swordPart:Destroy();
            end;
        end;
        if swordDataFolder then
            local swordPartClone = swordDataFolder:FindFirstChild("Sword");
            local offsetValue = swordDataFolder:FindFirstChild("Offset");
            if swordPartClone and offsetValue then
                local clonedSword = swordPartClone:Clone();
                local sword = character:FindFirstChild("Sword");
                if sword then
                    sword:Destroy();
                end;
                clonedSword.Parent = character;
                local rtoolPart = character:FindFirstChild("rtool");
                if rtoolPart then
                    local swordWeld = Instance.new("Weld");
                    swordWeld.Part0 = clonedSword;
                    swordWeld.Part1 = rtoolPart;
                    swordWeld.C1 = offsetValue.Value;
                    swordWeld.Parent = clonedSword;
                    clonedSword.Anchored = false;
                end;
            end;
        end;
        return ;
    end;
    local getAnimationData = function()
        local animationList = {};
        local dataBinsFolder = replicatedStorageService:FindFirstChild("DataBins");
        if not dataBinsFolder then
            return animationList;
        end;
        local itemDataFolder = dataBinsFolder:FindFirstChild("ItemData");
        if not itemDataFolder then
            return animationList;
        end;
        local sheetItemDataFolder = itemDataFolder:FindFirstChild("SheetItemData");
        if not sheetItemDataFolder then
            return animationList;
        end;
        local success, animationData = pcall(function()
            return requireFunction(sheetItemDataFolder);
        end);
        if success and animationData then
            for i, animationEntry in pairsFunction(animationData) do
                local poseDisplayName = animationEntry.Category == "Pose" and animationEntry.DisplayName;
                if poseDisplayName ~= "" and poseDisplayName then
                    local animationName = animationEntry.DisplayName;
                    table.insert(animationList, animationName);
                end;
            end;
        end;
        return animationList;
    end;
    local getAnimationUsageData = function(displayName)
        local dataBinsFolder = replicatedStorageService:FindFirstChild("DataBins");
        if not dataBinsFolder then
            return nil;
        end;
        local itemData = dataBinsFolder:FindFirstChild("ItemData");
        if not itemData then
            return nil;
        end;
        local sheetItemData = itemData:FindFirstChild("SheetItemData");
        if not sheetItemData then
            return nil;
        end;
        local success, animationData = pcall(function()
            return requireFunction(sheetItemData);
        end);
        if success and animationData then
            for index, poseData in pairsFunction(animationData) do
                if poseData.Category == "Pose" and poseData.DisplayName == displayName then
                    return poseData.UsageData;
                end;
            end;
        end;
        return nil;
    end;
    local stopAnimation = nil;
    local selectAnimation = function(poseDisplayName)
        if not library.IsRunning then
            return nil;
        end;
        currentAnimation = poseDisplayName;
        if poseDisplayName == "Default" then
            stopAnimation();
            return nil;
        end;
        local animationId = getAnimationUsageData(poseDisplayName);
        if animationId == 0 or animationId ~= animationId or animationId == "" or not animationId then
            warn((("No Pose found with DisplayName: %*"):format(poseDisplayName)));
            return nil;
        end;
        local someValue7 = nil;
        local animationIdString;
        if type(animationId) == "table" then
            local animationData = animationId;
            local animationId = animationData.AnimationId;
            if animationId == "" or not animationId then
                animationId = animationData[1];
            end;
            animationIdString = animationId;
        else
            animationIdString = animationId;
        end;
        if animationIdString == "" or not animationIdString or tostring(animationIdString) == "" then
            warn((("No AnimationId found in UsageData for Pose: %*"):format(poseDisplayName)));
            return nil;
        end;
        local player = localPlayer;
        local character = player.Character or player.CharacterAdded:Wait();
        local humanoid = character:WaitForChild("Humanoid");
        if runningConnection then
            runningConnection:Disconnect();
        end;
        if heartbeatConnection then
            heartbeatConnection:Disconnect();
        end;
        if animationTrack then
            animationTrack:Stop();
        end;
        local animation = character:FindFirstChild("Animation");
        if not animation then
            animation = Instance.new("Animation");
            animation.Parent = character;
        end;
        animation.AnimationId = ("rbxassetid://%*"):format(tostring(animationIdString));
        animationTrack = humanoid:LoadAnimation(animation);
        local onRunning = function()
            if not library.IsRunning then
                return nil;
            end;
            if humanoid.MoveDirection.Magnitude == 0 then
                if animationTrack and not animationTrack.IsPlaying then
                    animationTrack:Play();
                end;
            elseif animationTrack and animationTrack.IsPlaying then
                animationTrack:Stop();
            end;
            return ;
        end;
        runningConnection = humanoid.Running:Connect(onRunning);
        local currentAnimationId = animation.AnimationId;
        heartbeatConnection = runService.Heartbeat:Connect(function()
            if not library.IsRunning then
                if runningConnection then
                    runningConnection:Disconnect();
                end;
                if heartbeatConnection then
                    heartbeatConnection:Disconnect();
                end;
                if animationTrack then
                    animationTrack:Stop();
                end;
                return nil;
            end;
            if animation.AnimationId ~= currentAnimationId then
                if animationTrack then
                    animationTrack:Stop();
                end;
                animationTrack = humanoid:LoadAnimation(animation);
                animationTrack:Play();
                currentAnimationId = animation.AnimationId;
            end;
            return ;
        end);
        return ;
    end;
    stopAnimation = function()
        if runningConnection then
            runningConnection:Disconnect();
            runningConnection = nil;
        end;
        if heartbeatConnection then
            heartbeatConnection:Disconnect();
            heartbeatConnection = nil;
        end;
        if animationTrack then
            animationTrack:Stop();
            animationTrack = nil;
        end;
        return ;
    end;
    local reapplyAnimations = function()
        if not library.IsRunning then
            return nil;
        end;
        if currentSword ~= "Default" then
            selectSword(currentSword);
        end;
        if currentAnimation ~= "Default" then
            selectAnimation(currentAnimation);
        end;
        return ;
    end;
    local setupCharacterRespawnHandler = function()
        localPlayer.CharacterAdded:Connect(function()
            task.wait(1);
            reapplyAnimations();
            return ;
        end);
        return ;
    end;
    return { getSwordData = getSwordData, selectSword = selectSword, getAnimationData = getAnimationData, selectAnimation = selectAnimation, stopAnimation = stopAnimation, reapplyCurrentSettings = reapplyAnimations, setupCharacterRespawnHandler = setupCharacterRespawnHandler };
end);
createInstance("LKHUB", "Folder", "rbxts-bundle-example.LKHUB", "rbxts-bundle-example");
createInstance("Bypasses", "Folder", "rbxts-bundle-example.LKHUB.Bypasses", "rbxts-bundle-example.LKHUB");
registerModule("AdonisAntiKick", "ModuleScript", "rbxts-bundle-example.LKHUB.Bypasses.AdonisAntiKick", "rbxts-bundle-example.LKHUB.Bypasses", function()
    local adonisAntiKickModule = getModuleGlobals("rbxts-bundle-example.LKHUB.Bypasses.AdonisAntiKick");
    local scriptModule = adonisAntiKickModule.script;
    local requireFunction = adonisAntiKickModule.require;
    return {
        AdonisAntiKick = function()
            for garbageCollectionIndex, garbageCollectionObject in getgc(true) do
                local isIndexInstanceTable = type(garbageCollectionObject) == "table" and rawgetFunction(garbageCollectionObject, "indexInstance") ~= nil;
                if isIndexInstanceTable then
                    local indexInstance = rawgetFunction(garbageCollectionObject, "indexInstance");
                    isIndexInstanceTable = type(indexInstance) == "table";
                end;
                if isIndexInstanceTable then
                    if isreadonly(garbageCollectionObject) then
                        setreadonly(garbageCollectionObject, false);
                    end;
                    garbageCollectionObject.tvk = {
                        "kick",
                        function()
                            return task.wait(9000000000);
                        end
                    };
                end;
            end;
            return ;
        end
    };
end);
createInstance("DefaultTabs", "Folder", "rbxts-bundle-example.LKHUB.DefaultTabs", "rbxts-bundle-example.LKHUB");
registerModule("ISection", "ModuleScript", "rbxts-bundle-example.LKHUB.DefaultTabs.ISection", "rbxts-bundle-example.LKHUB.DefaultTabs", function()
    local iSectionModule = getModuleGlobals("rbxts-bundle-example.LKHUB.DefaultTabs.ISection");
    local scriptModule = iSectionModule.script;
    local requireFunction = iSectionModule.require;
    local someValue8 = nil;
    return {
        default = {
            constructor = function(L_1845, ...)
                local unknownTable = { ... };
                return ;
            end,
            Load = function(L_1847, L_1848)
                errorFunction("Not implemented");
                return ;
            end
        }
    };
end);
createInstance("LocalPlayer", "Folder", "rbxts-bundle-example.LKHUB.DefaultTabs.LocalPlayer", "rbxts-bundle-example.LKHUB.DefaultTabs");
registerModule("SectionAntiAfk", "ModuleScript", "rbxts-bundle-example.LKHUB.DefaultTabs.LocalPlayer.SectionAntiAfk", "rbxts-bundle-example.LKHUB.DefaultTabs.LocalPlayer", function()
    local sectionAntiAfkModule = getModuleGlobals("rbxts-bundle-example.LKHUB.DefaultTabs.LocalPlayer.SectionAntiAfk");
    local sectionAntiAfkScript = sectionAntiAfkModule.script;
    local runtimeLib = sectionAntiAfkModule.require(sectionAntiAfkScript.Parent.Parent.Parent.Parent.include.RuntimeLib);
    local librarySection = runtimeLib.import(sectionAntiAfkScript, sectionAntiAfkScript.Parent.Parent.Parent, "Library", "LibraryWrapper", "LibraryWrapper").LibrarySection;
    local defaultMain = runtimeLib.import(sectionAntiAfkScript, sectionAntiAfkScript.Parent.Parent.Parent, "Main").default;
    local playersService = runtimeLib.import(sectionAntiAfkScript, sectionAntiAfkScript.Parent.Parent.Parent, "Services").Players;
    local someValue9 = nil;
    local librarySectionWrapper = librarySection;
    local sectionAntiAfkMetatable = setmetatableFunction({}, {
        __tostring = function()
            return "SectionAntiAfk";
        end,
        __index = librarySectionWrapper
    });
    sectionAntiAfkMetatable.__index = sectionAntiAfkMetatable;
    sectionAntiAfkMetatable.new = function(...)
        local newObject = setmetatableFunction({}, sectionAntiAfkMetatable);
        return newObject:constructor(...) or newObject;
    end;
    sectionAntiAfkMetatable.constructor = function(arg1, antiAfkName)
        librarySectionWrapper.constructor(arg1, antiAfkName, "Anti AFK");
        return ;
    end;
    sectionAntiAfkMetatable.Load = function(antiAfkClass, antiAfkModule)
        local antiAfkSection = antiAfkClass.new(antiAfkModule);
        antiAfkSection:InitObjects();
        antiAfkClass.Instance = antiAfkSection;
        return antiAfkSection;
    end;
    sectionAntiAfkMetatable.InitObjects = function(librarySection)
        librarySection.AntiAfkToggle = librarySection:AddToggle({
            Name = "Anti AFK",
            Default = true,
            Callback = function(isAntiAfkEnabled)
                if getconnections == nil then
                    return defaultMain:Notification("Anti AFK Error", "Your executor does not have the required 'getconnections()' method", 30);
                end;
                if isAntiAfkEnabled then
                    local idledConnections = getconnections(playersService.LocalPlayer.Idled);
                    local disableConnection = function(disableFunction)
                        return disableFunction:Disable();
                    end;
                    for connectionIndex, connection in idledConnections, nil, nil do
                        disableConnection(connection, connectionIndex - 1, idledConnections);
                    end;
                else
                    local idleConnections = getconnections(playersService.LocalPlayer.Idled);
                    local enableConnection = function(enableFunction)
                        return enableFunction:Enable();
                    end;
                    for connectionIndex, connection in idleConnections, nil, nil do
                        enableConnection(connection, connectionIndex - 1, idleConnections);
                    end;
                end;
                return ;
            end
        });
        return ;
    end;
    return { default = sectionAntiAfkMetatable };
end);
registerModule("SectionPlayer", "ModuleScript", "rbxts-bundle-example.LKHUB.DefaultTabs.LocalPlayer.SectionPlayer", "rbxts-bundle-example.LKHUB.DefaultTabs.LocalPlayer", function()
    local sectionPlayerModule = getModuleGlobals("rbxts-bundle-example.LKHUB.DefaultTabs.LocalPlayer.SectionPlayer");
    local sectionPlayerScript = sectionPlayerModule.script;
    local runtimeLibRequire = sectionPlayerModule.require(sectionPlayerScript.Parent.Parent.Parent.Parent.include.RuntimeLib);
    local libraryWrapper = runtimeLibRequire.import(sectionPlayerScript, sectionPlayerScript.Parent.Parent.Parent, "Library", "LibraryWrapper", "LibraryWrapper");
    local librarySection = libraryWrapper.LibrarySection;
    local librarySlider = libraryWrapper.LibrarySlider;
    local mainModule = runtimeLibRequire.import(sectionPlayerScript, sectionPlayerScript.Parent.Parent.Parent, "Main").default;
    local uncGlobalsCloneref = runtimeLibRequire.import(sectionPlayerScript, sectionPlayerScript.Parent.Parent.Parent, "UNCGlobals").cloneref;
    local playersService = uncGlobalsCloneref(game:GetService("Players"));
    local userInputService = uncGlobalsCloneref(game:GetService("UserInputService"));
    local teleportServiceWrapper = uncGlobalsCloneref(game:GetService("TeleportService"));
    local workspaceService = uncGlobalsCloneref(game:GetService("Workspace"));
    local playerMouse = playersService.LocalPlayer:GetMouse();
    local getPlayerCharacter = function(localPlayer)
        if localPlayer == nil then
            localPlayer = playersService.LocalPlayer;
        end;
        return localPlayer.Character or localPlayer.CharacterAdded:Wait();
    end;
    local someValue10 = nil;
    local librarySection = librarySection;
    local sectionPlayer = setmetatableFunction({}, {
        __tostring = function()
            return "SectionPlayer";
        end,
        __index = librarySection
    });
    sectionPlayer.__index = sectionPlayer;
    sectionPlayer.new = function(...)
        local newObject = setmetatableFunction({}, sectionPlayer);
        return newObject:constructor(...) or newObject;
    end;
    sectionPlayer.constructor = function(aimbotSection, aimbotName)
        librarySection.constructor(aimbotSection, aimbotName, "Aimbot");
        return ;
    end;
    sectionPlayer.Load = function(toggle, aimbotModule)
        local newToggle = toggle.new(aimbotModule);
        newToggle:InitObjects();
        toggle.Instance = newToggle;
        return newToggle;
    end;
    sectionPlayer.InitObjects = function(localPlayerSection)
        librarySlider.new(localPlayerSection, {
            Name = "WalkSpeed",
            Default = 16,
            Min = 12,
            Max = 1000,
            AllowInput = true,
            IgnoreFirst = true,
            Callback = function(walkSpeed)
                local humanoid = getPlayerCharacter():FindFirstChildOfClass("Humanoid");
                if humanoid then
                    humanoid.WalkSpeed = walkSpeed;
                end;
                return ;
            end
        });
        librarySlider.new(localPlayerSection, {
            Name = "Jump Height",
            Default = 7.2,
            Min = 0,
            Max = 100,
            Increment = 0.05,
            AllowInput = true,
            IgnoreFirst = true,
            Callback = function(jumpHeight)
                local humanoid = getPlayerCharacter():FindFirstChildOfClass("Humanoid");
                if humanoid then
                    if humanoid.UseJumpPower then
                        humanoid.JumpPower = math.sqrt(2 * workspaceService.Gravity * jumpHeight);
                    else
                        humanoid.JumpHeight = jumpHeight;
                    end;
                end;
                return ;
            end
        });
        librarySlider.new(localPlayerSection, {
            Name = "FOV",
            Default = 70,
            Min = 1,
            Max = 120,
            AllowInput = true,
            IgnoreFirst = true,
            Callback = function(fieldOfView)
                workspaceService.CurrentCamera.FieldOfView = fieldOfView;
                return ;
            end
        });
        localPlayerSection.ClickTP = localPlayerSection:AddToggle({ Name = "Click TP", Default = false });
        localPlayerSection.InfJump = localPlayerSection:AddToggle({ Name = "Infinite Jump", Default = false });
        local isMovingForward = false;
        local forwardTeleportSpeedSlider = nil;
        localPlayerSection:AddBind({
            Name = "ForwardTeleport",
            Default = Enum.KeyCode.F,
            Hold = true,
            IgnoreFirst = true,
            Callback = function(unknownValue)
                isMovingForward = unknownValue;
                while isMovingForward do
                    local humanoidRootPart = getPlayerCharacter():FindFirstChild("HumanoidRootPart");
                    if humanoidRootPart then
                        humanoidRootPart.CFrame = humanoidRootPart.CFrame + humanoidRootPart.CFrame.LookVector * forwardTeleportSpeedSlider.Instance.Value;
                    end;
                    task.wait();
                end;
                return ;
            end
        });
        forwardTeleportSpeedSlider = localPlayerSection:AddSlider({ Name = "Forward Teleport Speed", Default = 3, Min = 0.05, Max = 10, AllowInput = true, Increment = 0.05, IgnoreFirst = true });
        localPlayerSection:AddButton({
            Name = "Rejoin Server",
            Callback = function()
                if #playersService:GetPlayers() <= 1 then
                    playersService.LocalPlayer:Kick("Rejoining...");
                    task.wait();
                    teleportServiceWrapper:Teleport(game.PlaceId);
                else
                    teleportServiceWrapper:TeleportToPlaceInstance(game.PlaceId, game.JobId);
                end;
                return ;
            end
        });
        mainModule:Clean(userInputService.InputEnded:Connect(function(inputObject, L_1911)
            if not playerMouse.Target then
                return nil;
            end;
            if not localPlayerSection.ClickTP.Instance.Value then
                return nil;
            end;
            if inputObject.UserInputType == Enum.UserInputType.MouseButton1 or inputObject.UserInputType == Enum.UserInputType.Touch then
                getPlayerCharacter():MoveTo(playerMouse.Hit.Position);
            end;
            return ;
        end));
        mainModule:Clean(userInputService.JumpRequest:Connect(function()
            if not localPlayerSection.InfJump.Instance.Value then
                return nil;
            end;
            local humanoid = getPlayerCharacter():FindFirstChildOfClass("Humanoid");
            if not humanoid then
                return nil;
            end;
            local humanoidRootPart = getPlayerCharacter():FindFirstChild("HumanoidRootPart");
            if humanoid:GetState() == Enum.HumanoidStateType.Jumping or humanoid:GetState() == Enum.HumanoidStateType.Freefall then
                humanoidRootPart.Velocity = Vector3.new(0, humanoid.JumpPower, 0);
            end;
            return ;
        end));
        return ;
    end;
    return { getChar = getPlayerCharacter, default = sectionPlayer };
end);
registerModule("SectionServer", "ModuleScript", "rbxts-bundle-example.LKHUB.DefaultTabs.LocalPlayer.SectionServer", "rbxts-bundle-example.LKHUB.DefaultTabs.LocalPlayer", function()
    local sectionServerModule = getModuleGlobals("rbxts-bundle-example.LKHUB.DefaultTabs.LocalPlayer.SectionServer");
    local sectionServerScript = sectionServerModule.script;
    local runtimeLibRequire = sectionServerModule.require(sectionServerScript.Parent.Parent.Parent.Parent.include.RuntimeLib);
    local librarySection = runtimeLibRequire.import(sectionServerScript, sectionServerScript.Parent.Parent.Parent, "Library", "LibraryWrapper", "LibraryWrapper").LibrarySection;
    local notificationModule = runtimeLibRequire.import(sectionServerScript, sectionServerScript.Parent.Parent.Parent, "Main").default;
    local services = runtimeLibRequire.import(sectionServerScript, sectionServerScript.Parent.Parent.Parent, "Services");
    local teleportService = services.TeleportService;
    local playersService = services.Players;
    local httpService = services.HttpService;
    local someValue11 = nil;
    local sectionServerBase = librarySection;
    local sectionServerMetatable = setmetatableFunction({}, {
        __tostring = function()
            return "SectionServer";
        end,
        __index = sectionServerBase
    });
    sectionServerMetatable.__index = sectionServerMetatable;
    sectionServerMetatable.new = function(...)
        local newObject = setmetatableFunction({}, sectionServerMetatable);
        return newObject:constructor(...) or newObject;
    end;
    sectionServerMetatable.constructor = function(serverObject, serverName)
        sectionServerBase.constructor(serverObject, serverName, "Server");
        return ;
    end;
    sectionServerMetatable.Load = function(SectionServer, serverModule)
        local sectionServerInstance = SectionServer.new(serverModule);
        sectionServerInstance:InitObjects();
        SectionServer.Instance = sectionServerInstance;
        return sectionServerInstance;
    end;
    sectionServerMetatable.InitObjects = function(libraryMain)
        libraryMain:AddButton({
            Name = "Rejoin",
            Callback = function()
                if #playersService:GetPlayers() <= 1 then
                    playersService.LocalPlayer:Kick("Rejoining...");
                    task.wait();
                    teleportService:Teleport(game.PlaceId, playersService.LocalPlayer);
                else
                    teleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, playersService.LocalPlayer);
                end;
                return ;
            end
        });
        libraryMain:AddButton({
            Name = "Server Hop",
            Callback = function()
                local availableJobIds = {};
                local serverListResponse = httpRequestFunction({ Url = ("https://games.roblox.com/v1/games/%*/servers/Public?sortOrder=Asc&limit=100"):format(game.PlaceId), Method = "GET", Headers = { ["Content-Type"] = "application/json" } });
                for instanceIndex, serverData in httpService:JSONDecode(serverListResponse.Body).data, nil, nil do
                    if type(serverData) == "table" then
                        local maxPlayers = serverData.maxPlayers;
                        if serverData.playing < maxPlayers and serverData.id ~= game.JobId then
                            local instanceId = serverData.id;
                            table.insert(availableJobIds, instanceId);
                        end;
                    end;
                end;
                if 0 < #availableJobIds then
                    teleportService:TeleportToPlaceInstance(game.PlaceId, availableJobIds[math.random(0, #availableJobIds - 1) + 1], playersService.LocalPlayer);
                else
                    notificationModule:Notification("Server Hop", "Couldn't find a server", 7);
                end;
                return ;
            end
        });
        return ;
    end;
    return { default = sectionServerMetatable };
end);
createInstance("Settings", "Folder", "rbxts-bundle-example.LKHUB.DefaultTabs.Settings", "rbxts-bundle-example.LKHUB.DefaultTabs");
registerModule("SectionCredits", "ModuleScript", "rbxts-bundle-example.LKHUB.DefaultTabs.Settings.SectionCredits", "rbxts-bundle-example.LKHUB.DefaultTabs.Settings", function()
    local sectionCreditsModule = getModuleGlobals("rbxts-bundle-example.LKHUB.DefaultTabs.Settings.SectionCredits");
    local scriptReference = sectionCreditsModule.script;
    local librarySection = sectionCreditsModule.require(scriptReference.Parent.Parent.Parent.Parent.include.RuntimeLib).import(scriptReference, scriptReference.Parent.Parent.Parent, "Library", "LibraryWrapper", "LibraryWrapper").LibrarySection;
    local someValue12 = nil;
    local sectionCreditsBase = librarySection;
    local sectionCreditsMetatable = setmetatableFunction({}, {
        __tostring = function()
            return "SectionCredits";
        end,
        __index = sectionCreditsBase
    });
    sectionCreditsMetatable.__index = sectionCreditsMetatable;
    sectionCreditsMetatable.new = function(...)
        local instance = setmetatableFunction({}, sectionCreditsMetatable);
        return instance:constructor(...) or instance;
    end;
    sectionCreditsMetatable.constructor = function(creditsObject, creditsArgument)
        sectionCreditsBase.constructor(creditsObject, creditsArgument, "Credits");
        return ;
    end;
    sectionCreditsMetatable.Load = function(SectionCredits, creditsArgument2)
        local sectionCreditsInstance = SectionCredits.new(creditsArgument2);
        sectionCreditsInstance:InitObjects();
        SectionCredits.Instance = sectionCreditsInstance;
        return sectionCreditsInstance;
    end;
    sectionCreditsMetatable.InitObjects = function(lkhubMenu)
        lkhubMenu:AddButton({
            Name = "Script Made by LKHUB",
            Callback = function()
                return ;
            end
        });
        lkhubMenu:AddButton({
            Name = "Discord Server",
            Callback = function()
                setclipboard("https://discord.gg/7KUB96VeDg");
                return ;
            end
        });
        return ;
    end;
    return { default = sectionCreditsMetatable };
end);
registerModule("SectionProfiles", "ModuleScript", "rbxts-bundle-example.LKHUB.DefaultTabs.Settings.SectionProfiles", "rbxts-bundle-example.LKHUB.DefaultTabs.Settings", function()
    local sectionProfilesModule = getModuleGlobals("rbxts-bundle-example.LKHUB.DefaultTabs.Settings.SectionProfiles");
    local sectionProfilesScript = sectionProfilesModule.script;
    local runtimeLib = sectionProfilesModule.require(sectionProfilesScript.Parent.Parent.Parent.Parent.include.RuntimeLib);
    local libraryWrapper = runtimeLib.import(sectionProfilesScript, sectionProfilesScript.Parent.Parent.Parent, "Library", "LibraryWrapper", "LibraryWrapper");
    local libraryButton = libraryWrapper.LibraryButton;
    local libraryDropdown = libraryWrapper.LibraryDropdown;
    local librarySection = libraryWrapper.LibrarySection;
    local libraryTextbox = libraryWrapper.LibraryTextbox;
    local makeSafeFileName = runtimeLib.import(sectionProfilesScript, sectionProfilesScript.Parent.Parent.Parent, "Utils").makeSafeFileName;
    local isFile = runtimeLib.import(sectionProfilesScript, sectionProfilesScript.Parent.Parent.Parent, "UNCGlobals").isfile;
    local library = runtimeLib.import(sectionProfilesScript, sectionProfilesScript.Parent.Parent.Parent, "Library", "Library");
    local someValue13 = nil;
    local sectionProfilesBase = librarySection;
    local sectionProfilesMetatable = setmetatableFunction({}, {
        __tostring = function()
            return "SectionProfiles";
        end,
        __index = sectionProfilesBase
    });
    sectionProfilesMetatable.__index = sectionProfilesMetatable;
    sectionProfilesMetatable.new = function(...)
        local instance2 = setmetatableFunction({}, sectionProfilesMetatable);
        return instance2:constructor(...) or instance2;
    end;
    sectionProfilesMetatable.constructor = function(profilesObject, profilesArgument)
        sectionProfilesBase.constructor(profilesObject, profilesArgument, "Profiles");
        return ;
    end;
    sectionProfilesMetatable.Load = function(ProfileManager, profilesArgument2)
        local profileManagerInstance = ProfileManager.new(profilesArgument2);
        profileManagerInstance:InitObjects();
        ProfileManager.Instance = profileManagerInstance;
        return profileManagerInstance;
    end;
    sectionProfilesMetatable.InitObjects = function(libraryWrapper)
        libraryWrapper.ProfilesDropdown = libraryDropdown.new(libraryWrapper, {
            Name = "Profile",
            Options = libraryWrapper.Parent.LibraryMain.Profiles,
            Default = "Default",
            IgnoreFirst = true,
            Callback = function(saveFileName)
                if type(saveFileName) ~= "string" then
                    return nil;
                end;
                libraryWrapper.Parent.LibraryMain:Save(saveFileName);
                libraryWrapper.Parent.LibraryMain:Load();
                return ;
            end
        });
        libraryWrapper.RemoveCurrentProfile = libraryButton.new(libraryWrapper, {
            Name = "Remove Current Profile",
            Callback = function()
                local libraryMain = libraryWrapper.Parent.LibraryMain;
                if libraryMain.Profile ~= "Default" then
                    local profileList = libraryMain.Profiles;
                    local currentProfileName = libraryMain.Profile;
                    local profileIndex = (table.find(profileList, currentProfileName) or 0) - 1;
                    if profileIndex ~= -1 then
                        table.remove(libraryMain.Profiles, profileIndex + 1);
                    end;
                    local profileFilePath = ("lkhub/profiles/%*"):format(makeSafeFileName((("%*_%*.profile"):format(libraryMain.Profile, libraryMain.gameName))));
                    if isFile(profileFilePath) and delfile then
                        delfile(profileFilePath);
                    end;
                    local newProfile = libraryMain.Profiles[#libraryMain.Profiles + 1];
                    libraryWrapper.Parent.LibraryMain:Save(newProfile);
                    libraryWrapper.Parent.LibraryMain:Load();
                    return ;
                end;
                return library.Notification({ Title = "LKHUB | Error", Content = "Failed to delete 'Default' profile: Profile is Locked", Delay = 10 });
            end
        });
        libraryWrapper.ProfileName = libraryTextbox.new(libraryWrapper, { Name = "New Profile Name", PlaceholderText = "New Profile Name", IgnoreFirst = true });
        libraryWrapper.AddProfile = libraryButton.new(libraryWrapper, {
            Name = "Add New Profile",
            Callback = function()
                local profileName = libraryWrapper.ProfileName.Instance.Value;
                if profileName == "" then
                    return nil;
                end;
                local libraryMainInstance = libraryWrapper.Parent.LibraryMain;
                if (table.find(libraryMainInstance.Profiles, profileName) or 0) - 1 ~= -1 then
                    return library.Notification({ Title = "LKHUB | Error", Content = "Profile with that name already exists", Delay = 10 });
                end;
                local profilesList = libraryMainInstance.Profiles;
                table.insert(profilesList, profileName);
                libraryWrapper.Parent.LibraryMain:Save(profileName);
                libraryWrapper.Parent.LibraryMain:Load();
                return ;
            end
        });
        return ;
    end;
    return { default = sectionProfilesMetatable };
end);
registerModule("SectionToggleGUI", "ModuleScript", "rbxts-bundle-example.LKHUB.DefaultTabs.Settings.SectionToggleGUI", "rbxts-bundle-example.LKHUB.DefaultTabs.Settings", function()
    local sectionToggleGUIModule = getModuleGlobals("rbxts-bundle-example.LKHUB.DefaultTabs.Settings.SectionToggleGUI");
    local sectionToggleGUIScript = sectionToggleGUIModule.script;
    local runtimeLib = sectionToggleGUIModule.require(sectionToggleGUIScript.Parent.Parent.Parent.Parent.include.RuntimeLib);
    local librarySection = runtimeLib.import(sectionToggleGUIScript, sectionToggleGUIScript.Parent.Parent.Parent, "Library", "LibraryWrapper", "LibraryWrapper").LibrarySection;
    local mainModule = runtimeLib.import(sectionToggleGUIScript, sectionToggleGUIScript.Parent.Parent.Parent, "Main").default;
    local someValue14 = nil;
    local librarySectionConstructor = librarySection;
    local sectionToggleGUIMetatable = setmetatableFunction({}, {
        __tostring = function()
            return "SectionToggleGUI";
        end,
        __index = librarySectionConstructor
    });
    sectionToggleGUIMetatable.__index = sectionToggleGUIMetatable;
    sectionToggleGUIMetatable.new = function(...)
        local instance3 = setmetatableFunction({}, sectionToggleGUIMetatable);
        return instance3:constructor(...) or instance3;
    end;
    sectionToggleGUIMetatable.constructor = function(self, toggleGuiArgument)
        librarySectionConstructor.constructor(self, toggleGuiArgument, "Toggle GUI");
        return ;
    end;
    sectionToggleGUIMetatable.Load = function(ESPColorpicker, toggleGuiArgument2)
        local espColorpickerInstance = ESPColorpicker.new(toggleGuiArgument2);
        espColorpickerInstance:InitObjects();
        ESPColorpicker.Instance = espColorpickerInstance;
        return espColorpickerInstance;
    end;
    sectionToggleGUIMetatable.InitObjects = function(library)
        library.ToggleGUIBind = library:AddBind({
            Name = "Toggle GUI",
            Default = Enum.KeyCode.RightControl,
            IgnoreFirst = true,
            Callback = function()
                mainModule.Library.MainFrame.Visible = not mainModule.Library.MainFrame.Visible;
                return ;
            end
        });
        return ;
    end;
    return { default = sectionToggleGUIMetatable };
end);
createInstance("ESP", "Folder", "rbxts-bundle-example.LKHUB.ESP", "rbxts-bundle-example.LKHUB");
registerModule("ESPColorpicker", "ModuleScript", "rbxts-bundle-example.LKHUB.ESP.ESPColorpicker", "rbxts-bundle-example.LKHUB.ESP", function()
    local espColorpickerModule = getModuleGlobals("rbxts-bundle-example.LKHUB.ESP.ESPColorpicker");
    local scriptModule = espColorpickerModule.script;
    local requireFunction = espColorpickerModule.require;
    local someValue15 = nil;
    local espColorpickerMetatable = setmetatableFunction({}, {
        __tostring = function()
            return "ESPColorpicker";
        end
    });
    espColorpickerMetatable.__index = espColorpickerMetatable;
    espColorpickerMetatable.new = function(...)
        local instance4 = setmetatableFunction({}, espColorpickerMetatable);
        return instance4:constructor(...) or instance4;
    end;
    espColorpickerMetatable.constructor = function(defaultColor, colorValue)
        if typeofFunction(colorValue) == "Color3" then
            defaultColor.defaultColor = colorValue;
        else
            defaultColor.colorpicker = colorValue;
        end;
        return ;
    end;
    espColorpickerMetatable.getColor = function(espColorpicker)
        local selectedColor = espColorpicker.colorpicker;
        if selectedColor ~= nil then
            selectedColor = selectedColor.Instance.Value;
        end;
        local currentColor = selectedColor;
        if currentColor == nil then
            currentColor = espColorpicker.defaultColor;
        end;
        return currentColor;
    end;
    return { default = espColorpickerMetatable };
end);
registerModule("ESPUtils", "ModuleScript", "rbxts-bundle-example.LKHUB.ESP.ESPUtils", "rbxts-bundle-example.LKHUB.ESP", function()
    local espUtilsModule = getModuleGlobals("rbxts-bundle-example.LKHUB.ESP.ESPUtils");
    local scriptReference2 = espUtilsModule.script;
    local services = espUtilsModule.require(scriptReference2.Parent.Parent.Parent.include.RuntimeLib).import(scriptReference2, scriptReference2.Parent.Parent, "Services");
    local playersService = services.Players;
    local workspaceService = services.Workspace;
    local currentCamera = workspaceService.CurrentCamera;
    local localPlayer = playersService.LocalPlayer;
    local mouse = localPlayer:GetMouse();
    local ignoredInstancesList = {};
    local someValue16 = nil;
    local espUtils = setmetatableFunction({}, {
        __tostring = function()
            return "ESPUtils";
        end
    });
    espUtils.__index = espUtils;
    espUtils.new = function(...)
        local instance5 = setmetatableFunction({}, espUtils);
        return instance5:constructor(...) or instance5;
    end;
    espUtils.constructor = function(L_2021)
        return ;
    end;
    espUtils.CheckRay = function(L_2022, ignoreList, raycastDistance, raycastOrigin, raycastDirection, dataList)
        if 1000 <= raycastDistance then
            return false;
        end;
        local hitNothing = true;
        local raycastParams = RaycastParams.new();
        local callbackResultsList = {};
        local character = localPlayer.Character;
        table.insert(callbackResultsList, character);
        table.insert(callbackResultsList, currentCamera);
        if mouse.TargetFilter then
            local targetFilter = mouse.TargetFilter;
            table.insert(callbackResultsList, targetFilter);
        end;
        while 64 < #ignoredInstancesList do
            table.remove(ignoredInstancesList, 2);
        end;
        local insertAndCountCallback = function(filterInstance)
            table.insert(callbackResultsList, filterInstance);
            return #callbackResultsList;
        end;
        for index, value in ignoredInstancesList, nil, nil do
            insertAndCountCallback(value, index - 1, ignoredInstancesList);
        end;
        if dataList then
            local insertAndCountCallback2 = function(filterInstance2)
                table.insert(callbackResultsList, filterInstance2);
                return #callbackResultsList;
            end;
            for index2, value2 in dataList, nil, nil do
                insertAndCountCallback2(value2, index2 - 1, dataList);
            end;
        end;
        raycastParams.FilterType = Enum.RaycastFilterType.Exclude;
        raycastParams:AddToFilter(callbackResultsList);
        local raycastResult = workspaceService:Raycast(raycastOrigin, raycastDirection * raycastDistance, raycastParams);
        if raycastResult ~= nil then
            raycastResult = raycastResult.Instance;
        end;
        local hitPart = raycastResult;
        if hitPart and not hitPart:IsDescendantOf(ignoreList) then
            hitNothing = false;
            if 0.3 <= hitPart.Transparency or not hitPart.CanCollide and not hitPart:IsA("Terrain") then
                table.insert(ignoredInstancesList, hitPart);
            end;
        end;
        return hitNothing;
    end;
    espUtils.EnsureHighlight = function(L_2043, parentInstance, highlightName, outlineColor, adorneePart)
        local highlightInstance = parentInstance:FindFirstChild(highlightName);
        if highlightInstance and highlightInstance:IsA("Highlight") then
            highlightInstance.OutlineColor = outlineColor;
            return highlightInstance;
        end;
        local highlight = Instance.new("Highlight");
        highlight.Name = highlightName;
        highlight.Adornee = adorneePart or parentInstance;
        highlight.FillTransparency = 1;
        highlight.OutlineTransparency = 0;
        highlight.OutlineColor = outlineColor;
        highlight.Parent = parentInstance;
        return highlight;
    end;
    return { camera = currentCamera, default = espUtils };
end);
createInstance("PlayerESP", "Folder", "rbxts-bundle-example.LKHUB.ESP.PlayerESP", "rbxts-bundle-example.LKHUB.ESP");
createInstance("Components", "Folder", "rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components", "rbxts-bundle-example.LKHUB.ESP.PlayerESP");
registerModule("ESPBaseComponent", "ModuleScript", "rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components.ESPBaseComponent", "rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components", function()
    local espBaseComponentModule = getModuleGlobals("rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components.ESPBaseComponent");
    local scriptModule = espBaseComponentModule.script;
    local requireFunction = espBaseComponentModule.require;
    local someValue17 = nil;
    local espBaseComponent = setmetatableFunction({}, {
        __tostring = function()
            return "ESPBaseComponent";
        end
    });
    espBaseComponent.__index = espBaseComponent;
    espBaseComponent.new = function(...)
        local instance6 = setmetatableFunction({}, espBaseComponent);
        return instance6:constructor(...) or instance6;
    end;
    espBaseComponent.constructor = function(instancePart, parentInstance)
        instancePart.Parent = parentInstance;
        return ;
    end;
    espBaseComponent.getVisible = function(onScreenData)
        return onScreenData.Parent.data.onScreen;
    end;
    espBaseComponent.update = function(L_2059)
        return ;
    end;
    espBaseComponent.destroy = function(L_2060)
        return ;
    end;
    return { default = espBaseComponent };
end);
registerModule("ESPBox", "ModuleScript", "rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components.ESPBox", "rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components", function()
    local espBoxModule = getModuleGlobals("rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components.ESPBox");
    local espBoxScript = espBoxModule.script;
    local runtimeLibRequire = espBoxModule.require(espBoxScript.Parent.Parent.Parent.Parent.Parent.include.RuntimeLib);
    local espBaseComponentDefault = runtimeLibRequire.import(espBoxScript, espBoxScript.Parent, "ESPBaseComponent").default;
    local cameraUtils = runtimeLibRequire.import(espBoxScript, espBoxScript.Parent.Parent.Parent, "ESPUtils").camera;
    local someValue18 = nil;
    local espBaseComponentInstance = espBaseComponentDefault;
    local espBox = setmetatableFunction({}, {
        __tostring = function()
            return "ESPBox";
        end,
        __index = espBaseComponentInstance
    });
    espBox.__index = espBox;
    espBox.new = function(...)
        local instance7 = setmetatableFunction({}, espBox);
        return instance7:constructor(...) or instance7;
    end;
    espBox.constructor = function(self, argument)
        espBaseComponentInstance.constructor(self, argument);
        self:initialize();
        return ;
    end;
    espBox.initialize = function(espDrawing)
        local drawingBorder = Drawing.new("Square");
        drawingBorder.Transparency = 1;
        drawingBorder.Thickness = 3;
        drawingBorder.Filled = false;
        espDrawing.DrawingBorder = drawingBorder;
        local squareDrawing = Drawing.new("Square");
        squareDrawing.Transparency = 1;
        squareDrawing.Thickness = 1;
        squareDrawing.Filled = false;
        espDrawing.Drawing = squareDrawing;
        return ;
    end;
    espBox.getVisible = function(config)
        local isVisible = espBaseComponentInstance.getVisible(config);
        if isVisible then
            local toggle = config.toggle;
            if toggle ~= nil then
                toggle = toggle.Instance.Value;
            end;
            local borderEnabled = toggle;
            if borderEnabled == nil then
                borderEnabled = false;
            end;
            isVisible = borderEnabled;
        end;
        return isVisible;
    end;
    espBox.update = function(espObject)
        local isVisibleResult = espObject:getVisible();
        local borderToggleValue = espObject.borderToggle;
        if borderToggleValue ~= nil then
            borderToggleValue = borderToggleValue.Instance.Value;
        end;
        local borderToggleState = borderToggleValue;
        if borderToggleState == nil then
            borderToggleState = false;
        end;
        local isBorderEnabled = borderToggleState;
        espObject.Drawing.Visible = isVisibleResult;
        espObject.DrawingBorder.Visible = isVisibleResult and isBorderEnabled;
        if espBaseComponentInstance.getVisible(espObject) then
            local screenPosition = espObject.Parent.data.screenPosition;
            local viewportWidth = cameraUtils.ViewportSize.X;
            local viewportHeight = cameraUtils.ViewportSize.Y;
            local scaleFactor = 1 / (screenPosition.Z * math.tan(math.rad(cameraUtils.FieldOfView * 0.5)) * 2) * 100;
            local scaledWidth = math.floor(viewportHeight / 25 * scaleFactor);
            local scaledHeight = math.floor(viewportWidth / 27 * scaleFactor);
            local drawingPosition = Vector2.new(screenPosition.X - scaledWidth / 2, screenPosition.Y - scaledHeight / 2);
            local drawingSize = Vector2.new(scaledWidth, scaledHeight);
            if isBorderEnabled then
                espObject.DrawingBorder.Position = drawingPosition;
                espObject.DrawingBorder.Size = drawingSize;
                local borderColorValue = espObject.borderColorpicker;
                if borderColorValue ~= nil then
                    borderColorValue = borderColorValue:getColor();
                end;
                local borderColor = borderColorValue;
                if borderColor == nil then
                    borderColor = Color3.new(0, 0, 0);
                end;
                espObject.DrawingBorder.Color = borderColor;
            end;
            espObject.Drawing.Position = drawingPosition;
            espObject.Drawing.Size = drawingSize;
            local fillColorValue = espObject.colorpicker;
            if fillColorValue ~= nil then
                fillColorValue = fillColorValue:getColor(espObject);
            end;
            local fillColor = fillColorValue;
            if fillColor == nil then
                fillColor = Color3.new(1, 1, 1);
            end;
            espObject.Drawing.Color = fillColor;
        end;
        return ;
    end;
    espBox.destroy = function(drawingData)
        drawingData.Drawing:Destroy();
        drawingData.DrawingBorder:Destroy();
        return ;
    end;
    espBox.setToggle = function(espSettings, toggleValue)
        espSettings.toggle = toggleValue;
        return espSettings;
    end;
    espBox.setBorderToggle = function(espSettings2, borderToggle)
        espSettings2.borderToggle = borderToggle;
        return espSettings2;
    end;
    espBox.setColorpicker = function(espSettings3, colorpicker)
        espSettings3.colorpicker = colorpicker;
        return espSettings3;
    end;
    espBox.setBorderColorpicker = function(espSettings4, borderColorpicker)
        espSettings4.borderColorpicker = borderColorpicker;
        return espSettings4;
    end;
    return { default = espBox };
end);
registerModule("ESPHealthBar", "ModuleScript", "rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components.ESPHealthBar", "rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components", function()
    local espHealthBarModule = getModuleGlobals("rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components.ESPHealthBar");
    local scriptReference3 = espHealthBarModule.script;
    local espBaseComponent = espHealthBarModule.require(scriptReference3.Parent.Parent.Parent.Parent.Parent.include.RuntimeLib).import(scriptReference3, scriptReference3.Parent, "ESPBaseComponent").default;
    local someValue19 = nil;
    local espHealthBarClass = espBaseComponent;
    local espHealthBarMetatable = setmetatableFunction({}, {
        __tostring = function()
            return "ESPHealthBar";
        end,
        __index = espHealthBarClass
    });
    espHealthBarMetatable.__index = espHealthBarMetatable;
    espHealthBarMetatable.new = function(...)
        local instance8 = setmetatableFunction({}, espHealthBarMetatable);
        return instance8:constructor(...) or instance8;
    end;
    espHealthBarMetatable.constructor = function(self, argument2, boxObject)
        espHealthBarClass.constructor(self, argument2);
        self:initialize();
        self.Box = boxObject;
        return ;
    end;
    espHealthBarMetatable.initialize = function(espDrawing)
        local drawingBorder2 = Drawing.new("Square");
        drawingBorder2.Transparency = 1;
        drawingBorder2.Thickness = 4;
        drawingBorder2.Filled = false;
        espDrawing.DrawingBorder = drawingBorder2;
        local squareBorderDrawing = Drawing.new("Square");
        squareBorderDrawing.Transparency = 1;
        squareBorderDrawing.Thickness = 2;
        squareBorderDrawing.Filled = true;
        espDrawing.Drawing = squareBorderDrawing;
        return ;
    end;
    espHealthBarMetatable.getVisible = function(instance)
        local isVisible = espHealthBarClass.getVisible(instance);
        if isVisible then
            local toggleInstanceValue = instance.toggle;
            if toggleInstanceValue ~= nil then
                toggleInstanceValue = toggleInstanceValue.Instance.Value;
            end;
            local isBorderEnabled = toggleInstanceValue;
            if isBorderEnabled == nil then
                isBorderEnabled = false;
            end;
            isVisible = isBorderEnabled;
        end;
        return isVisible;
    end;
    espHealthBarMetatable.update = function(healthBarObject)
        local isVisibleHealthBar = healthBarObject:getVisible();
        local isBorderToggleEnabled = healthBarObject.borderToggle;
        if isBorderToggleEnabled ~= nil then
            isBorderToggleEnabled = isBorderToggleEnabled.Instance.Value;
        end;
        local isBorderEnabledLocal = isBorderToggleEnabled;
        if isBorderEnabledLocal == nil then
            isBorderEnabledLocal = false;
        end;
        local isBorderVisible = isBorderEnabledLocal;
        healthBarObject.Drawing.Visible = isVisibleHealthBar;
        healthBarObject.DrawingBorder.Visible = isVisibleHealthBar and isBorderVisible;
        if isVisibleHealthBar then
            local drawingBox = healthBarObject.Box.Drawing;
            local currentHealth, maxHealth = healthBarObject:getHealth();
            if isBorderVisible then
                healthBarObject.DrawingBorder.Size = Vector2.new(4, drawingBox.Size.Y);
                healthBarObject.DrawingBorder.Position = Vector2.new(drawingBox.Position.X - 9, drawingBox.Position.Y);
                local borderColor = healthBarObject.borderColorpicker;
                if borderColor ~= nil then
                    borderColor = borderColor:getColor();
                end;
                local borderColorLocal = borderColor;
                if borderColorLocal == nil then
                    borderColorLocal = Color3.new(0, 0, 0);
                end;
                healthBarObject.DrawingBorder.Color = borderColorLocal;
            end;
            local healthRatio = 1 - currentHealth / maxHealth;
            healthBarObject.Drawing.Size = Vector2.new(2, drawingBox.Size.Y * currentHealth / maxHealth);
            healthBarObject.Drawing.Position = Vector2.new(drawingBox.Position.X - 8, drawingBox.Position.Y + drawingBox.Size.Y * healthRatio);
            healthBarObject.Drawing.Color = Color3.new(0, 1, 0):Lerp(Color3.new(1, 0, 0), healthRatio);
        end;
        return ;
    end;
    espHealthBarMetatable.destroy = function(drawingData)
        drawingData.Drawing:Destroy();
        drawingData.DrawingBorder:Destroy();
        return ;
    end;
    espHealthBarMetatable.getHealth = function(dataParent)
        local characterHumanoid = dataParent.Parent.data.hum;
        return characterHumanoid.Health, characterHumanoid.MaxHealth;
    end;
    espHealthBarMetatable.setToggle = function(toggleData, toggleValue)
        toggleData.toggle = toggleValue;
        return toggleData;
    end;
    espHealthBarMetatable.setBorderToggle = function(borderToggleData, borderToggleValue)
        borderToggleData.borderToggle = borderToggleValue;
        return borderToggleData;
    end;
    espHealthBarMetatable.setBorderColorpicker = function(borderColorPickerData, borderColorPickerValue)
        borderColorPickerData.borderColorpicker = borderColorPickerValue;
        return borderColorPickerData;
    end;
    return { default = espHealthBarMetatable };
end);
registerModule("ESPHighlight", "ModuleScript", "rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components.ESPHighlight", "rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components", function()
    local espHighlightModule = getModuleGlobals("rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components.ESPHighlight");
    local currentScript = espHighlightModule.script;
    local espBaseComponentHighlight = espHighlightModule.require(currentScript.Parent.Parent.Parent.Parent.Parent.include.RuntimeLib).import(currentScript, currentScript.Parent, "ESPBaseComponent").default;
    local someValue20 = nil;
    local espHighlightClass = espBaseComponentHighlight;
    local espHighlightMetatable = setmetatableFunction({}, {
        __tostring = function()
            return "ESPHighlight";
        end,
        __index = espHighlightClass
    });
    espHighlightMetatable.__index = espHighlightMetatable;
    espHighlightMetatable.new = function(...)
        local espComponent = setmetatableFunction({}, espHighlightMetatable);
        return espComponent:constructor(...) or espComponent;
    end;
    espHighlightMetatable.constructor = function(selfHighlight, unknownParameter)
        espHighlightClass.constructor(selfHighlight, unknownParameter);
        selfHighlight:initialize();
        return ;
    end;
    espHighlightMetatable.initialize = function(characterModel)
        local espHighlight = Instance.new("Highlight");
        espHighlight.Name = "ESP_Highlight";
        espHighlight.Adornee = characterModel.Parent.char;
        espHighlight.FillTransparency = 1;
        espHighlight.OutlineTransparency = 0;
        espHighlight.Enabled = false;
        espHighlight.Parent = characterModel.Parent.char;
        characterModel.Highlight = espHighlight;
        return ;
    end;
    espHighlightMetatable.getVisible = function(espInfoTag)
        local isHighlightVisible = espHighlightClass.getVisible(espInfoTag);
        if isHighlightVisible then
            local isToggleEnabled = espInfoTag.toggle;
            if isToggleEnabled ~= nil then
                isToggleEnabled = isToggleEnabled.Instance.Value;
            end;
            local isHighlightEnabled = isToggleEnabled;
            if isHighlightEnabled == nil then
                isHighlightEnabled = false;
            end;
            isHighlightVisible = isHighlightEnabled;
        end;
        return isHighlightVisible;
    end;
    espHighlightMetatable.update = function(espComponent)
        local isVisible = espComponent:getVisible();
        espComponent.Highlight.Enabled = isVisible;
        if isVisible then
            local componentColor = espComponent.colorpicker;
            if componentColor ~= nil then
                componentColor = componentColor:getColor(espComponent);
            end;
            local highlightColor = componentColor;
            if highlightColor == nil then
                highlightColor = Color3.new(1, 1, 1);
            end;
            espComponent.Highlight.OutlineColor = highlightColor;
        end;
        return ;
    end;
    espHighlightMetatable.destroy = function(highlightData)
        highlightData.Highlight:Destroy();
        return ;
    end;
    espHighlightMetatable.setToggle = function(toggleData2, toggleValue2)
        toggleData2.toggle = toggleValue2;
        return toggleData2;
    end;
    espHighlightMetatable.setColorpicker = function(colorPickerData, colorPickerValue)
        colorPickerData.colorpicker = colorPickerValue;
        return colorPickerData;
    end;
    return { default = espHighlightMetatable };
end);
registerModule("ESPInfoTag", "ModuleScript", "rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components.ESPInfoTag", "rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components", function()
    local espInfoTagModule = getModuleGlobals("rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components.ESPInfoTag");
    local currentScript2 = espInfoTagModule.script;
    local espBaseComponent = espInfoTagModule.require(currentScript2.Parent.Parent.Parent.Parent.Parent.include.RuntimeLib).import(currentScript2, currentScript2.Parent, "ESPBaseComponent").default;
    local someValue21 = nil;
    local espBaseComponentPrototype = espBaseComponent;
    local espInfoTagClass = setmetatableFunction({}, {
        __tostring = function()
            return "ESPInfoTag";
        end,
        __index = espBaseComponentPrototype
    });
    espInfoTagClass.__index = espInfoTagClass;
    espInfoTagClass.new = function(...)
        local espComponent2 = setmetatableFunction({}, espInfoTagClass);
        return espComponent2:constructor(...) or espComponent2;
    end;
    espInfoTagClass.constructor = function(self, unknownParameter2, boxObject)
        espBaseComponentPrototype.constructor(self, unknownParameter2);
        self.subComponents = {};
        self:initialize();
        self.Box = boxObject;
        return ;
    end;
    espInfoTagClass.initialize = function(drawingData)
        local nameTextDrawing = Drawing.new("Text");
        nameTextDrawing.Center = true;
        nameTextDrawing.Size = 12;
        drawingData.Drawing = nameTextDrawing;
        return ;
    end;
    espInfoTagClass.getVisible = function(espInfoTagInstance)
        local isComponentVisible = espBaseComponentPrototype.getVisible(espInfoTagInstance);
        if isComponentVisible then
            local subComponents = espInfoTagInstance.subComponents;
            local unknownBoolean = false;
            local isSubComponentToggleEnabled = function(toggleData3)
                local subComponentToggleValue = toggleData3.toggle;
                if subComponentToggleValue ~= nil then
                    subComponentToggleValue = subComponentToggleValue.Instance.Value;
                end;
                local unknownBoolean = subComponentToggleValue;
                if unknownBoolean == nil then
                    unknownBoolean = false;
                end;
                return unknownBoolean;
            end;
            for subComponentIndex, subComponent in subComponents, nil, nil do
                if isSubComponentToggleEnabled(subComponent, subComponentIndex - 1, subComponents) then
                    unknownBoolean = true;
                    break;
                end;
            end;
            isComponentVisible = unknownBoolean;
        end;
        return isComponentVisible;
    end;
    espInfoTagClass.update = function(espDrawing)
        local isVisible = espDrawing:getVisible();
        local isBorderToggleEnabled2 = espDrawing.borderToggle;
        if isBorderToggleEnabled2 ~= nil then
            isBorderToggleEnabled2 = isBorderToggleEnabled2.Instance.Value;
        end;
        local isBorderEnabledLocal2 = isBorderToggleEnabled2;
        if isBorderEnabledLocal2 == nil then
            isBorderEnabledLocal2 = false;
        end;
        local isOutlineEnabled = isBorderEnabledLocal2;
        espDrawing.Drawing.Visible = isVisible;
        if isVisible then
            local screenPosition = espDrawing.Parent.data.screenPosition;
            local subComponents = espDrawing.subComponents;
            local visibleSubComponents = {};
            local isSubComponentToggleEnabled = function(toggleData4)
                local subComponentToggleValue = toggleData4.toggle;
                if subComponentToggleValue ~= nil then
                    subComponentToggleValue = subComponentToggleValue.Instance.Value;
                end;
                local unknownBoolean = subComponentToggleValue;
                if unknownBoolean == nil then
                    unknownBoolean = false;
                end;
                return unknownBoolean;
            end;
            local index = 0;
            for subComponentIndex, subComponent in subComponents, nil, nil do
                if isSubComponentToggleEnabled(subComponent, subComponentIndex - 1, subComponents) == true then
                    index = index + 1;
                    visibleSubComponents[index] = subComponent;
                end;
            end;
            local textValues = table.create(#visibleSubComponents);
            local getComponentValue = function(unknownValue)
                return unknownValue:getValue(espDrawing);
            end;
            for textValueIndex, value in visibleSubComponents, nil, nil do
                textValues[textValueIndex] = getComponentValue(value, textValueIndex - 1, visibleSubComponents);
            end;
            espDrawing.Drawing.Text = table.concat(textValues, " ");
            espDrawing.Drawing.Position = Vector2.new(screenPosition.X, espDrawing.Box.Drawing.Position.Y + espDrawing.Box.Drawing.Size.Y);
            local textColor = espDrawing.colorpicker;
            if textColor ~= nil then
                textColor = textColor:getColor(espDrawing);
            end;
            local textColorLocal = textColor;
            if textColorLocal == nil then
                textColorLocal = Color3.new(1, 1, 1);
            end;
            espDrawing.Drawing.Color = textColorLocal;
            espDrawing.Drawing.Outline = isOutlineEnabled;
            local outlineColor = espDrawing.borderColorpicker;
            if outlineColor ~= nil then
                outlineColor = outlineColor:getColor();
            end;
            local outlineColorLocal = outlineColor;
            if outlineColorLocal == nil then
                outlineColorLocal = Color3.new(0, 0, 0);
            end;
            espDrawing.Drawing.OutlineColor = outlineColorLocal;
        end;
        return ;
    end;
    espInfoTagClass.destroy = function(drawingData)
        drawingData.Drawing:Destroy();
        return ;
    end;
    espInfoTagClass.addSubComponent = function(componentData, itemToInsert)
        local subComponents = componentData.subComponents;
        table.insert(subComponents, itemToInsert);
        return componentData;
    end;
    espInfoTagClass.setBorderToggle = function(borderToggleData2, borderToggleValue2)
        borderToggleData2.borderToggle = borderToggleValue2;
        return borderToggleData2;
    end;
    espInfoTagClass.setColorpicker = function(colorPickerData2, colorPickerValue2)
        colorPickerData2.colorpicker = colorPickerValue2;
        return colorPickerData2;
    end;
    espInfoTagClass.setBorderColorpicker = function(borderColorPickerData2, borderColorPickerValue2)
        borderColorPickerData2.borderColorpicker = borderColorPickerValue2;
        return borderColorPickerData2;
    end;
    return { default = espInfoTagClass };
end);
registerModule("ESPNameTag", "ModuleScript", "rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components.ESPNameTag", "rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components", function()
    local espNameTagModule = getModuleGlobals("rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components.ESPNameTag");
    local currentScript3 = espNameTagModule.script;
    local espBaseComponent = espNameTagModule.require(currentScript3.Parent.Parent.Parent.Parent.Parent.include.RuntimeLib).import(currentScript3, currentScript3.Parent, "ESPBaseComponent").default;
    local someValue22 = nil;
    local espBaseComponentClass = espBaseComponent;
    local espNameTagClass = setmetatableFunction({}, {
        __tostring = function()
            return "ESPNameTag";
        end,
        __index = espBaseComponentClass
    });
    espNameTagClass.__index = espNameTagClass;
    espNameTagClass.new = function(...)
        local espComponent3 = setmetatableFunction({}, espNameTagClass);
        return espComponent3:constructor(...) or espComponent3;
    end;
    espNameTagClass.constructor = function(self, unknownParameter3, boxObject)
        espBaseComponentClass.constructor(self, unknownParameter3);
        self:initialize();
        self.Box = boxObject;
        return ;
    end;
    espNameTagClass.initialize = function(instanceToDraw)
        local nameTextDrawing2 = Drawing.new("Text");
        nameTextDrawing2.Text = instanceToDraw:getName();
        nameTextDrawing2.Center = true;
        nameTextDrawing2.Size = 16;
        instanceToDraw.Drawing = nameTextDrawing2;
        return ;
    end;
    espNameTagClass.getName = function(playerNameData)
        return playerNameData.Parent.plr.Name;
    end;
    espNameTagClass.getVisible = function(data)
        local isVisible = espBaseComponentClass.getVisible(data);
        if isVisible then
            local toggleValue = data.toggle;
            if toggleValue ~= nil then
                toggleValue = toggleValue.Instance.Value;
            end;
            local isHighlightEnabled2 = toggleValue;
            if isHighlightEnabled2 == nil then
                isHighlightEnabled2 = false;
            end;
            isVisible = isHighlightEnabled2;
        end;
        return isVisible;
    end;
    espNameTagClass.update = function(nameTag)
        local isNameTagVisible = nameTag:getVisible();
        local isBorderToggleEnabled3 = nameTag.borderToggle;
        if isBorderToggleEnabled3 ~= nil then
            isBorderToggleEnabled3 = isBorderToggleEnabled3.Instance.Value;
        end;
        local isBorderEnabledLocal3 = isBorderToggleEnabled3;
        if isBorderEnabledLocal3 == nil then
            isBorderEnabledLocal3 = false;
        end;
        local isOutlineEnabled2 = isBorderEnabledLocal3;
        nameTag.Drawing.Visible = isNameTagVisible;
        if isNameTagVisible then
            local screenPosition2 = nameTag.Parent.data.screenPosition;
            nameTag.Drawing.Position = Vector2.new(screenPosition2.X, nameTag.Box.Drawing.Position.Y);
            local drawingPosition = nameTag.Drawing.Position;
            local textBoundsOffset = Vector2.new(0, nameTag.Drawing.TextBounds.Y);
            nameTag.Drawing.Position = drawingPosition - textBoundsOffset;
            local textColor2 = nameTag.colorpicker;
            if textColor2 ~= nil then
                textColor2 = textColor2:getColor(nameTag);
            end;
            local defaultColor = textColor2;
            if defaultColor == nil then
                defaultColor = Color3.new(1, 1, 1);
            end;
            nameTag.Drawing.Color = defaultColor;
            nameTag.Drawing.Outline = isOutlineEnabled2;
            local borderColor = nameTag.borderColorpicker;
            if borderColor ~= nil then
                borderColor = borderColor:getColor();
            end;
            local outlineColor = borderColor;
            if outlineColor == nil then
                outlineColor = Color3.new(0, 0, 0);
            end;
            nameTag.Drawing.OutlineColor = outlineColor;
        end;
        return ;
    end;
    espNameTagClass.destroy = function(drawingData)
        drawingData.Drawing:Destroy();
        return ;
    end;
    espNameTagClass.setToggle = function(toggleData, toggleState)
        toggleData.toggle = toggleState;
        return toggleData;
    end;
    espNameTagClass.setBorderToggle = function(borderToggleData, borderToggleState)
        borderToggleData.borderToggle = borderToggleState;
        return borderToggleData;
    end;
    espNameTagClass.setColorpicker = function(colorPickerData, colorPickerInstance)
        colorPickerData.colorpicker = colorPickerInstance;
        return colorPickerData;
    end;
    espNameTagClass.setBorderColorpicker = function(borderColorPickerData, borderColorPickerInstance)
        borderColorPickerData.borderColorpicker = borderColorPickerInstance;
        return borderColorPickerData;
    end;
    return { default = espNameTagClass };
end);
registerModule("ESPTracer", "ModuleScript", "rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components.ESPTracer", "rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components", function()
    local espTracerModule = getModuleGlobals("rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components.ESPTracer");
    local espTracerScript = espTracerModule.script;
    local runtimeLibRequire = espTracerModule.require(espTracerScript.Parent.Parent.Parent.Parent.Parent.include.RuntimeLib);
    local espBaseComponent = runtimeLibRequire.import(espTracerScript, espTracerScript.Parent, "ESPBaseComponent").default;
    local camera = runtimeLibRequire.import(espTracerScript, espTracerScript.Parent.Parent.Parent, "ESPUtils").camera;
    local someValue23 = nil;
    local espTracerClass = espBaseComponent;
    local espTracer = setmetatableFunction({}, {
        __tostring = function()
            return "ESPTracer";
        end,
        __index = espTracerClass
    });
    espTracer.__index = espTracer;
    espTracer.new = function(...)
        local newObject = setmetatableFunction({}, espTracer);
        return newObject:constructor(...) or newObject;
    end;
    espTracer.constructor = function(self, constructorArgument)
        espTracerClass.constructor(self, constructorArgument);
        self:initialize();
        return ;
    end;
    espTracer.initialize = function(drawingContainer)
        local drawingLine = Drawing.new("Line");
        drawingLine.Thickness = 3;
        drawingContainer.DrawingBorder = drawingLine;
        local lineDrawing = Drawing.new("Line");
        lineDrawing.Visible = true;
        lineDrawing.Thickness = 1;
        drawingContainer.Drawing = lineDrawing;
        return ;
    end;
    espTracer.getVisible = function(data)
        local isVisible = espTracerClass.getVisible(data);
        if isVisible then
            local toggleValue = data.toggle;
            if toggleValue ~= nil then
                toggleValue = toggleValue.Instance.Value;
            end;
            local isToggled = toggleValue;
            if isToggled == nil then
                isToggled = false;
            end;
            isVisible = isToggled;
        end;
        return isVisible;
    end;
    espTracer.update = function(tracer)
        local isTracerVisible = tracer:getVisible();
        local borderToggleValue = tracer.borderToggle;
        if borderToggleValue ~= nil then
            borderToggleValue = borderToggleValue.Instance.Value;
        end;
        local isBorderEnabled = borderToggleValue;
        if isBorderEnabled == nil then
            isBorderEnabled = false;
        end;
        local isBorderEnabled = isBorderEnabled;
        tracer.Drawing.Visible = isTracerVisible;
        tracer.DrawingBorder.Visible = isTracerVisible and isBorderEnabled;
        if isTracerVisible then
            local screenPosition = tracer.Parent.data.screenPosition;
            local distanceFromTarget = tracer.Parent.data.distance;
            local viewportCenter = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y);
            local drawingVector = Vector2.new(screenPosition.X, screenPosition.Y);
            tracer.Drawing.From = viewportCenter;
            tracer.Drawing.To = drawingVector;
            tracer.Drawing.Transparency = math.clamp(1 - distanceFromTarget / 200, 0.25, 0.75);
            local drawingColor = tracer.colorpicker;
            if drawingColor ~= nil then
                drawingColor = drawingColor:getColor(tracer);
            end;
            local defaultDrawingColor = drawingColor;
            if defaultDrawingColor == nil then
                defaultDrawingColor = Color3.new(1, 1, 1);
            end;
            tracer.Drawing.Color = defaultDrawingColor;
            if isBorderEnabled then
                tracer.DrawingBorder.From = viewportCenter;
                tracer.DrawingBorder.To = drawingVector;
                tracer.DrawingBorder.Transparency = tracer.Drawing.Transparency - 0.15;
                local borderDrawingColor = tracer.borderColorpicker;
                if borderDrawingColor ~= nil then
                    borderDrawingColor = borderDrawingColor:getColor();
                end;
                local defaultBorderDrawingColor = borderDrawingColor;
                if defaultBorderDrawingColor == nil then
                    defaultBorderDrawingColor = Color3.new(0, 0, 0);
                end;
                tracer.DrawingBorder.Color = defaultBorderDrawingColor;
            end;
        end;
        return ;
    end;
    espTracer.destroy = function(drawingData)
        drawingData.Drawing:Destroy();
        drawingData.DrawingBorder:Destroy();
        return ;
    end;
    espTracer.setToggle = function(toggleData2, toggleState2)
        toggleData2.toggle = toggleState2;
        return toggleData2;
    end;
    espTracer.setBorderToggle = function(borderToggleData2, borderToggleState2)
        borderToggleData2.borderToggle = borderToggleState2;
        return borderToggleData2;
    end;
    espTracer.setColorpicker = function(colorPickerData2, colorPickerInstance2)
        colorPickerData2.colorpicker = colorPickerInstance2;
        return colorPickerData2;
    end;
    espTracer.setBorderColorpicker = function(borderColorPickerData2, borderColorPickerInstance2)
        borderColorPickerData2.borderColorpicker = borderColorPickerInstance2;
        return borderColorPickerData2;
    end;
    return { default = espTracer };
end);
createInstance("InfoTag", "Folder", "rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components.InfoTag", "rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components");
registerModule("ESPInfoTag_Distance", "ModuleScript", "rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components.InfoTag.ESPInfoTag_Distance", "rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components.InfoTag", function()
    local espInfoTagDistanceModule = getModuleGlobals("rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components.InfoTag.ESPInfoTag_Distance");
    local scriptModule = espInfoTagDistanceModule.script;
    local requireFunction = espInfoTagDistanceModule.require;
    local someValue24 = nil;
    local espInfoTagDistance = setmetatableFunction({}, {
        __tostring = function()
            return "ESPInfoTag_Distance";
        end
    });
    espInfoTagDistance.__index = espInfoTagDistance;
    espInfoTagDistance.new = function(...)
        local newObject2 = setmetatableFunction({}, espInfoTagDistance);
        return newObject2:constructor(...) or newObject2;
    end;
    espInfoTagDistance.constructor = function(L_2306)
        return ;
    end;
    espInfoTagDistance.getValue = function(L_2307, parentObject)
        local distanceValue = parentObject.Parent.data.distance;
        return tostring(math.floor(distanceValue * 0.28)) .. "m";
    end;
    espInfoTagDistance.setToggle = function(toggleData3, toggleState3)
        toggleData3.toggle = toggleState3;
        return toggleData3;
    end;
    return { default = espInfoTagDistance };
end);
registerModule("ESPInfoTag_Health", "ModuleScript", "rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components.InfoTag.ESPInfoTag_Health", "rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components.InfoTag", function()
    local espInfoTagHealthModule = getModuleGlobals("rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components.InfoTag.ESPInfoTag_Health");
    local scriptModule = espInfoTagHealthModule.script;
    local requireFunction = espInfoTagHealthModule.require;
    local unknownValue1 = nil;
    local espInfoTagHealth = setmetatableFunction({}, {
        __tostring = function()
            return "ESPInfoTag_Health";
        end
    });
    espInfoTagHealth.__index = espInfoTagHealth;
    espInfoTagHealth.new = function(...)
        local newObject3 = setmetatableFunction({}, espInfoTagHealth);
        return newObject3:constructor(...) or newObject3;
    end;
    espInfoTagHealth.constructor = function(L_2318)
        return ;
    end;
    espInfoTagHealth.getValue = function(L_2319, parentObject2)
        local humanoid = parentObject2.Parent.data.hum;
        local currentHealth = humanoid.Health;
        local maxHealth = humanoid.MaxHealth;
        return ("[%*/%*]"):format(math.floor(currentHealth), math.floor(maxHealth));
    end;
    espInfoTagHealth.setToggle = function(toggleData4, toggleState4)
        toggleData4.toggle = toggleState4;
        return toggleData4;
    end;
    return { default = espInfoTagHealth };
end);
registerModule("IESPInfoTag", "ModuleScript", "rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components.InfoTag.IESPInfoTag", "rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components.InfoTag", function()
    local espInfoTagModule = getModuleGlobals("rbxts-bundle-example.LKHUB.ESP.PlayerESP.Components.InfoTag.IESPInfoTag");
    local scriptModule = espInfoTagModule.script;
    local requireFunction = espInfoTagModule.require;
    return nil;
end);
registerModule("ESPColorpickerWithTeam", "ModuleScript", "rbxts-bundle-example.LKHUB.ESP.PlayerESP.ESPColorpickerWithTeam", "rbxts-bundle-example.LKHUB.ESP.PlayerESP", function()
    local espColorpickerWithTeamModule = getModuleGlobals("rbxts-bundle-example.LKHUB.ESP.PlayerESP.ESPColorpickerWithTeam");
    local scriptReference = espColorpickerWithTeamModule.script;
    local ESPColorpicker = espColorpickerWithTeamModule.require(scriptReference.Parent.Parent.Parent.Parent.include.RuntimeLib).import(scriptReference, scriptReference.Parent.Parent, "ESPColorpicker").default;
    local unknownValue2 = nil;
    local ESPColorpickerWithTeamClass = ESPColorpicker;
    local ESPColorpickerWithTeamMetatable = setmetatableFunction({}, {
        __tostring = function()
            return "ESPColorpickerWithTeam";
        end,
        __index = ESPColorpickerWithTeamClass
    });
    ESPColorpickerWithTeamMetatable.__index = ESPColorpickerWithTeamMetatable;
    ESPColorpickerWithTeamMetatable.new = function(...)
        local newObject4 = setmetatableFunction({}, ESPColorpickerWithTeamMetatable);
        return newObject4:constructor(...) or newObject4;
    end;
    ESPColorpickerWithTeamMetatable.constructor = function(self, constructorArgument2, teamColorToggleValue)
        ESPColorpickerWithTeamClass.constructor(self, constructorArgument2);
        self.teamColorToggle = teamColorToggleValue;
        return ;
    end;
    ESPColorpickerWithTeamMetatable.getColor = function(self, objectReference)
        local useTeamColor = objectReference;
        if useTeamColor then
            local teamColorToggleValue = self.teamColorToggle;
            if teamColorToggleValue ~= nil then
                teamColorToggleValue = teamColorToggleValue.Instance.Value;
            end;
            useTeamColor = teamColorToggleValue;
        end;
        if useTeamColor then
            return objectReference.Parent:getPlayerTeamColor(objectReference.Parent.plr);
        end;
        return ESPColorpickerWithTeamClass.getColor(self);
    end;
    return { default = ESPColorpickerWithTeamMetatable };
end);
registerModule("ESPInstance", "ModuleScript", "rbxts-bundle-example.LKHUB.ESP.PlayerESP.ESPInstance", "rbxts-bundle-example.LKHUB.ESP.PlayerESP", function()
    local espInstanceModule = getModuleGlobals("rbxts-bundle-example.LKHUB.ESP.PlayerESP.ESPInstance");
    local espInstanceScript = espInstanceModule.script;
    local runtimeLib = espInstanceModule.require(espInstanceScript.Parent.Parent.Parent.Parent.include.RuntimeLib);
    local playersService = runtimeLib.import(espInstanceScript, espInstanceScript.Parent.Parent.Parent, "Services").Players;
    local espUtils = runtimeLib.import(espInstanceScript, espInstanceScript.Parent.Parent, "ESPUtils");
    local espUtilsDefault = espUtils.default;
    local camera = espUtils.camera;
    local localPlayer = playersService.LocalPlayer;
    local unknownValue3 = nil;
    local ESPInstanceMetatable = setmetatableFunction({}, {
        __tostring = function()
            return "ESPInstance";
        end
    });
    ESPInstanceMetatable.__index = ESPInstanceMetatable;
    ESPInstanceMetatable.new = function(...)
        local newObject5 = setmetatableFunction({}, ESPInstanceMetatable);
        return newObject5:constructor(...) or newObject5;
    end;
    ESPInstanceMetatable.constructor = function(self, manager, characterModel, player)
        self.components = {};
        self.data = {};
        self.char = characterModel;
        self.plr = player;
        self.manager = manager;
        self.ancestryConnection = characterModel.AncestryChanged:Connect(function(L_2358, ancestryChangeArgument)
            if ancestryChangeArgument == nil then
                self:destroy();
            end;
            return ;
        end);
        return ;
    end;
    ESPInstanceMetatable.addComponent = function(objectReference2, itemToInsert)
        local components = objectReference2.components;
        table.insert(components, itemToInsert);
        return itemToInsert;
    end;
    ESPInstanceMetatable.update = function(self)
        local humanoidReference = self.char:FindFirstChildOfClass("Humanoid");
        local humanoidRootPart = self.char:FindFirstChild("HumanoidRootPart") or self.char.PrimaryPart;
        self.data.hum = humanoidReference;
        self.data.humRP = humanoidRootPart;
        local screenX, isOnScreen = camera:WorldToViewportPoint(humanoidRootPart.Position);
        local distance = (camera.CFrame.Position - humanoidRootPart.Position).Magnitude;
        self.data.distance = distance;
        local ignoreTeammates = isOnScreen;
        if ignoreTeammates then
            local ignoreTeammatesToggleValue = self.ignoreTeammatesToggle;
            if ignoreTeammatesToggleValue ~= nil then
                ignoreTeammatesToggleValue = ignoreTeammatesToggleValue.Instance.Value;
            end;
            ignoreTeammates = ignoreTeammatesToggleValue;
            if ignoreTeammates then
                ignoreTeammates = self:checkTeam();
            end;
        end;
        if ignoreTeammates then
            isOnScreen = false;
        end;
        local visibilityCheck = isOnScreen;
        if visibilityCheck then
            local visibilityCheckToggleValue = self.visibilityCheckToggle;
            if visibilityCheckToggleValue ~= nil then
                visibilityCheckToggleValue = visibilityCheckToggleValue.Instance.Value;
            end;
            visibilityCheck = visibilityCheckToggleValue;
        end;
        if visibilityCheck then
            isOnScreen = self:checkVisibility();
        end;
        self.data.screenPosition = screenX;
        self.data.onScreen = isOnScreen;
        self:updateComponents();
        return ;
    end;
    ESPInstanceMetatable.destroy = function(componentContainer)
        local componentsList = componentContainer.components;
        local destroyComponent = function(objectToDestroy)
            return objectToDestroy:destroy();
        end;
        for index, component in componentsList, nil, nil do
            destroyComponent(component, index - 1, componentsList);
        end;
        table.clear(componentContainer.components);
        componentContainer.ancestryConnection:Disconnect();
        return ;
    end;
    ESPInstanceMetatable.updateComponents = function(objectReference3)
        local componentsList = objectReference3.components;
        local updateComponent = function(updateFunction)
            return updateFunction:update();
        end;
        for index, component in componentsList, nil, nil do
            updateComponent(component, index - 1, componentsList);
        end;
        return ;
    end;
    ESPInstanceMetatable.getPlayerTeamColor = function(L_2385, teamColor)
        return teamColor.TeamColor.Color;
    end;
    ESPInstanceMetatable.checkTeam = function(objectReference4)
        return not (objectReference4.plr.Neutral and localPlayer.Neutral) and objectReference4:getPlayerTeamColor(objectReference4.plr) == objectReference4:getPlayerTeamColor(localPlayer);
    end;
    ESPInstanceMetatable.checkVisibility = function(raycastData)
        local headPart = raycastData.char:FindFirstChild("Head");
        local raycastHit = headPart;
        if raycastHit then
            local characterModel = raycastData.char;
            local raycastDistance = raycastData.data.distance;
            local originPosition = camera.CFrame.Position;
            local targetPosition = headPart.Position;
            local sourcePosition = camera.CFrame.Position;
            raycastHit = espUtilsDefault:CheckRay(characterModel, raycastDistance, originPosition, (targetPosition - sourcePosition).Unit);
        end;
        return raycastHit;
    end;
    ESPInstanceMetatable.setIgnoreTeammatesToggle = function(ignoreTeammatesData, ignoreTeammatesState)
        ignoreTeammatesData.ignoreTeammatesToggle = ignoreTeammatesState;
        return ignoreTeammatesData;
    end;
    ESPInstanceMetatable.setVisibilityCheckToggle = function(visibilityCheckData, visibilityCheckEnabled)
        visibilityCheckData.visibilityCheckToggle = visibilityCheckEnabled;
        return visibilityCheckData;
    end;
    return { default = ESPInstanceMetatable };
end);
registerModule("ESPManager", "ModuleScript", "rbxts-bundle-example.LKHUB.ESP.PlayerESP.ESPManager", "rbxts-bundle-example.LKHUB.ESP.PlayerESP", function()
    local espManagerModule = getModuleGlobals("rbxts-bundle-example.LKHUB.ESP.PlayerESP.ESPManager");
    local espManagerScript = espManagerModule.script;
    local runtimeLibRequire = espManagerModule.require(espManagerScript.Parent.Parent.Parent.Parent.include.RuntimeLib);
    local libraryImport = runtimeLibRequire.import(espManagerScript, espManagerScript.Parent.Parent.Parent, "Library", "Library");
    local mainModule = runtimeLibRequire.import(espManagerScript, espManagerScript.Parent.Parent.Parent, "Main").default;
    local servicesModule = runtimeLibRequire.import(espManagerScript, espManagerScript.Parent.Parent.Parent, "Services");
    local runService = servicesModule.RunService;
    local playersService = servicesModule.Players;
    local espInstanceClass = runtimeLibRequire.import(espManagerScript, espManagerScript.Parent, "ESPInstance").default;
    local unknownValue4 = nil;
    local espManager = setmetatableFunction({}, {
        __tostring = function()
            return "ESPManager";
        end
    });
    espManager.__index = espManager;
    espManager.new = function(...)
        local espInstance = setmetatableFunction({}, espManager);
        return espInstance:constructor(...) or espInstance;
    end;
    espManager.constructor = function(self, espEnabled)
        self.ESPToggle = espEnabled;
        self.playerESPs = {};
        self.ESPInstanceClass = espInstanceClass;
        self:initialize();
        return ;
    end;
    espManager.initialize = function(espInstance)
        mainModule:Clean(function()
            return espInstance:cleanup();
        end);
        mainModule:Clean(runService.RenderStepped:Connect(function()
            return espInstance:update();
        end));
        return ;
    end;
    espManager.initComponents = function(espModule, createComponents)
        espModule.createComponentsFunc = createComponents;
        return ;
    end;
    espManager.getESP = function(self, player, espInstanceProperties)
        if self.playerESPs[player] ~= nil then
            return self.playerESPs[player];
        end;
        local playerEspInstance = self.ESPInstanceClass.new(self, player, espInstanceProperties);
        self.createComponentsFunc(playerEspInstance);
        self.playerESPs[player] = playerEspInstance;
        return playerEspInstance;
    end;
    espManager.getCharacter = function(L_2421, characterModel)
        return characterModel.Character;
    end;
    espManager.isEnabled = function(espToggleValue)
        return espToggleValue.ESPToggle.Instance.Value;
    end;
    espManager.update = function(espHandler)
        if not libraryImport.IsRunning() then
            espHandler:cleanup();
            return nil;
        end;
        if not espHandler:isEnabled() then
            espHandler:cleanup();
            return nil;
        end;
        local playerList = playersService:GetPlayers();
        local updateEspForPlayer = function(player)
            if player == playersService.LocalPlayer then
                return nil;
            end;
            local character = espHandler:getCharacter(player);
            if not character then
                return nil;
            end;
            local espInstance = espHandler:getESP(character, player);
            if character.PrimaryPart ~= nil then
                espInstance:update();
            end;
            return ;
        end;
        for playerIndex, playerInstance in playerList, nil, nil do
            updateEspForPlayer(playerInstance, playerIndex - 1, playerList);
        end;
        return ;
    end;
    espManager.cleanup = function(espHandler)
        local playerEsps = espHandler.playerESPs;
        local destroyEsp = function(destroyableObject)
            return destroyableObject:destroy();
        end;
        for espIndex, espInstance in playerEsps, nil, nil do
            destroyEsp(espInstance, espIndex, playerEsps);
        end;
        table.clear(espHandler.playerESPs);
        return ;
    end;
    return { default = espManager };
end);
createInstance("Library", "Folder", "rbxts-bundle-example.LKHUB.Library", "rbxts-bundle-example.LKHUB");
registerModule("Library", "ModuleScript", "rbxts-bundle-example.LKHUB.Library.Library", "rbxts-bundle-example.LKHUB.Library", function()
    local libraryModule = getModuleGlobals("rbxts-bundle-example.LKHUB.Library.Library");
    local scriptReference = libraryModule.script;
    local requireFunction = libraryModule.require;
    local cloneReference = cloneref or function(unknownValue)
        return unknownValue;
    end;
    local userInputServiceWrapper = cloneReference(game:GetService("UserInputService"));
    local tweenServiceWrapper = cloneReference(game:GetService("TweenService"));
    local runServiceWrapper = cloneReference(game:GetService("RunService"));
    local localPlayer = cloneReference(game:GetService("Players")).LocalPlayer;
    local coreGuiServiceWrapper = cloneReference(game:GetService("CoreGui"));
    local mouse = localPlayer:GetMouse();
    local connectionManager = { Connections = {}, Destroyed = false };
    local connectEvent = function(event, eventHandler)
        local eventConnection = event:Connect(eventHandler);
        connectionManager.Clean(eventConnection);
        return eventConnection;
    end;
    connectionManager.Clean = function(connectionOrInstance)
        if not connectionManager.IsRunning() then
            return ;
        end;
        if typeofFunction(connectionOrInstance) == "Instance" then
            table.insert(connectionManager.Connections, {
                Disconnect = function()
                    connectionOrInstance:ClearAllChildren();
                    connectionOrInstance:Destroy();
                    return ;
                end
            });
        elseif type(connectionOrInstance) == "function" then
            table.insert(connectionManager.Connections, { Disconnect = connectionOrInstance });
        else
            table.insert(connectionManager.Connections, connectionOrInstance);
        end;
        return ;
    end;
    pcall(function()
        if shared.NapkinLibrary then
            shared.NapkinLibrary.Uninject();
        end;
        return ;
    end);
    local createInstance = function(instanceClassName, propertiesTable, childrenTable)
        local instance = Instance.new(instanceClassName);
        for propertyName, propertyValue in next, propertiesTable or {}, nil do
            instance[propertyName] = propertyValue;
        end;
        for propertyKey, child in next, childrenTable or {}, nil do
            child.Parent = instance;
        end;
        return instance;
    end;
    local roundToIncrement = function(value, increment)
        if increment == 0 then
            return value;
        end;
        local roundedValue = math.floor(value / increment + 0.5) * increment;
        local roundingFactor = 10 ^ math.max(0, -math.floor(math.log10(increment)));
        return math.floor(roundedValue * roundingFactor + 0.5) / roundingFactor;
    end;
    local makeDraggable = function(draggableObject, uiElement)
        pcall(function()
            local isDragging = false;
            local dragStartMousePosition = nil;
            local dragStartObjectPosition = nil;
            local updateDrag = function(element)
                if isDragging and (dragStartMousePosition and dragStartObjectPosition) then
                    local positionDifference = element.Position - dragStartMousePosition;
                    uiElement.Position = UDim2.new(dragStartObjectPosition.X.Scale, dragStartObjectPosition.X.Offset + positionDifference.X, dragStartObjectPosition.Y.Scale, dragStartObjectPosition.Y.Offset + positionDifference.Y);
                end;
                return ;
            end;
            connectEvent(draggableObject.InputBegan, function(inputObjectBegan)
                if inputObjectBegan.UserInputType == Enum.UserInputType.MouseButton1 or inputObjectBegan.UserInputType == Enum.UserInputType.Touch then
                    isDragging = true;
                    dragStartMousePosition = inputObjectBegan.Position;
                    dragStartObjectPosition = uiElement.Position;
                end;
                return ;
            end);
            connectEvent(draggableObject.InputChanged, function(inputObjectChanged)
                if inputObjectChanged.UserInputType == Enum.UserInputType.MouseMovement or inputObjectChanged.UserInputType == Enum.UserInputType.Touch then
                    updateDrag(inputObjectChanged);
                end;
                return ;
            end);
            connectEvent(userInputServiceWrapper.InputChanged, function(callbackArgument)
                updateDrag(callbackArgument);
                return ;
            end);
            connectEvent(userInputServiceWrapper.InputEnded, function(inputObjectEnded)
                if inputObjectEnded.UserInputType == Enum.UserInputType.MouseButton1 or inputObjectEnded.UserInputType == Enum.UserInputType.Touch then
                    isDragging = false;
                    dragStartMousePosition = nil;
                    dragStartObjectPosition = nil;
                end;
                return ;
            end);
            return ;
        end);
        return ;
    end;
    local ignoredKeys = { Enum.KeyCode.Unknown, Enum.KeyCode.W, Enum.KeyCode.A, Enum.KeyCode.S, Enum.KeyCode.D, Enum.KeyCode.Up, Enum.KeyCode.Left, Enum.KeyCode.Down, Enum.KeyCode.Right, Enum.KeyCode.Slash, Enum.KeyCode.Tab, Enum.KeyCode.Backspace, Enum.KeyCode.Escape };
    local createDraggableIcon = function(parentFrame)
        local draggableIcon = createInstance("ImageLabel", { Parent = parentFrame, BackgroundColor3 = Color3.fromRGB(255, 255, 255), BackgroundTransparency = 1, Image = "rbxassetid://266543268", ImageColor3 = Color3.fromRGB(210, 210, 210), ImageTransparency = 0.88 });
        draggableIcon.Position = UDim2.new(0, mouse.X - draggableIcon.AbsolutePosition.X, 0, mouse.Y - draggableIcon.AbsolutePosition.Y);
        local scaledSize = parentFrame.AbsoluteSize.X / 1.5;
        tweenServiceWrapper:Create(draggableIcon, TweenInfo.new(0.5), { Position = UDim2.fromScale(math.clamp(mouse.X - parentFrame.AbsolutePosition.X, 0, parentFrame.AbsoluteSize.X) / parentFrame.AbsoluteSize.X, parentFrame, math.clamp(mouse.Y - parentFrame.AbsolutePosition.Y, 0, parentFrame.AbsoluteSize.Y) / parentFrame.AbsoluteSize.Y) - UDim2.fromOffset(scaledSize / 2, scaledSize / 2), ImageTransparency = 1, Size = UDim2.fromOffset(scaledSize, scaledSize) }):Play();
        spawn(function()
            wait(0.5);
            draggableIcon:Destroy();
            return ;
        end);
        return ;
    end;
    local screenGui = createInstance("ScreenGui", { Parent = coreGuiServiceWrapper, ZIndexBehavior = Enum.ZIndexBehavior.Sibling });
    connectionManager.GUI = screenGui;
    shared.NapkinLibrary = connectionManager;
    connectionManager.IsRunning = function()
        return shared.NapkinLibrary and shared.NapkinLibrary == connectionManager and not connectionManager.Destroyed;
    end;
    connectionManager.Uninject = function()
        for connectionIndex, connection in connectionManager.Connections, nil, nil do
            pcall(function()
                connection:Disconnect();
                return ;
            end);
        end;
        if screenGui then
            screenGui:Destroy();
        end;
        connectionManager.Destroyed = true;
        shared.NapkinLibrary = nil;
        connectionManager = nil;
        return ;
    end;
    local notificationHolderFrame = nil;
    connectionManager.Notification = function(notificationData)
        notificationData.Title = notificationData.Title or "Notification";
        notificationData.Content = notificationData.Content or "Content";
        notificationData.Delay = notificationData.Delay or 5;
        if not notificationHolderFrame then
            notificationHolderFrame = createInstance("Frame", { Position = UDim2.new(1, -15, 1, -15), Size = UDim2.new(0, 230, 1, -15), AnchorPoint = Vector2.new(1, 1), BackgroundTransparency = 1, Parent = screenGui, Name = "NotificationHolder" }, { createInstance("UIListLayout", { HorizontalAlignment = Enum.HorizontalAlignment.Center, SortOrder = Enum.SortOrder.LayoutOrder, VerticalAlignment = Enum.VerticalAlignment.Bottom }) });
        end;
        local notificationButton = createInstance("TextButton", { Size = UDim2.new(1, 0, 0, 0), BackgroundTransparency = 1, Text = "", Parent = notificationHolderFrame, ZIndex = 1001 });
        local notificationSeparatorFrame = createInstance("Frame", { Parent = notificationButton, Size = UDim2.new(1, -24, 0, 3), Position = UDim2.new(0, 12, 1, -12), BackgroundColor3 = Color3.fromRGB(37, 37, 37), BorderSizePixel = 0, ZIndex = 1002 }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 3) }) });
        local notificationContentFrame = createInstance("Frame", { Parent = notificationButton, Size = UDim2.new(1, 0, 0, 0), Position = UDim2.new(1, 15, 0, 5), BackgroundColor3 = Color3.fromRGB(27, 27, 27), ZIndex = 1002 }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 8) }), createInstance("TextLabel", { BackgroundTransparency = 1, Position = UDim2.new(0, 12, 0, 12), Size = UDim2.new(1, -24, 0, 10), Font = Enum.Font.GothamSemibold, Text = notificationData.Title, TextXAlignment = Enum.TextXAlignment.Left, TextColor3 = Color3.fromRGB(180, 180, 180), TextSize = 13, RichText = true, Name = "Title", ZIndex = 1003 }), createInstance("TextLabel", { BackgroundTransparency = 1, Position = UDim2.new(0, 12, 0, 12), Size = UDim2.new(1, -24, 0, 10), Font = Enum.Font.GothamSemibold, Text = "", TextXAlignment = Enum.TextXAlignment.Right, TextColor3 = Color3.fromRGB(180, 180, 180), TextSize = 13, RichText = true, Name = "Time", ZIndex = 1003 }), createInstance("TextLabel", { BackgroundTransparency = 1, Position = UDim2.new(0, 12, 0, 11), Size = UDim2.new(1, -24, 1, -15), Font = Enum.Font.Gotham, Text = notificationData.Content, TextXAlignment = Enum.TextXAlignment.Left, TextColor3 = Color3.fromRGB(255, 255, 255), TextSize = 13, RichText = true, TextWrapped = true, Name = "Content", ZIndex = 1003 }), createInstance("Frame", { Parent = notificationButton, Size = UDim2.new(1, -24, 0, 3), Position = UDim2.new(0, 12, 1, -12), BackgroundColor3 = Color3.fromRGB(32, 32, 32), BorderSizePixel = 0, ZIndex = 1003 }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 3) }) }), notificationSeparatorFrame });
        spawn(function()
            for remainingTime = notificationData.Delay, 0, -1 do
                notificationContentFrame.Time.Text = remainingTime .. "s";
                task.wait(1);
            end;
            return ;
        end);
        notificationContentFrame.Size = UDim2.new(1, 0, 0, notificationContentFrame.Content.TextBounds.Y + 42);
        tweenServiceWrapper:Create(notificationButton, TweenInfo.new(0.25, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), { Size = UDim2.new(1, 0, 0, notificationContentFrame.Content.TextBounds.Y + 48) }):Play();
        tweenServiceWrapper:Create(notificationSeparatorFrame, TweenInfo.new(notificationData.Delay, Enum.EasingStyle.Linear, Enum.EasingDirection.Out), { Size = UDim2.new(0, 0, 0, 3) }):Play();
        delay(0.15, function()
            tweenServiceWrapper:Create(notificationContentFrame, TweenInfo.new(0.25, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), { Position = UDim2.new(0, 0, 0, 5) }):Play();
            return ;
        end);
        delay(notificationData.Delay, function()
            tweenServiceWrapper:Create(notificationContentFrame, TweenInfo.new(0.25, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), { Position = UDim2.new(1, 15, 0, 5) }):Play();
            delay(0.15, function()
                tweenServiceWrapper:Create(notificationButton, TweenInfo.new(0.25, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), { Size = UDim2.new(1, 0, 0, 0) }):Play();
                return ;
            end);
            delay(5, function()
                notificationButton:Destroy();
                return ;
            end);
            return ;
        end);
        return ;
    end;
    connectionManager.Load = function(notificationOptions)
        local notificationData = notificationOptions or {};
        notificationData.Title = notificationData.Title or "Title";
        if not string.find(notificationData.Title, "LKHUB") then
            while true do
            end;
        end;
        local isNotificationVisible = false;
        local isVisible = false;
        local closeButton = createInstance("TextButton", { BackgroundTransparency = 1, Position = UDim2.new(1, -34, 0, 4), Size = UDim2.new(1, -8, 1, -8), SizeConstraint = Enum.SizeConstraint.RelativeYY, Text = "" }, { createInstance("Frame", { AnchorPoint = Vector2.new(0.5, 0.5), BackgroundColor3 = Color3.fromRGB(38, 38, 38), BackgroundTransparency = 1, Position = UDim2.new(0.5, 0, 0.5, 0), Size = UDim2.new(0.8, 0, 0.8, 0), Name = "Hover" }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 8) }) }), createInstance("ImageLabel", { BackgroundTransparency = 1, Position = UDim2.new(0.5, -9, 0.5, -9), Size = UDim2.new(0, 18, 0, 18), Image = "rbxassetid://6235536018", ImageColor3 = Color3.fromRGB(180, 180, 180), ScaleType = Enum.ScaleType.Crop, Name = "Ico" }) });
        connectEvent(closeButton.MouseEnter, function()
            tweenServiceWrapper:Create(closeButton.Hover, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { Size = UDim2.new(1, 0, 1, 0), BackgroundTransparency = 0 }):Play();
            tweenServiceWrapper:Create(closeButton.Ico, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { ImageColor3 = Color3.fromRGB(255, 0, 68) }):Play();
            return ;
        end);
        connectEvent(closeButton.MouseLeave, function()
            tweenServiceWrapper:Create(closeButton.Hover, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { Size = UDim2.new(0.8, 0, 0.8, 0), BackgroundTransparency = 1 }):Play();
            tweenServiceWrapper:Create(closeButton.Ico, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { ImageColor3 = Color3.fromRGB(180, 180, 180) }):Play();
            return ;
        end);
        connectEvent(closeButton.MouseButton1Click, function()
            connectionManager.Uninject();
            return ;
        end);
        local acceptButton = createInstance("TextButton", { BackgroundTransparency = 1, Position = UDim2.new(0, 4, 0, 4), Size = UDim2.new(1, -8, 1, -8), SizeConstraint = Enum.SizeConstraint.RelativeYY, Text = "" }, { createInstance("Frame", { AnchorPoint = Vector2.new(0.5, 0.5), BackgroundColor3 = Color3.fromRGB(38, 38, 38), BackgroundTransparency = 1, Position = UDim2.new(0.5, 0, 0.5, 0), Size = UDim2.new(0.8, 0, 0.8, 0), Name = "Hover" }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 8) }) }), createInstance("ImageLabel", { BackgroundTransparency = 1, Position = UDim2.new(0.5, -8, 0.5, -8), Size = UDim2.new(0, 16, 0, 16), Image = "rbxassetid://7072718840", ImageColor3 = Color3.fromRGB(180, 180, 180), ScaleType = Enum.ScaleType.Crop, Name = "Ico" }) });
        connectEvent(acceptButton.MouseEnter, function()
            tweenServiceWrapper:Create(acceptButton.Hover, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { Size = UDim2.new(1, 0, 1, 0), BackgroundTransparency = 0 }):Play();
            tweenServiceWrapper:Create(acceptButton.Ico, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { ImageColor3 = Color3.fromRGB(255, 255, 255) }):Play();
            return ;
        end);
        connectEvent(acceptButton.MouseLeave, function()
            tweenServiceWrapper:Create(acceptButton.Hover, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { Size = UDim2.new(0.8, 0, 0.8, 0), BackgroundTransparency = 1 }):Play();
            tweenServiceWrapper:Create(acceptButton.Ico, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { ImageColor3 = Color3.fromRGB(180, 180, 180) }):Play();
            return ;
        end);
        local notificationContainerFrame = createInstance("Frame", { BackgroundColor3 = Color3.fromRGB(27, 27, 27), BorderSizePixel = 0, Position = UDim2.new(-1, -5, 0, 0), Size = UDim2.new(1, 0, 1, 0) }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 5) }), createInstance("Frame", { BackgroundColor3 = Color3.fromRGB(27, 27, 27), BorderSizePixel = 0, Position = UDim2.new(1, -5, 0, 0), Size = UDim2.new(0, 5, 1, 0) }), createInstance("Frame", { BackgroundColor3 = Color3.fromRGB(27, 27, 27), BorderSizePixel = 0, Size = UDim2.new(1, 0, 0, 5) }), createInstance("Frame", { BackgroundColor3 = Color3.fromRGB(50, 50, 50), BackgroundTransparency = 0.5, BorderSizePixel = 0, Position = UDim2.new(1, -1, 0, 0), Size = UDim2.new(0, 1, 1, 0) }), createInstance("Frame", { BackgroundColor3 = Color3.fromRGB(255, 255, 255), BackgroundTransparency = 1, Size = UDim2.new(1, 0, 1, 0), Name = "Container" }, { createInstance("UIPadding", { PaddingBottom = UDim.new(0, 10), PaddingTop = UDim.new(0, 10) }), createInstance("UIListLayout") }) });
        local mainFrame = createInstance("Frame", { AnchorPoint = Vector2.new(0.5, 0.5), BackgroundColor3 = Color3.fromRGB(25, 25, 25), Position = UDim2.new(0.5, 0, 0.5, 0), Size = UDim2.new(0, 480, 0, 380), Parent = screenGui }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 5) }), createInstance("ImageLabel", { BackgroundTransparency = 1, Position = UDim2.new(0, -15, 0, -15), Size = UDim2.new(1, 30, 1, 30), Image = "http://www.roblox.com/asset/?id=5554236805", ImageColor3 = Color3.fromRGB(10, 10, 10), ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(23, 23, 277, 277) }), createInstance("Folder", { Name = "Container" }), createInstance("TextButton", { Size = UDim2.new(1, 0, 1, -38), Position = UDim2.new(0, 0, 0, 38), BackgroundColor3 = Color3.fromRGB(0, 0, 0), BackgroundTransparency = 1, Text = "", AutoButtonColor = false, Name = "Darken", BorderSizePixel = 0, Visible = false }), createInstance("Frame", { BackgroundTransparency = 1, BorderSizePixel = 0, ClipsDescendants = true, Position = UDim2.new(0, 0, 0, 36), Size = UDim2.new(0.4, 0, 1, -36) }, { notificationContainerFrame }), createInstance("Frame", { BackgroundColor3 = Color3.fromRGB(27, 27, 27), Size = UDim2.new(1, 0, 0, 38), Position = UDim2.new(0, 0, 0, -1), Name = "TopBar" }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 5) }), createInstance("Frame", { BackgroundColor3 = Color3.fromRGB(27, 27, 27), BorderSizePixel = 0, Position = UDim2.new(0, 0, 1, -5), Size = UDim2.new(1, 0, 0, 5) }), createInstance("Frame", { BackgroundColor3 = Color3.fromRGB(50, 50, 50), BackgroundTransparency = 0.4, BorderSizePixel = 0, Position = UDim2.new(0, 0, 1, 0), Size = UDim2.new(1, 0, 0, 1) }), createInstance("TextLabel", { BackgroundTransparency = 1, Size = UDim2.new(1, 0, 1, 0), Font = Enum.Font.Gotham, Text = notificationData.Title, TextColor3 = Color3.fromRGB(180, 180, 180), TextSize = 14, RichText = true }), closeButton, acceptButton }) });
        connectionManager.MainFrame = mainFrame;
        local toggleNotificationsButton = createInstance("TextButton", { Text = "", AnchorPoint = Vector2.new(0.5, 0), BackgroundColor3 = Color3.new(1, 1, 1), BackgroundTransparency = 1, BorderSizePixel = 0, Position = UDim2.new(0.5, 0, 0, 10), Size = UDim2.new(0, 60, 0, 60), Visible = true, Parent = screenGui }, { createInstance("UIAspectRatioConstraint"), createInstance("ImageLabel", { Image = "rbxassetid://86512128296661", BackgroundTransparency = 1, Size = UDim2.new(0, 60, 0, 60), Visible = true, ZIndex = 0, Name = "Ellipse" }), createInstance("ImageLabel", { Image = "rbxassetid://110567333174139", BackgroundTransparency = 1, Size = UDim2.new(0, 60, 0, 60), Visible = true, Name = "Border" }), createInstance("ImageLabel", { Image = "rbxassetid://140542593588098", AnchorPoint = Vector2.new(0.5, 0.5), BackgroundTransparency = 1, Position = UDim2.new(0.5, 0, 0.5, 0), Size = UDim2.new(0, 26, 0, 24), Visible = true, ZIndex = 0, Name = "Vector" }, { createInstance("UIAspectRatioConstraint", { AspectType = Enum.AspectType.ScaleWithParentSize }) }), createInstance("UICorner", { CornerRadius = UDim.new(1, 0) }), createInstance("ImageLabel", { Image = "rbxassetid://110567333174139", BackgroundTransparency = 1, Rotation = 180, Size = UDim2.new(0, 60, 0, 60), Visible = true, Name = "Border2" }), createInstance("UIStroke", { ApplyStrokeMode = Enum.ApplyStrokeMode.Border, Color = Color3.new(0.0862745, 0.576471, 0.0313726) }) });
        local isUIVisible = true;
        local toggleNotifications = function()
            isUIVisible = not isUIVisible;
            if not mainFrame then
                spawn(function()
                    while not mainFrame do
                        task.wait(0.1);
                    end;
                    mainFrame.Visible = isUIVisible;
                    return ;
                end);
            else
                mainFrame.Visible = isUIVisible;
            end;
            return ;
        end;
        connectEvent(toggleNotificationsButton.MouseButton1Click, function()
            toggleNotifications();
            return ;
        end);
        connectEvent(toggleNotificationsButton.TouchTap, function()
            toggleNotifications();
            return ;
        end);
        connectEvent(acceptButton.MouseButton1Click, function()
            isNotificationVisible = not isNotificationVisible;
            tweenServiceWrapper:Create(notificationContainerFrame, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { Position = isNotificationVisible and UDim2.new(0, 0, 0, 0) or UDim2.new(-1, -5, 0, 0) }):Play();
            tweenServiceWrapper:Create(mainFrame.Darken, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { BackgroundTransparency = isNotificationVisible and 0.8 or 1 }):Play();
            mainFrame.Darken.Visible = isNotificationVisible;
            return ;
        end);
        makeDraggable(mainFrame.TopBar, mainFrame);
        makeDraggable(toggleNotificationsButton, toggleNotificationsButton);
        return {
            AddTab = function(buttonText)
                local notificationButton = createInstance("TextButton", { Parent = notificationContainerFrame.Container, BackgroundColor3 = Color3.fromRGB(0, 150, 100), BackgroundTransparency = 1, BorderSizePixel = 0, Size = UDim2.new(1, 0, 0, 35), Text = "", AutoButtonColor = false }, { createInstance("TextLabel", { BackgroundTransparency = 1, Position = UDim2.new(0, 10, 0, 0), Size = UDim2.new(1, -10, 1, 0), Font = Enum.Font.Gotham, Text = buttonText, TextColor3 = Color3.fromRGB(165, 165, 165), TextSize = 14, TextXAlignment = Enum.TextXAlignment.Left, Name = "Title" }) });
                local notificationScrollingFrame = createInstance("ScrollingFrame", { Parent = mainFrame.Container, Size = UDim2.new(1, 0, 1, -38), Position = UDim2.new(0, 0, 0, 38), BackgroundTransparency = 1, Visible = false, MidImage = "rbxassetid://7445543667", BottomImage = "rbxassetid://7445542488", TopImage = "rbxassetid://7445543667", ScrollBarImageColor3 = Color3.fromRGB(27, 27, 27), ScrollBarThickness = 6, CanvasSize = UDim2.new(0, 0, 0, 0), BorderSizePixel = 0 }, { createInstance("UIPadding", { PaddingBottom = UDim.new(0, 14), PaddingTop = UDim.new(0, 14), PaddingLeft = UDim.new(0, 16), PaddingRight = UDim.new(0, 16) }), createInstance("UIListLayout", { Padding = UDim.new(0, 12) }) });
                connectEvent(notificationScrollingFrame.UIListLayout:GetPropertyChangedSignal("AbsoluteContentSize"), function()
                    notificationScrollingFrame.CanvasSize = UDim2.new(0, 0, 0, notificationScrollingFrame.UIListLayout.AbsoluteContentSize.Y + 28);
                    return ;
                end);
                if isVisible == false then
                    isVisible = true;
                    notificationScrollingFrame.Visible = true;
                    notificationButton.BackgroundTransparency = 0;
                    notificationButton.Title.TextColor3 = Color3.fromRGB(255, 255, 255);
                end;
                connectEvent(notificationButton.MouseButton1Click, function()
                    for index, child in next, notificationContainerFrame.Container:GetChildren() do
                        if child:IsA("TextButton") then
                            tweenServiceWrapper:Create(child, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { BackgroundTransparency = 1 }):Play();
                            tweenServiceWrapper:Create(child.Title, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { TextColor3 = Color3.fromRGB(165, 165, 165) }):Play();
                        end;
                    end;
                    for childIndex, child in next, mainFrame.Container:GetChildren() do
                        if child:IsA("ScrollingFrame") then
                            child.Visible = false;
                        end;
                    end;
                    tweenServiceWrapper:Create(notificationButton, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { BackgroundTransparency = 0 }):Play();
                    tweenServiceWrapper:Create(notificationButton.Title, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { TextColor3 = Color3.fromRGB(255, 255, 255) }):Play();
                    notificationScrollingFrame.Visible = true;
                    return ;
                end);
                return {
                    AddSection = function(canvasGroupProperties)
                        local isSectionExpanded = true;
                        local sectionCanvasGroup = createInstance("CanvasGroup", { BackgroundColor3 = Color3.fromRGB(26, 26, 26), BorderColor3 = Color3.fromRGB(0, 0, 0), BorderSizePixel = 0, Position = UDim2.fromScale(-6.83E-08, 0), Size = UDim2.new(1, 0, 0, 32), Parent = notificationScrollingFrame }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 6) }), createInstance("TextButton", { Text = "", AutoButtonColor = false, BackgroundColor3 = Color3.fromRGB(28, 28, 28), BorderColor3 = Color3.fromRGB(50, 50, 50), BorderSizePixel = 0, ClipsDescendants = true, Size = UDim2.new(1, 0, 0, 32), Name = "Header" }, { createInstance("TextLabel", { FontFace = Font.new("rbxasset://fonts/families/GothamSSm.json"), Text = canvasGroupProperties, TextColor3 = Color3.fromRGB(255, 255, 255), TextSize = 13, TextXAlignment = Enum.TextXAlignment.Left, BackgroundTransparency = 1, BorderColor3 = Color3.fromRGB(27, 42, 53), Position = UDim2.fromOffset(10, 0), Size = UDim2.new(1, -10, 1, 0), Name = "TitleLabel" }), createInstance("TextLabel", { FontFace = Font.new("rbxasset://fonts/families/GothamSSm.json"), Text = "", TextColor3 = Color3.fromRGB(255, 255, 255), TextSize = 13, TextTransparency = 0.4, TextXAlignment = Enum.TextXAlignment.Right, BackgroundTransparency = 1, BorderColor3 = Color3.fromRGB(27, 42, 53), Position = UDim2.fromOffset(10, 0), Size = UDim2.new(1, -38, 1, 0), Name = "StatusLabel" }), createInstance("ImageLabel", { Image = "rbxassetid://7072706745", ImageColor3 = Color3.fromRGB(165, 165, 165), BackgroundTransparency = 1, BorderColor3 = Color3.fromRGB(27, 42, 53), Position = UDim2.new(1, -24, 0.5, -8), Size = UDim2.fromOffset(16, 16), Name = "Arrow" }), createInstance("UIStroke", { ApplyStrokeMode = Enum.ApplyStrokeMode.Border, Color = Color3.fromRGB(50, 50, 50), Thickness = 0.8, Transparency = 0.4 }) }), createInstance("CanvasGroup", { AutomaticSize = Enum.AutomaticSize.Y, BackgroundTransparency = 1, BorderColor3 = Color3.fromRGB(27, 42, 53), BorderSizePixel = 0, Position = UDim2.fromOffset(0, 32), Size = UDim2.new(1, 0, 1, -32), Name = "Content" }, { createInstance("UIListLayout", { Padding = UDim.new(0, 5) }), createInstance("UIPadding", { PaddingBottom = UDim.new(0, 6), PaddingLeft = UDim.new(0, 5), PaddingRight = UDim.new(0, 5), PaddingTop = UDim.new(0, 6) }) }) });
                        local sectionHeaderButton = sectionCanvasGroup.Header;
                        local sectionContentFrame = sectionCanvasGroup.Content;
                        local sectionArrowImage = sectionHeaderButton.Arrow;
                        local collapseAnimation = function()
                            local arrowRotation = isSectionExpanded and 0 or -90;
                            tweenServiceWrapper:Create(sectionArrowImage, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { Rotation = arrowRotation }):Play();
                            return ;
                        end;
                        local expandAnimation = function()
                            if isSectionExpanded then
                                sectionContentFrame.Visible = true;
                                sectionContentFrame.GroupTransparency = 0;
                                local contentHeight = sectionContentFrame.UIListLayout.AbsoluteContentSize.Y + 12;
                                tweenServiceWrapper:Create(sectionCanvasGroup, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { Size = UDim2.new(1, 0, 0, 32 + contentHeight) }):Play();
                            else
                                sectionContentFrame.GroupTransparency = 1;
                                sectionContentFrame.Visible = false;
                                tweenServiceWrapper:Create(sectionCanvasGroup, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { Size = UDim2.new(1, 0, 0, 32) }):Play();
                            end;
                            return ;
                        end;
                        connectEvent(sectionHeaderButton.MouseButton1Click, function()
                            isSectionExpanded = not isSectionExpanded;
                            collapseAnimation();
                            expandAnimation();
                            return ;
                        end);
                        connectEvent(sectionHeaderButton.MouseEnter, function()
                            tweenServiceWrapper:Create(sectionHeaderButton, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { BackgroundColor3 = Color3.fromRGB(30, 30, 30) }):Play();
                            return ;
                        end);
                        connectEvent(sectionHeaderButton.MouseLeave, function()
                            tweenServiceWrapper:Create(sectionHeaderButton, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { BackgroundColor3 = Color3.fromRGB(28, 28, 28) }):Play();
                            return ;
                        end);
                        connectEvent(sectionContentFrame.UIListLayout:GetPropertyChangedSignal("AbsoluteContentSize"), function()
                            local contentHeight = sectionContentFrame.UIListLayout.AbsoluteContentSize.Y + 12;
                            sectionContentFrame.Size = UDim2.new(1, 0, 0, contentHeight);
                            if isSectionExpanded then
                                sectionCanvasGroup.Size = UDim2.new(1, 0, 0, 32 + contentHeight);
                            end;
                            return ;
                        end);
                        return {
                            AddButton = function(unknownTable1)
                                local buttonConfig = unknownTable1 or {};
                                buttonConfig.Name = buttonConfig.Name or "Button";
                                buttonConfig.Callback = buttonConfig.Callback or function()
                                    return ;
                                end;
                                local buttonModule = {};
                                local buttonTextButton = createInstance("TextButton", { BackgroundColor3 = Color3.fromRGB(28, 28, 28), Size = UDim2.new(1, 0, 0, 32), Parent = sectionContentFrame, AutoButtonColor = false, ClipsDescendants = true, Text = "" }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 5) }) });
                                local buttonTextLabel = createInstance("TextLabel", { Parent = buttonTextButton, BackgroundTransparency = 1, Position = UDim2.new(0, 10, 0, 0), Size = UDim2.new(1, -10, 1, 0), Font = Enum.Font.Gotham, TextColor3 = Color3.fromRGB(255, 255, 255), TextSize = 13, TextXAlignment = Enum.TextXAlignment.Left, Text = buttonConfig.Name });
                                connectEvent(buttonTextButton.MouseEnter, function()
                                    tweenServiceWrapper:Create(buttonTextButton, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { BackgroundColor3 = Color3.fromRGB(30, 30, 30) }):Play();
                                    return ;
                                end);
                                connectEvent(buttonTextButton.MouseLeave, function()
                                    tweenServiceWrapper:Create(buttonTextButton, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { BackgroundColor3 = Color3.fromRGB(28, 28, 28) }):Play();
                                    return ;
                                end);
                                connectEvent(buttonTextButton.MouseButton1Down, function()
                                    tweenServiceWrapper:Create(buttonTextButton, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { BackgroundColor3 = Color3.fromRGB(33, 33, 33) }):Play();
                                    return ;
                                end);
                                connectEvent(buttonTextButton.MouseButton1Up, function()
                                    tweenServiceWrapper:Create(buttonTextButton, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { BackgroundColor3 = Color3.fromRGB(30, 30, 30) }):Play();
                                    createDraggableIcon(buttonTextButton);
                                    buttonConfig.Callback();
                                    return ;
                                end);
                                buttonModule.Set = function(L_2530, buttonName)
                                    buttonConfig.Name = buttonName or "Button";
                                    buttonTextLabel.Text = buttonConfig.Name;
                                    return ;
                                end;
                                return buttonModule;
                            end,
                            AddToggle = function(unknownTable2)
                                local toggleConfig = unknownTable2 or {};
                                toggleConfig.Name = toggleConfig.Name or "Toggle";
                                toggleConfig.IgnoreFirst = toggleConfig.IgnoreFirst or false;
                                toggleConfig.Default = toggleConfig.Default or false;
                                toggleConfig.Callback = toggleConfig.Callback or function()
                                    return ;
                                end;
                                local toggleValue = { Value = toggleConfig.Default, Type = "Toggle" };
                                local mainFrame = createInstance("Frame", { AnchorPoint = Vector2.new(0.5, 0.5), BackgroundColor3 = Color3.fromRGB(0, 150, 100), Position = UDim2.new(0.5, 0, 0.5, 0), Size = UDim2.new(0.5, 0, 0.5, 0), BackgroundTransparency = 1, BorderSizePixel = 0 }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 5) }), createInstance("ImageLabel", { AnchorPoint = Vector2.new(0.5, 0.5), BackgroundTransparency = 1, Position = UDim2.new(0.5, 0, 0.5, 0), Size = UDim2.new(1, -2, 1, -2), Image = "http://www.roblox.com/asset/?id=6031094667", ImageTransparency = 1, Name = "Ico" }) });
                                local uiFrame = createInstance("Frame", { AnchorPoint = Vector2.new(1, 0.5), BackgroundColor3 = Color3.fromRGB(28, 28, 28), Position = UDim2.new(1, -10, 0.5, 0), Size = UDim2.new(0, 20, 0, 20), BackgroundTransparency = 1 }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 5) }), createInstance("UIStroke", { Color = Color3.fromRGB(55, 55, 55) }), mainFrame });
                                local menuButton = createInstance("TextButton", { BackgroundColor3 = Color3.fromRGB(28, 28, 28), Size = UDim2.new(1, 0, 0, 32), Parent = sectionContentFrame, AutoButtonColor = false, ClipsDescendants = true, Text = "" }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 5) }), createInstance("TextLabel", { BackgroundTransparency = 1, Position = UDim2.new(0, 10, 0, 0), Size = UDim2.new(1, -10, 1, 0), Font = Enum.Font.Gotham, TextColor3 = Color3.fromRGB(255, 255, 255), TextSize = 13, TextXAlignment = Enum.TextXAlignment.Left, Text = toggleConfig.Name }), uiFrame });
                                connectEvent(menuButton.MouseEnter, function()
                                    tweenServiceWrapper:Create(menuButton, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { BackgroundColor3 = Color3.fromRGB(30, 30, 30) }):Play();
                                    return ;
                                end);
                                connectEvent(menuButton.MouseLeave, function()
                                    tweenServiceWrapper:Create(menuButton, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { BackgroundColor3 = Color3.fromRGB(28, 28, 28) }):Play();
                                    return ;
                                end);
                                connectEvent(menuButton.MouseButton1Down, function()
                                    tweenServiceWrapper:Create(menuButton, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { BackgroundColor3 = Color3.fromRGB(33, 33, 33) }):Play();
                                    return ;
                                end);
                                connectEvent(menuButton.MouseButton1Up, function()
                                    tweenServiceWrapper:Create(menuButton, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { BackgroundColor3 = Color3.fromRGB(30, 30, 30) }):Play();
                                    toggleValue:Set(not toggleValue.Value);
                                    return ;
                                end);
                                toggleValue.Set = function(isMenuOpen, newValue, skipCallback)
                                    isMenuOpen.Value = newValue;
                                    tweenServiceWrapper:Create(mainFrame, TweenInfo.new(0.25, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), { BackgroundTransparency = isMenuOpen.Value and 0 or 1, Size = isMenuOpen.Value and UDim2.new(1, 0, 1, 0) or UDim2.new(0.5, 0, 0.5, 0) }):Play();
                                    tweenServiceWrapper:Create(mainFrame.Ico, TweenInfo.new(0.25, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), { ImageTransparency = isMenuOpen.Value and 0 or 1 }):Play();
                                    if not skipCallback then
                                        return toggleConfig.Callback(isMenuOpen.Value);
                                    end;
                                    return ;
                                end;
                                toggleValue:Set(toggleValue.Value, toggleConfig.IgnoreFirst);
                                return toggleValue;
                            end,
                            AddSlider = function(unknownTable3)
                                local sliderConfig = unknownTable3 or {};
                                sliderConfig.Name = sliderConfig.Name or "Slider";
                                sliderConfig.Min = sliderConfig.Min or 10;
                                sliderConfig.Max = sliderConfig.Max or 20;
                                sliderConfig.Increment = sliderConfig.Increment or 1;
                                sliderConfig.Default = sliderConfig.Default or 0;
                                sliderConfig.AllowInput = sliderConfig.AllowInput or false;
                                sliderConfig.IgnoreFirst = sliderConfig.IgnoreFirst or false;
                                sliderConfig.Callback = sliderConfig.Callback or function()
                                    return ;
                                end;
                                local sliderValue = { Value = sliderConfig.Default, Type = "Slider" };
                                local isDragging = false;
                                local unknownValue5 = nil;
                                local valueTextBox;
                                if sliderConfig.AllowInput then
                                    valueTextBox = createInstance("TextBox", { CursorPosition = -1, Font = Enum.Font.Gotham, PlaceholderColor3 = Color3.fromRGB(210, 210, 210), PlaceholderText = "Input Value", Text = "", TextColor3 = Color3.fromRGB(255, 255, 255), TextSize = 13, TextXAlignment = Enum.TextXAlignment.Right, AnchorPoint = Vector2.new(1, 0), AutomaticSize = Enum.AutomaticSize.X, BackgroundColor3 = Color3.fromRGB(36, 36, 36), Position = UDim2.new(1, -10, 0, 5), Size = UDim2.new(0, 50, 0, 20), Visible = true, Parent = workspace }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 5) }), createInstance("UIPadding", { PaddingLeft = UDim.new(0, 5), PaddingRight = UDim.new(0, 5) }) });
                                    connectEvent(valueTextBox:GetPropertyChangedSignal("Text"), function()
                                        valueTextBox.Size = UDim2.new(0, valueTextBox.TextBounds.X + 10, 0, 20);
                                        return ;
                                    end);
                                    valueTextBox.Size = UDim2.new(0, valueTextBox.TextBounds.X + 10, 0, 20);
                                    connectEvent(valueTextBox.FocusLost, function()
                                        if tonumber(valueTextBox.Text) then
                                            sliderValue:Set(tonumber(valueTextBox.Text));
                                        else
                                            valueTextBox.Text = sliderValue.Value;
                                        end;
                                        return ;
                                    end);
                                else
                                    valueTextBox = createInstance("TextLabel", { BackgroundTransparency = 1, Position = UDim2.new(0, 10, 0, 0), Size = UDim2.new(1, -20, 0, 32), Font = Enum.Font.Gotham, TextColor3 = Color3.fromRGB(255, 255, 255), TextSize = 13, TextXAlignment = Enum.TextXAlignment.Right, Text = "" });
                                end;
                                local sliderBar = createInstance("Frame", { Position = UDim2.new(0, 0, 0, 0), Size = UDim2.new(0, 0, 1, 0), BackgroundColor3 = Color3.fromRGB(50, 50, 50), BorderSizePixel = 0 }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 4) }) });
                                local sliderThumb = createInstance("TextButton", { Position = UDim2.new(0.5, -6, 0.5, -6), Size = UDim2.new(0, 12, 0, 12), BackgroundColor3 = Color3.fromRGB(55, 55, 55), BorderSizePixel = 0, AutoButtonColor = false, Text = "" }, { createInstance("UICorner", { CornerRadius = UDim.new(1, 0) }), createInstance("UIStroke", { Color = Color3.fromRGB(65, 65, 65), ApplyStrokeMode = Enum.ApplyStrokeMode.Border }) });
                                local sliderTrack = createInstance("Frame", { Position = UDim2.new(0, 10, 0, 30), Size = UDim2.new(1, -20, 0, 4), BackgroundColor3 = Color3.fromRGB(36, 36, 36), BorderSizePixel = 0 }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 4) }), createInstance("UIStroke", { Color = Color3.fromRGB(55, 55, 55) }), sliderBar, sliderThumb });
                                local textButton = createInstance("TextButton", { BackgroundColor3 = Color3.fromRGB(28, 28, 28), Size = UDim2.new(1, 0, 0, 42), Parent = sectionContentFrame, AutoButtonColor = false, ClipsDescendants = true, Text = "" }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 5) }), createInstance("TextLabel", { BackgroundTransparency = 1, Position = UDim2.new(0, 10, 0, 0), Size = UDim2.new(1, -10, 0, 32), Font = Enum.Font.Gotham, TextColor3 = Color3.fromRGB(255, 255, 255), TextSize = 13, TextXAlignment = Enum.TextXAlignment.Left, Text = sliderConfig.Name }), valueTextBox, sliderTrack });
                                local onSliderInputBegan = function(inputObject)
                                    if inputObject.UserInputType == Enum.UserInputType.MouseButton1 or inputObject.UserInputType == Enum.UserInputType.Touch then
                                        isDragging = true;
                                        local sliderValue = math.clamp((inputObject.Position.X - sliderTrack.AbsolutePosition.X) / sliderTrack.AbsoluteSize.X, 0, 1);
                                        sliderValue:Set(sliderConfig.Min + (sliderConfig.Max - sliderConfig.Min) * sliderValue);
                                    end;
                                    return ;
                                end;
                                connectEvent(sliderThumb.InputBegan, onSliderInputBegan);
                                connectEvent(sliderTrack.InputBegan, onSliderInputBegan);
                                connectEvent(textButton.InputBegan, onSliderInputBegan);
                                connectEvent(userInputServiceWrapper.InputEnded, function(inputObjectEnded)
                                    if inputObjectEnded.UserInputType == Enum.UserInputType.MouseButton1 or inputObjectEnded.UserInputType == Enum.UserInputType.Touch then
                                        isDragging = false;
                                    end;
                                    return ;
                                end);
                                connectEvent(userInputServiceWrapper.InputChanged, function(inputObjectMoved)
                                    if isDragging and (inputObjectMoved.UserInputType == Enum.UserInputType.MouseMovement or inputObjectMoved.UserInputType == Enum.UserInputType.Touch) then
                                        local sliderValue = math.clamp((inputObjectMoved.Position.X - sliderTrack.AbsolutePosition.X) / sliderTrack.AbsoluteSize.X, 0, 1);
                                        sliderValue:Set(sliderConfig.Min + (sliderConfig.Max - sliderConfig.Min) * sliderValue);
                                    end;
                                    return ;
                                end);
                                sliderValue.Set = function(self, inputValue, skipCallback)
                                    self.Value = math.clamp(roundToIncrement(inputValue, sliderConfig.Increment), sliderConfig.Min, sliderConfig.Max);
                                    valueTextBox.Text = tostring(self.Value);
                                    tweenServiceWrapper:Create(sliderThumb, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Position = UDim2.new((self.Value - sliderConfig.Min) / (sliderConfig.Max - sliderConfig.Min), -6, 0.5, -6) }):Play();
                                    tweenServiceWrapper:Create(sliderBar, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Size = UDim2.fromScale((self.Value - sliderConfig.Min) / (sliderConfig.Max - sliderConfig.Min), 1) }):Play();
                                    if not skipCallback then
                                        return sliderConfig.Callback(self.Value);
                                    end;
                                    return ;
                                end;
                                sliderValue:Set(sliderValue.Value, sliderConfig.IgnoreFirst);
                                return sliderValue;
                            end,
                            AddRangeSlider = function(unknownTable4)
                                local rangeSliderConfig = unknownTable4 or {};
                                rangeSliderConfig.Name = rangeSliderConfig.Name or "Slider";
                                rangeSliderConfig.Min = rangeSliderConfig.Min or 10;
                                rangeSliderConfig.Max = rangeSliderConfig.Max or 20;
                                rangeSliderConfig.DefaultMin = rangeSliderConfig.DefaultMin or rangeSliderConfig.Min;
                                rangeSliderConfig.DefaultMax = rangeSliderConfig.DefaultMax or rangeSliderConfig.Max;
                                rangeSliderConfig.Increment = rangeSliderConfig.Increment or 1;
                                rangeSliderConfig.IgnoreFirst = rangeSliderConfig.IgnoreFirst or false;
                                rangeSliderConfig.Callback = rangeSliderConfig.Callback or function()
                                    return ;
                                end;
                                local rangeSliderValue = { MinValue = rangeSliderConfig.DefaultMin, MaxValue = rangeSliderConfig.DefaultMax, Type = "RangeSlider" };
                                local isMinThumbDragging = false;
                                local isMaxThumbDragging = false;
                                local rangeTextLabel = createInstance("TextLabel", { BackgroundTransparency = 1, Position = UDim2.new(0, 10, 0, 0), Size = UDim2.new(1, -20, 0, 32), Font = Enum.Font.Gotham, TextColor3 = Color3.fromRGB(255, 255, 255), TextSize = 13, TextXAlignment = Enum.TextXAlignment.Right, Text = "" });
                                local rangeSliderBar = createInstance("Frame", { Position = UDim2.new(0, 0, 0, 0), Size = UDim2.new(0, 0, 1, 0), BackgroundColor3 = Color3.fromRGB(50, 50, 50), BorderSizePixel = 0 }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 4) }) });
                                local createThumbButton = function()
                                    return createInstance("TextButton", { Position = UDim2.new(0.5, -6, 0.5, -6), Size = UDim2.new(0, 12, 0, 12), BackgroundColor3 = Color3.fromRGB(55, 55, 55), BorderSizePixel = 0, AutoButtonColor = false, Text = "" }, { createInstance("UICorner", { CornerRadius = UDim.new(1, 0) }), createInstance("UIStroke", { Color = Color3.fromRGB(65, 65, 65), ApplyStrokeMode = Enum.ApplyStrokeMode.Border }) });
                                end;
                                local minSliderThumb = createThumbButton();
                                local maxSliderThumb = createThumbButton();
                                local rangeSliderTrack = createInstance("Frame", { Position = UDim2.new(0, 10, 0, 30), Size = UDim2.new(1, -20, 0, 4), BackgroundColor3 = Color3.fromRGB(36, 36, 36), BorderSizePixel = 0 }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 4) }), createInstance("UIStroke", { Color = Color3.fromRGB(55, 55, 55) }), rangeSliderBar, minSliderThumb, maxSliderThumb });
                                local rangeButton = createInstance("TextButton", { BackgroundColor3 = Color3.fromRGB(28, 28, 28), Size = UDim2.new(1, 0, 0, 42), Parent = sectionContentFrame, AutoButtonColor = false, ClipsDescendants = true, Text = "" }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 5) }), createInstance("TextLabel", { BackgroundTransparency = 1, Position = UDim2.new(0, 10, 0, 0), Size = UDim2.new(1, -10, 0, 32), Font = Enum.Font.Gotham, TextColor3 = Color3.fromRGB(255, 255, 255), TextSize = 13, TextXAlignment = Enum.TextXAlignment.Left, Text = rangeSliderConfig.Name }), rangeSliderTrack, rangeTextLabel });
                                connectEvent(minSliderThumb.InputBegan, function(minThumbInputObject)
                                    if minThumbInputObject.UserInputType == Enum.UserInputType.MouseButton1 or minThumbInputObject.UserInputType == Enum.UserInputType.Touch then
                                        isMinThumbDragging = true;
                                    end;
                                    return ;
                                end);
                                connectEvent(minSliderThumb.InputEnded, function(minThumbInputObjectEnded)
                                    if minThumbInputObjectEnded.UserInputType == Enum.UserInputType.MouseButton1 or minThumbInputObjectEnded.UserInputType == Enum.UserInputType.Touch then
                                        isMinThumbDragging = false;
                                    end;
                                    return ;
                                end);
                                connectEvent(maxSliderThumb.InputBegan, function(maxThumbInputObject)
                                    if maxThumbInputObject.UserInputType == Enum.UserInputType.MouseButton1 or maxThumbInputObject.UserInputType == Enum.UserInputType.Touch then
                                        isMaxThumbDragging = true;
                                    end;
                                    return ;
                                end);
                                connectEvent(maxSliderThumb.InputEnded, function(maxThumbInputObjectEnded)
                                    if maxThumbInputObjectEnded.UserInputType == Enum.UserInputType.MouseButton1 or maxThumbInputObjectEnded.UserInputType == Enum.UserInputType.Touch then
                                        isMaxThumbDragging = false;
                                    end;
                                    return ;
                                end);
                                connectEvent(userInputServiceWrapper.InputChanged, function(rangeSliderInputObject)
                                    if (isMinThumbDragging or isMaxThumbDragging) and (rangeSliderInputObject.UserInputType == Enum.UserInputType.MouseMovement or rangeSliderInputObject.UserInputType == Enum.UserInputType.Touch) then
                                        local sliderPosition = math.clamp((rangeSliderInputObject.Position.X - rangeSliderTrack.AbsolutePosition.X) / rangeSliderTrack.AbsoluteSize.X, 0, 1);
                                        if isMinThumbDragging then
                                            rangeSliderValue:Set(rangeSliderConfig.Min + (rangeSliderConfig.Max - rangeSliderConfig.Min) * sliderPosition, rangeSliderValue.MaxValue);
                                        elseif isMaxThumbDragging then
                                            rangeSliderValue:Set(rangeSliderValue.MinValue, rangeSliderConfig.Min + (rangeSliderConfig.Max - rangeSliderConfig.Min) * sliderPosition);
                                        end;
                                    end;
                                    return ;
                                end);
                                rangeSliderValue.Set = function(numberRange, minValueInput, maxValueInput, shouldTriggerCallback)
                                    rangeSliderValue.MinValue = math.clamp(roundToIncrement(minValueInput, rangeSliderConfig.Increment), rangeSliderConfig.Min, rangeSliderValue.MaxValue);
                                    rangeSliderValue.MaxValue = math.clamp(roundToIncrement(maxValueInput, rangeSliderConfig.Increment), rangeSliderValue.MinValue, rangeSliderConfig.Max);
                                    local sliderMinValueRatio = (rangeSliderValue.MinValue - rangeSliderConfig.Min) / (rangeSliderConfig.Max - rangeSliderConfig.Min);
                                    local sliderMaxValueRatio = (rangeSliderValue.MaxValue - rangeSliderConfig.Min) / (rangeSliderConfig.Max - rangeSliderConfig.Min);
                                    tweenServiceWrapper:Create(minSliderThumb, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Position = UDim2.new(sliderMinValueRatio, -6, 0.5, -6) }):Play();
                                    tweenServiceWrapper:Create(maxSliderThumb, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Position = UDim2.new(sliderMaxValueRatio, -6, 0.5, -6) }):Play();
                                    tweenServiceWrapper:Create(rangeSliderBar, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Position = UDim2.new(sliderMinValueRatio, 0, 0, 0), Size = UDim2.new(sliderMaxValueRatio - sliderMinValueRatio, 0, 1, 0) }):Play();
                                    rangeTextLabel.Text = rangeSliderValue.MinValue .. (" - " .. rangeSliderValue.MaxValue);
                                    rangeSliderConfig.Callback(rangeSliderValue.MinValue, rangeSliderValue.MaxValue);
                                    if not shouldTriggerCallback then
                                        return rangeSliderConfig.Callback(numberRange.MinValue, numberRange.MaxValue);
                                    end;
                                    return ;
                                end;
                                rangeSliderValue:Set(rangeSliderValue.MinValue, rangeSliderValue.MaxValue, rangeSliderConfig.IgnoreFirst);
                                return rangeSliderValue;
                            end,
                            AddDropdown = function(unknownTable5)
                                local dropdownConfig = unknownTable5 or {};
                                dropdownConfig.Name = dropdownConfig.Name or "Dropdown";
                                dropdownConfig.Options = dropdownConfig.Options or {};
                                dropdownConfig.Default = dropdownConfig.Default or "";
                                dropdownConfig.IgnoreFirst = dropdownConfig.IgnoreFirst or false;
                                dropdownConfig.Multiple = dropdownConfig.Multiple or false;
                                dropdownConfig.MaxOptions = dropdownConfig.MaxOptions or math.huge;
                                dropdownConfig.Callback = dropdownConfig.Callback or function()
                                    return ;
                                end;
                                local dropdownData = { Value = dropdownConfig.Default, Options = dropdownConfig.Options, Buttons = {}, Toggled = false, Type = "Dropdown" };
                                local uiListLayout = createInstance("UIListLayout", { Padding = UDim.new(0, 2), HorizontalAlignment = Enum.HorizontalAlignment.Center });
                                local optionsFrame = createInstance("Frame", { BackgroundTransparency = 1, LayoutOrder = 1, Size = UDim2.new(1, -2, 0, dropdownConfig.Multiple and 57 or 32), Visible = true }, { createInstance("UIListLayout", { HorizontalAlignment = Enum.HorizontalAlignment.Center, SortOrder = Enum.SortOrder.LayoutOrder }) });
                                local searchTextBox = createInstance("TextBox", { CursorPosition = -1, Font = Enum.Font.Gotham, PlaceholderColor3 = Color3.fromRGB(130, 130, 130), PlaceholderText = "Search...", Text = "", TextColor3 = Color3.fromRGB(255, 255, 255), TextSize = 13, TextXAlignment = Enum.TextXAlignment.Left, BackgroundColor3 = Color3.fromRGB(24, 24, 24), LayoutOrder = 1, Size = UDim2.new(1, 0, 0, 30), Visible = true, Parent = optionsFrame }, { createInstance("UIPadding", { PaddingLeft = UDim.new(0, 10) }), createInstance("UIStroke", { ApplyStrokeMode = Enum.ApplyStrokeMode.Border, Color = Color3.fromRGB(40, 40, 40) }) });
                                local selectAllDeselectAllFrame = createInstance("Frame", { BackgroundTransparency = 1, LayoutOrder = 2, Size = UDim2.new(1, 0, 0, 25), Visible = dropdownConfig.Multiple, Parent = optionsFrame }, { createInstance("UIListLayout", { FillDirection = Enum.FillDirection.Horizontal, HorizontalAlignment = Enum.HorizontalAlignment.Center }) });
                                local selectAllButton = createInstance("TextButton", { Font = Enum.Font.Gotham, Text = "Select All", TextColor3 = Color3.fromRGB(255, 255, 255), TextSize = 12, BackgroundColor3 = Color3.fromRGB(24, 24, 24), Size = UDim2.new(0.5, 0, 0, 25), Visible = dropdownConfig.Multiple, Parent = selectAllDeselectAllFrame }, { createInstance("UIStroke", { ApplyStrokeMode = Enum.ApplyStrokeMode.Border, Color = Color3.fromRGB(40, 40, 40) }) });
                                local deselectAllButton = createInstance("TextButton", { Font = Enum.Font.Gotham, Text = "Deselect All", TextColor3 = Color3.fromRGB(255, 255, 255), TextSize = 12, BackgroundColor3 = Color3.fromRGB(24, 24, 24), Size = UDim2.new(0.5, 0, 0, 25), Visible = dropdownConfig.Multiple, Parent = selectAllDeselectAllFrame }, { createInstance("UIStroke", { ApplyStrokeMode = Enum.ApplyStrokeMode.Border, Color = Color3.fromRGB(40, 40, 40) }) });
                                local scrollingFrame = createInstance("ScrollingFrame", { Position = UDim2.new(0, 0, 0, 32), Size = UDim2.new(1, 0, 1, -32), BackgroundTransparency = 1, MidImage = "rbxassetid://7445543667", BottomImage = "rbxassetid://7445542488", TopImage = "rbxassetid://7445543667", ScrollBarImageColor3 = Color3.fromRGB(35, 35, 35), ScrollBarThickness = 4, CanvasSize = UDim2.new(0, 0, 0, 0), BorderSizePixel = 0 }, { uiListLayout, optionsFrame });
                                local dropdownArrowImage = createInstance("ImageLabel", { Image = "rbxassetid://7072706745", BackgroundTransparency = 1, ImageColor3 = Color3.fromRGB(165, 165, 165), Size = UDim2.new(0, 16, 0, 16), Position = UDim2.new(1, -24, 0.5, -8) });
                                local selectedOptionLabel = createInstance("TextLabel", { BackgroundTransparency = 1, Position = UDim2.new(0, 10, 0, 0), Size = UDim2.new(1, -38, 1, 0), Font = Enum.Font.Gotham, TextColor3 = Color3.fromRGB(255, 255, 255), TextSize = 13, TextTransparency = 0.4, TextXAlignment = Enum.TextXAlignment.Right, Text = "", Visible = not dropdownConfig.Multiple });
                                local dropdownButton = createInstance("TextButton", { BackgroundTransparency = 1, Size = UDim2.new(1, 0, 0, 32), AutoButtonColor = false, ClipsDescendants = true, Text = "" }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 5) }), createInstance("TextLabel", { BackgroundTransparency = 1, Position = UDim2.new(0, 10, 0, 0), Size = UDim2.new(1, -10, 1, 0), Font = Enum.Font.Gotham, TextColor3 = Color3.fromRGB(255, 255, 255), TextSize = 13, TextXAlignment = Enum.TextXAlignment.Left, Text = dropdownConfig.Name }), selectedOptionLabel, dropdownArrowImage });
                                local dropdownContainerButton = createInstance("TextButton", { BackgroundColor3 = Color3.fromRGB(28, 28, 28), Size = UDim2.new(1, 0, 0, 32), Parent = sectionContentFrame, ClipsDescendants = true, Text = "", AutoButtonColor = false }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 5) }), dropdownButton, scrollingFrame, createInstance("Frame", { Size = UDim2.new(1, 0, 0, 1), Position = UDim2.new(0, 0, 0, 32), ClipsDescendants = true, BackgroundColor3 = Color3.fromRGB(50, 50, 50), BackgroundTransparency = 0.4, BorderSizePixel = 0 }) });
                                connectEvent(uiListLayout:GetPropertyChangedSignal("AbsoluteContentSize"), function()
                                    scrollingFrame.CanvasSize = UDim2.new(0, 0, 0, uiListLayout.AbsoluteContentSize.Y);
                                    return ;
                                end);
                                local createDropdownButtons = function(buttonData)
                                    local layoutOrderCounter = 2;
                                    for optionIndex, optionValue in pairsFunction(buttonData) do
                                        local optionButton = createInstance("TextButton", { Parent = scrollingFrame, Size = UDim2.new(1, 0, 0, 26), BackgroundTransparency = 1, ClipsDescendants = true, AutoButtonColor = false, BackgroundColor3 = Color3.fromRGB(36, 36, 36), Text = "", LayoutOrder = layoutOrderCounter }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 5) }), createInstance("TextLabel", { BackgroundTransparency = 1, Position = UDim2.new(0, 10, 0, 0), Size = UDim2.new(1, -10, 1, 0), Font = Enum.Font.Gotham, TextColor3 = Color3.fromRGB(255, 255, 255), TextSize = 13, TextXAlignment = Enum.TextXAlignment.Left, Text = optionValue, Name = "Title" }) });
                                        connectEvent(optionButton.MouseButton1Click, function()
                                            dropdownData:Set(optionValue);
                                            createDraggableIcon(optionButton);
                                            return ;
                                        end);
                                        dropdownData.Buttons[optionValue] = optionButton;
                                        layoutOrderCounter = layoutOrderCounter + 1;
                                    end;
                                    return ;
                                end;
                                local filterButtons = function(filterText)
                                    for buttonText, buttonInstance in pairsFunction(dropdownData.Buttons) do
                                        buttonInstance.Visible = filterText == "" or string.find(string.lower(buttonText), string.lower(filterText), 1, true);
                                    end;
                                    return ;
                                end;
                                connectEvent(searchTextBox:GetPropertyChangedSignal("Text"), function()
                                    filterButtons(searchTextBox.Text);
                                    return ;
                                end);
                                connectEvent(selectAllButton.MouseButton1Click, function()
                                    if dropdownConfig.Multiple then
                                        local selectedOptionsList = {};
                                        local searchTextLower = string.lower(searchTextBox.Text);
                                        for optionIndex, optionText in pairsFunction(dropdownData.Options) do
                                            if searchTextLower == "" or string.find(string.lower(optionText), searchTextLower, 1, true) then
                                                table.insert(selectedOptionsList, optionText);
                                            end;
                                        end;
                                        if dropdownData.SetBulk then
                                            dropdownData:SetBulk(selectedOptionsList);
                                        else
                                            dropdownData.Value = selectedOptionsList;
                                            local selectedMap = {};
                                            for selectedIndex, selectedValue in ipairs(dropdownData.Value) do
                                                selectedMap[selectedValue] = true;
                                            end;
                                            for buttonValue, buttonFrame in pairsFunction(dropdownData.Buttons) do
                                                buttonFrame.BackgroundTransparency = selectedMap[buttonValue] and 0 or 1;
                                                if buttonFrame:FindFirstChild("Title") then
                                                    buttonFrame.Title.TextTransparency = selectedMap[buttonValue] and 0 or 0.4;
                                                end;
                                            end;
                                            dropdownConfig.Callback(dropdownData.Value);
                                        end;
                                        createDraggableIcon(selectAllButton);
                                    end;
                                    return ;
                                end);
                                connectEvent(deselectAllButton.MouseButton1Click, function()
                                    if dropdownConfig.Multiple then
                                        if dropdownData.SetBulk then
                                            dropdownData:SetBulk({});
                                        else
                                            dropdownData.Value = {};
                                            for buttonIndex, button in pairsFunction(dropdownData.Buttons) do
                                                button.BackgroundTransparency = 1;
                                                if button:FindFirstChild("Title") then
                                                    button.Title.TextTransparency = 0.4;
                                                end;
                                            end;
                                            dropdownConfig.Callback(dropdownData.Value);
                                        end;
                                        createDraggableIcon(deselectAllButton);
                                    end;
                                    return ;
                                end);
                                dropdownData.Refresh = function(L_2619, dropdownOptions, shouldClear)
                                    if shouldClear then
                                        for buttonIndex, button in pairsFunction(dropdownData.Buttons) do
                                            button:Destroy();
                                        end;
                                        table.clear(dropdownData.Options);
                                        table.clear(dropdownData.Buttons);
                                    end;
                                    dropdownData.Options = dropdownOptions;
                                    createDropdownButtons(dropdownData.Options);
                                    return ;
                                end;
                                dropdownData.Set = function(L_2624, selectedOption, shouldTriggerCallback2)
                                    if dropdownConfig.Multiple then
                                        if type(dropdownData.Value) ~= "table" then
                                            dropdownData.Value = { dropdownData.Value };
                                        end;
                                        if table.find(dropdownData.Value, selectedOption) then
                                            table.remove(dropdownData.Value, table.find(dropdownData.Value, selectedOption));
                                        elseif #dropdownData.Value < (dropdownConfig.MaxOptions or math.huge) then
                                            table.insert(dropdownData.Value, selectedOption);
                                        end;
                                    else
                                        dropdownData.Value = selectedOption;
                                    end;
                                    local isSelected = dropdownConfig.Multiple and true or table.find(dropdownData.Options, selectedOption);
                                    if dropdownConfig.Multiple then
                                        for index, value in pairsFunction(dropdownData.Value) do
                                            if not table.find(dropdownData.Options, value) then
                                                table.remove(dropdownData.Value, index);
                                            end;
                                        end;
                                        if #dropdownData.Value < 1 then
                                            isSelected = false;
                                        end;
                                    end;
                                    if not isSelected then
                                        dropdownData.Value = dropdownConfig.Multiple and {} or "...";
                                        selectedOptionLabel.Text = "...";
                                        for buttonIndex2, button in pairsFunction(dropdownData.Buttons) do
                                            tweenServiceWrapper:Create(button, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { BackgroundTransparency = 1 }):Play();
                                            tweenServiceWrapper:Create(button.Title, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { TextTransparency = 0.4 }):Play();
                                        end;
                                        return ;
                                    end;
                                    selectedOptionLabel.Text = dropdownConfig.Multiple and table.concat(dropdownData.Value, ", ") or dropdownData.Value;
                                    for buttonIndex, buttonInstance in pairsFunction(dropdownData.Buttons) do
                                        if dropdownConfig.Multiple and table.find(dropdownData.Value, buttonIndex) or not dropdownConfig.Multiple and buttonIndex == selectedOption then
                                            tweenServiceWrapper:Create(buttonInstance, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { BackgroundTransparency = 0 }):Play();
                                            tweenServiceWrapper:Create(buttonInstance.Title, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { TextTransparency = 0 }):Play();
                                        else
                                            tweenServiceWrapper:Create(buttonInstance, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { BackgroundTransparency = 1 }):Play();
                                            tweenServiceWrapper:Create(buttonInstance.Title, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { TextTransparency = 0.4 }):Play();
                                        end;
                                    end;
                                    if not shouldTriggerCallback2 then
                                        return dropdownConfig.Callback(dropdownData.Value);
                                    end;
                                    return ;
                                end;
                                connectEvent(dropdownButton.MouseButton1Click, function()
                                    dropdownData.Toggled = not dropdownData.Toggled;
                                    tweenServiceWrapper:Create(dropdownArrowImage, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Rotation = dropdownData.Toggled and 90 or 0 }):Play();
                                    if dropdownData.Toggled then
                                        searchTextBox.Text = "";
                                        filterButtons("");
                                    end;
                                    if 5 < #dropdownData.Options then
                                        tweenServiceWrapper:Create(dropdownContainerButton, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Size = dropdownData.Toggled and UDim2.new(1, 0, 0, 192 + (dropdownConfig.Multiple and 27 or 0)) or UDim2.new(1, 0, 0, 32) }):Play();
                                    else
                                        tweenServiceWrapper:Create(dropdownContainerButton, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Size = dropdownData.Toggled and UDim2.new(1, 0, 0, uiListLayout.AbsoluteContentSize.Y + 32) or UDim2.new(1, 0, 0, 32) }):Play();
                                    end;
                                    return ;
                                end);
                                dropdownData:Refresh(dropdownData.Options, false);
                                dropdownData:Set(dropdownData.Value, dropdownConfig.IgnoreFirst);
                                return dropdownData;
                            end,
                            AddBind = function(bindConfig)
                                bindConfig.Name = bindConfig.Name or "Bind";
                                bindConfig.Default = bindConfig.Default or Enum.KeyCode.Unknown;
                                bindConfig.Hold = bindConfig.Hold or false;
                                bindConfig.IgnoreFirst = bindConfig.IgnoreFirst or false;
                                bindConfig.Callback = bindConfig.Callback or function()
                                    return ;
                                end;
                                bindConfig.ChangeCallback = bindConfig.ChangeCallback or function()
                                    return ;
                                end;
                                local bindData = { Value = bindConfig.Default, Binding = false, Type = "Bind" };
                                local isActionActive = false;
                                local valueTextLabel = createInstance("TextLabel", { BackgroundTransparency = 1, Position = UDim2.new(0, 10, 0, 0), Size = UDim2.new(1, -20, 1, 0), Font = Enum.Font.Gotham, TextColor3 = Color3.fromRGB(255, 255, 255), TextSize = 13, TextTransparency = 0.4, TextXAlignment = Enum.TextXAlignment.Right, Text = "" });
                                local inputButton = createInstance("TextButton", { BackgroundColor3 = Color3.fromRGB(28, 28, 28), Size = UDim2.new(1, 0, 0, 32), Parent = sectionContentFrame, ClipsDescendants = true, Text = "", AutoButtonColor = false }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 5) }), createInstance("TextLabel", { BackgroundTransparency = 1, Position = UDim2.new(0, 10, 0, 0), Size = UDim2.new(1, -10, 1, 0), Font = Enum.Font.Gotham, TextColor3 = Color3.fromRGB(255, 255, 255), TextSize = 13, TextXAlignment = Enum.TextXAlignment.Left, Text = bindConfig.Name }), valueTextLabel });
                                connectEvent(inputButton.InputEnded, function(inputObject)
                                    if inputObject.UserInputType == Enum.UserInputType.MouseButton1 then
                                        if bindData.Binding then
                                            return ;
                                        end;
                                        bindData.Binding = true;
                                        valueTextLabel.Text = "...";
                                    end;
                                    return ;
                                end);
                                connectEvent(userInputServiceWrapper.InputBegan, function(inputObject)
                                    if userInputServiceWrapper:GetFocusedTextBox() then
                                        return ;
                                    end;
                                    if (inputObject.KeyCode.Name == bindData.Value.Name or inputObject.UserInputType.Name == bindData.Value.Name) and not bindData.Binding then
                                        if bindConfig.Hold then
                                            isActionActive = true;
                                            bindConfig.Callback(isActionActive);
                                        else
                                            bindConfig.Callback();
                                        end;
                                    elseif bindData.Binding then
                                        local keyCode = nil;
                                        pcall(function()
                                            if not table.find(ignoredKeys, inputObject.KeyCode) then
                                                keyCode = inputObject.KeyCode;
                                            end;
                                            return ;
                                        end);
                                        keyCode = keyCode or bindData.Value;
                                        bindData:Set(keyCode);
                                    end;
                                    return ;
                                end);
                                connectEvent(userInputServiceWrapper.InputEnded, function(inputObject)
                                    if (inputObject.KeyCode.Name == bindData.Value.Name or inputObject.UserInputType.Name == bindData.Value.Name) and (bindConfig.Hold and isActionActive) then
                                        isActionActive = false;
                                        bindConfig.Callback(isActionActive);
                                    end;
                                    return ;
                                end);
                                bindData.Set = function(L_2643, inputValue, shouldTriggerCallback3)
                                    bindData.Binding = false;
                                    bindData.Value = inputValue or bindData.Value;
                                    valueTextLabel.Text = bindData.Value.Name;
                                    if not shouldTriggerCallback3 then
                                        bindConfig.ChangeCallback(bindData.Value);
                                    end;
                                    return ;
                                end;
                                bindData:Set(bindConfig.Default, bindConfig.IgnoreFirst);
                                return bindData;
                            end,
                            AddColorpicker = function(unknownTable6)
                                local colorPickerConfig = unknownTable6 or {};
                                colorPickerConfig.Name = colorPickerConfig.Name or "Colorpicker";
                                colorPickerConfig.Default = colorPickerConfig.Default or Color3.fromRGB(255, 255, 255);
                                colorPickerConfig.IgnoreFirst = colorPickerConfig.IgnoreFirst or false;
                                colorPickerConfig.Callback = colorPickerConfig.Callback or function()
                                    return ;
                                end;
                                local hue = 1;
                                local saturation = 1;
                                local valueBrightness = 1;
                                local colorPickerData = { Value = colorPickerConfig.Default, Toggled = false, Type = "Colorpicker" };
                                local saturationBrightnessIndicator = createInstance("ImageLabel", { Size = UDim2.new(0, 18, 0, 18), Position = UDim2.new(select(3, Color3.toHSV(colorPickerData.Value))), ScaleType = Enum.ScaleType.Fit, AnchorPoint = Vector2.new(0.5, 0.5), BackgroundTransparency = 1, Image = "http://www.roblox.com/asset/?id=4805639000" });
                                local hueIndicator = createInstance("ImageLabel", { Size = UDim2.new(0, 18, 0, 18), Position = UDim2.new(0.5, 0, 1 - select(1, Color3.toHSV(colorPickerData.Value))), ScaleType = Enum.ScaleType.Fit, AnchorPoint = Vector2.new(0.5, 0.5), BackgroundTransparency = 1, Image = "http://www.roblox.com/asset/?id=4805639000" });
                                local saturationBrightnessImage = createInstance("ImageLabel", { Size = UDim2.new(1, -25, 1, 0), Visible = false, Image = "rbxassetid://4155801252" }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 5) }), saturationBrightnessIndicator });
                                local hueFrame = createInstance("Frame", { Size = UDim2.new(0, 20, 1, 0), Position = UDim2.new(1, -20, 0, 0), Visible = false }, { createInstance("UIGradient", { Rotation = 270, Color = ColorSequence.new({ ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 4)), ColorSequenceKeypoint.new(0.2, Color3.fromRGB(234, 255, 0)), ColorSequenceKeypoint.new(0.4, Color3.fromRGB(21, 255, 0)), ColorSequenceKeypoint.new(0.6, Color3.fromRGB(0, 255, 255)), ColorSequenceKeypoint.new(0.8, Color3.fromRGB(0, 17, 255)), ColorSequenceKeypoint.new(0.9, Color3.fromRGB(255, 0, 251)), ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 0, 4)) }) }), createInstance("UICorner", { CornerRadius = UDim.new(0, 5) }), hueIndicator });
                                local colorPickerFrame = createInstance("Frame", { Position = UDim2.new(0, 0, 0, 32), Size = UDim2.new(1, 0, 1, -32), BackgroundTransparency = 1, ClipsDescendants = true }, { hueFrame, saturationBrightnessImage, createInstance("UIPadding", { PaddingLeft = UDim.new(0, 35), PaddingRight = UDim.new(0, 35), PaddingBottom = UDim.new(0, 8), PaddingTop = UDim.new(0, 4) }) });
                                local colorPreviewFrame = createInstance("Frame", { AnchorPoint = Vector2.new(1, 0.5), BackgroundColor3 = Color3.fromRGB(255, 255, 255), Position = UDim2.new(1, -10, 0.5, 0), Size = UDim2.new(0, 20, 0, 20) }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 5) }), createInstance("UIStroke", { Color = Color3.fromRGB(55, 55, 55) }) });
                                local colorPickerButton = createInstance("TextButton", { BackgroundTransparency = 1, Size = UDim2.new(1, 0, 0, 32), AutoButtonColor = false, ClipsDescendants = true, Text = "" }, { createInstance("TextLabel", { BackgroundTransparency = 1, Position = UDim2.new(0, 10, 0, 0), Size = UDim2.new(1, -10, 1, 0), Font = Enum.Font.Gotham, TextColor3 = Color3.fromRGB(255, 255, 255), TextSize = 13, TextXAlignment = Enum.TextXAlignment.Left, Text = colorPickerConfig.Name }), colorPreviewFrame });
                                local colorPickerContainer = createInstance("TextButton", { BackgroundColor3 = Color3.fromRGB(28, 28, 28), Size = UDim2.new(1, 0, 0, 32), Parent = sectionContentFrame, AutoButtonColor = false, ClipsDescendants = true, Text = "" }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 5) }), colorPickerButton, colorPickerFrame });
                                local updateColor = function()
                                    colorPreviewFrame.BackgroundColor3 = Color3.fromHSV(hue, saturation, valueBrightness);
                                    saturationBrightnessImage.BackgroundColor3 = Color3.fromHSV(hue, 1, 1);
                                    colorPickerData.Value = colorPreviewFrame.BackgroundColor3;
                                    colorPickerConfig.Callback(colorPreviewFrame.BackgroundColor3);
                                    return ;
                                end;
                                connectEvent(colorPickerButton.MouseButton1Click, function()
                                    colorPickerData.Toggled = not colorPickerData.Toggled;
                                    tweenServiceWrapper:Create(colorPickerContainer, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Size = colorPickerData.Toggled and UDim2.new(1, 0, 0, 142) or UDim2.new(1, 0, 0, 32) }):Play();
                                    saturationBrightnessImage.Visible = colorPickerData.Toggled;
                                    hueFrame.Visible = colorPickerData.Toggled;
                                    return ;
                                end);
                                hue = 1 - math.clamp(hueIndicator.AbsolutePosition.Y - hueFrame.AbsolutePosition.Y, 0, hueFrame.AbsoluteSize.Y) / hueFrame.AbsoluteSize.Y;
                                saturation = math.clamp(saturationBrightnessIndicator.AbsolutePosition.X - saturationBrightnessImage.AbsolutePosition.X, 0, saturationBrightnessImage.AbsoluteSize.X) / saturationBrightnessImage.AbsoluteSize.X;
                                valueBrightness = 1 - math.clamp(saturationBrightnessIndicator.AbsolutePosition.Y - saturationBrightnessImage.AbsolutePosition.Y, 0, saturationBrightnessImage.AbsoluteSize.Y) / saturationBrightnessImage.AbsoluteSize.Y;
                                connectEvent(saturationBrightnessImage.InputBegan, function(inputObject)
                                    if inputObject.UserInputType == Enum.UserInputType.MouseButton1 then
                                        if ColorInput then
                                            ColorInput:Disconnect();
                                        end;
                                        ColorInput = connectEvent(runServiceWrapper.RenderStepped, function()
                                            local saturationValue = math.clamp(mouse.X - saturationBrightnessImage.AbsolutePosition.X, 0, saturationBrightnessImage.AbsoluteSize.X) / saturationBrightnessImage.AbsoluteSize.X;
                                            local brightnessValue = math.clamp(mouse.Y - saturationBrightnessImage.AbsolutePosition.Y, 0, saturationBrightnessImage.AbsoluteSize.Y) / saturationBrightnessImage.AbsoluteSize.Y;
                                            saturationBrightnessIndicator.Position = UDim2.new(saturationValue, 0, brightnessValue, 0);
                                            saturation = saturationValue;
                                            valueBrightness = 1 - brightnessValue;
                                            updateColor();
                                            return ;
                                        end);
                                    end;
                                    return ;
                                end);
                                connectEvent(saturationBrightnessImage.InputEnded, function(inputObject)
                                    if inputObject.UserInputType == Enum.UserInputType.MouseButton1 and ColorInput then
                                        ColorInput:Disconnect();
                                    end;
                                    return ;
                                end);
                                connectEvent(hueFrame.InputBegan, function(inputObject)
                                    if inputObject.UserInputType == Enum.UserInputType.MouseButton1 then
                                        if HueInput then
                                            HueInput:Disconnect();
                                        end;
                                        HueInput = connectEvent(runServiceWrapper.RenderStepped, function()
                                            local hueValue = math.clamp(mouse.Y - hueFrame.AbsolutePosition.Y, 0, hueFrame.AbsoluteSize.Y) / hueFrame.AbsoluteSize.Y;
                                            hueIndicator.Position = UDim2.new(0.5, 0, hueValue, 0);
                                            hue = 1 - hueValue;
                                            updateColor();
                                            return ;
                                        end);
                                    end;
                                    return ;
                                end);
                                connectEvent(hueFrame.InputEnded, function(inputObject2)
                                    if inputObject2.UserInputType == Enum.UserInputType.MouseButton1 and HueInput then
                                        HueInput:Disconnect();
                                    end;
                                    return ;
                                end);
                                colorPickerData.Set = function(L_2668, colorValue, shouldTriggerCallback4)
                                    local hue, saturation, value = colorValue:ToHSV();
                                    hue = hue;
                                    saturation = saturation;
                                    valueBrightness = value;
                                    colorPickerData.Value = colorValue;
                                    colorPreviewFrame.BackgroundColor3 = colorPickerData.Value;
                                    saturationBrightnessImage.BackgroundColor3 = Color3.fromHSV(hue, 1, 1);
                                    local invertedHue = 1 - hue;
                                    hueIndicator.Position = UDim2.new(0.5, 0, invertedHue, 0);
                                    local xPositionOffset = saturation;
                                    local yPositionOffset = 1 - valueBrightness;
                                    saturationBrightnessIndicator.Position = UDim2.new(xPositionOffset, 0, yPositionOffset, 0);
                                    if not shouldTriggerCallback4 then
                                        colorPickerConfig.Callback(colorPickerData.Value);
                                    end;
                                    return ;
                                end;
                                colorPickerData:Set(colorPickerConfig.Default, colorPickerConfig.IgnoreFirst);
                                return colorPickerData;
                            end,
                            AddTextbox = function(unknownTable7)
                                local textBoxConfig = unknownTable7 or {};
                                textBoxConfig.Name = textBoxConfig.Name or "Textbox";
                                textBoxConfig.Default = textBoxConfig.Default or "";
                                textBoxConfig.PlaceholderText = textBoxConfig.PlaceholderText or "Write here...";
                                textBoxConfig.ClearTextOnFocusLost = textBoxConfig.ClearTextOnFocusLost or false;
                                textBoxConfig.IgnoreFirst = textBoxConfig.IgnoreFirst or false;
                                textBoxConfig.Callback = textBoxConfig.Callback or function()
                                    return ;
                                end;
                                local textBoxValue = { Value = textBoxConfig.Default, Type = "Textbox" };
                                local textBox = createInstance("TextBox", { AnchorPoint = Vector2.new(1, 0.5), BackgroundColor3 = Color3.fromRGB(36, 36, 36), Position = UDim2.new(1, -10, 0.5, 0), Size = UDim2.new(0, 20, 0, 20), TextColor3 = Color3.fromRGB(255, 255, 255), PlaceholderColor3 = Color3.fromRGB(210, 210, 210), PlaceholderText = textBoxConfig.PlaceholderText, TextXAlignment = Enum.TextXAlignment.Right, Text = "", Font = Enum.Font.Gotham, TextSize = 13, ClearTextOnFocus = false }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 5) }), createInstance("UIPadding", { PaddingLeft = UDim.new(0, 5), PaddingRight = UDim.new(0, 5) }) });
                                local focusButton = createInstance("TextButton", { BackgroundColor3 = Color3.fromRGB(28, 28, 28), Size = UDim2.new(1, 0, 0, 32), Parent = sectionContentFrame, AutoButtonColor = false, ClipsDescendants = true, Text = "" }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 5) }), createInstance("TextLabel", { BackgroundTransparency = 1, Position = UDim2.new(0, 10, 0, 0), Size = UDim2.new(1, -10, 1, 0), Font = Enum.Font.Gotham, TextColor3 = Color3.fromRGB(255, 255, 255), TextSize = 13, TextXAlignment = Enum.TextXAlignment.Left, Text = textBoxConfig.Name }), textBox });
                                connectEvent(focusButton.MouseButton1Click, function()
                                    textBox:CaptureFocus();
                                    return ;
                                end);
                                connectEvent(textBox.FocusLost, function()
                                    textBoxValue.Value = textBox.Text;
                                    textBoxConfig.Callback(textBoxValue.Value);
                                    if textBoxConfig.ClearTextOnFocusLost then
                                        textBox.Text = "";
                                        textBoxValue.Value = "";
                                    end;
                                    return ;
                                end);
                                connectEvent(textBox:GetPropertyChangedSignal("Text"), function()
                                    textBox.Size = UDim2.new(0, textBox.TextBounds.X + 10, 0, 20);
                                    return ;
                                end);
                                textBox.Size = UDim2.new(0, textBox.TextBounds.X + 10, 0, 20);
                                textBoxValue.Set = function(L_2682, inputText, shouldTriggerCallback5)
                                    textBox.Text = inputText;
                                    textBoxValue.Value = inputText;
                                    if not shouldTriggerCallback5 then
                                        textBoxConfig.Callback(textBox.Text);
                                    end;
                                    return ;
                                end;
                                textBoxValue:Set(textBoxConfig.Default, textBoxConfig.IgnoreFirst);
                                return textBoxValue;
                            end,
                            AddParagraph = function(unknownTable8)
                                local configuration = unknownTable8 or {};
                                configuration.Description = configuration.Description or "Description";
                                local configurationSet = {};
                                local descriptionFrame = createInstance("Frame", { BackgroundColor3 = Color3.fromRGB(28, 28, 28), Size = UDim2.new(1, 0, 0, 0), Parent = sectionContentFrame, ClipsDescendants = true, AutomaticSize = Enum.AutomaticSize.Y }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 5) }), createInstance("UIPadding", { PaddingBottom = UDim.new(0, 10), PaddingLeft = UDim.new(0, 10), PaddingRight = UDim.new(0, 10), PaddingTop = UDim.new(0, 10) }) });
                                local descriptionLabel = createInstance("TextLabel", { Parent = descriptionFrame, BackgroundTransparency = 1, Position = UDim2.new(0, 0, 0, 0), Size = UDim2.new(1, -10, 0, 0), Font = Enum.Font.Gotham, TextColor3 = Color3.fromRGB(255, 255, 255), TextSize = 13, TextXAlignment = Enum.TextXAlignment.Left, Text = configuration.Description, AutomaticSize = Enum.AutomaticSize.Y, TextWrapped = true, RichText = true });
                                configurationSet.Set = function(L_2690, data)
                                    data.Description = data.Description or configuration.Description;
                                    descriptionLabel.Text = data.Description;
                                    return ;
                                end;
                                return configurationSet;
                            end
                        };
                    end
                };
            end
        };
    end;
    connectionManager.CreateModal = function(configuration2)
        local modalConfig = configuration2 or {};
        modalConfig.Title = modalConfig.Title or "Modal";
        modalConfig.Text = modalConfig.Text or "Text";
        modalConfig.YesText = modalConfig.YesText or "Yes";
        modalConfig.NoText = modalConfig.NoText or "Nah, Continue";
        modalConfig.YesCallback = modalConfig.YesCallback or function()
            return ;
        end;
        modalConfig.NoCallback = modalConfig.NoCallback or function()
            return ;
        end;
        local modal = {};
        local isInitialized = false;
        local modalBackgroundButton = createInstance("TextButton", { Text = "", AutoButtonColor = false, BackgroundColor3 = Color3.fromRGB(0, 0, 0), BackgroundTransparency = 1, BorderColor3 = Color3.fromRGB(27, 42, 53), BorderSizePixel = 0, Position = UDim2.fromOffset(0, 38), Size = UDim2.new(1, 0, 1, -38), Parent = connectionManager.MainFrame, Visible = false, ZIndex = 10 }, { createInstance("CanvasGroup", { AnchorPoint = Vector2.new(0.5, 0.5), BackgroundColor3 = Color3.fromRGB(25, 25, 25), BorderColor3 = Color3.fromRGB(0, 0, 0), BorderSizePixel = 0, Position = UDim2.fromScale(0.5, 0.5), Size = UDim2.fromOffset(380, 300), GroupTransparency = 1, Name = "ModalContainer" }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 5) }), createInstance("ImageLabel", { Image = "rbxassetid://1316045217", ImageColor3 = Color3.fromRGB(25, 25, 25), ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(10, 10, 118, 118), AnchorPoint = Vector2.new(0.5, 0.5), BackgroundTransparency = 1, BorderColor3 = Color3.fromRGB(27, 42, 53), Position = UDim2.fromOffset(181, 287), Size = UDim2.fromOffset(390, 100), ZIndex = 3, Name = "Shadow" }), createInstance("ImageLabel", { Image = "rbxassetid://1316045217", ImageColor3 = Color3.fromRGB(25, 25, 25), ScaleType = Enum.ScaleType.Slice, SliceCenter = Rect.new(10, 10, 118, 118), AnchorPoint = Vector2.new(0.5, 0.5), BackgroundTransparency = 1, BorderColor3 = Color3.fromRGB(27, 42, 53), Position = UDim2.fromOffset(187, 27), Size = UDim2.fromOffset(379, 57), ZIndex = 2, Name = "Shadow1" }), createInstance("Frame", { BackgroundColor3 = Color3.fromRGB(27, 27, 27), BorderColor3 = Color3.fromRGB(27, 42, 53), Position = UDim2.fromOffset(0, -1), Size = UDim2.new(1, 0, 0, 38), ZIndex = 2, Name = "TopBar" }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 5) }), createInstance("Frame", { BackgroundColor3 = Color3.fromRGB(50, 50, 50), BackgroundTransparency = 0.4, BorderColor3 = Color3.fromRGB(27, 42, 53), BorderSizePixel = 0, Position = UDim2.fromScale(0, 1), Size = UDim2.new(1, 0, 0, 1), ZIndex = 2 }), createInstance("TextLabel", { FontFace = Font.new("rbxasset://fonts/families/GothamSSm.json"), RichText = true, Text = modalConfig.Title, TextColor3 = Color3.fromRGB(180, 180, 180), TextSize = 14, TextXAlignment = Enum.TextXAlignment.Left, BackgroundTransparency = 1, BorderColor3 = Color3.fromRGB(27, 42, 53), Size = UDim2.fromScale(1, 1), ZIndex = 2, Name = "TitleLabel" }, { createInstance("UIPadding", { PaddingLeft = UDim.new(0, 15) }) }), createInstance("TextButton", { Text = "", BackgroundTransparency = 1, BorderColor3 = Color3.fromRGB(27, 42, 53), Position = UDim2.new(1, -34, 0, 4), Size = UDim2.new(1, -8, 1, -8), SizeConstraint = Enum.SizeConstraint.RelativeYY, ZIndex = 2, Name = "CloseButton" }, { createInstance("Frame", { AnchorPoint = Vector2.new(0.5, 0.5), BackgroundColor3 = Color3.fromRGB(38, 38, 38), BackgroundTransparency = 1, BorderColor3 = Color3.fromRGB(27, 42, 53), Position = UDim2.fromScale(0.5, 0.5), Size = UDim2.fromScale(0.8, 0.8), ZIndex = 2, Name = "Hover" }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 8) }) }), createInstance("ImageLabel", { Image = "rbxassetid://6235536018", ImageColor3 = Color3.fromRGB(180, 180, 180), ScaleType = Enum.ScaleType.Crop, BackgroundTransparency = 1, BorderColor3 = Color3.fromRGB(27, 42, 53), Position = UDim2.new(0.5, -9, 0.5, -9), Size = UDim2.fromOffset(18, 18), ZIndex = 2, Name = "Icon" }) }) }), createInstance("ScrollingFrame", { AutomaticCanvasSize = Enum.AutomaticSize.Y, CanvasSize = UDim2.new(), ScrollBarImageColor3 = Color3.fromRGB(50, 50, 50), ScrollBarThickness = 2, AnchorPoint = Vector2.new(0.5, 1), BackgroundTransparency = 1, BorderColor3 = Color3.fromRGB(27, 42, 53), BorderSizePixel = 0, Position = UDim2.fromScale(0.5, 1), Size = UDim2.new(1, -1, 1, -40), Name = "Content" }, { createInstance("UIPadding", { PaddingBottom = UDim.new(0, 60), PaddingLeft = UDim.new(0, 10), PaddingRight = UDim.new(0, 10), PaddingTop = UDim.new(0, 13) }), createInstance("UIListLayout", { Padding = UDim.new(0, 5) }), createInstance("TextLabel", { FontFace = Font.new("rbxasset://fonts/families/GothamSSm.json"), RichText = true, Text = modalConfig.Text, TextColor3 = Color3.fromRGB(200, 200, 200), TextSize = 14, TextWrapped = true, TextXAlignment = Enum.TextXAlignment.Left, TextYAlignment = Enum.TextYAlignment.Top, AutomaticSize = Enum.AutomaticSize.Y, BackgroundColor3 = Color3.fromRGB(28, 28, 28), BorderColor3 = Color3.fromRGB(0, 0, 0), BorderSizePixel = 0, Size = UDim2.fromScale(1, 0), Name = "TextContent" }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 5) }), createInstance("UIPadding", { PaddingBottom = UDim.new(0, 10), PaddingLeft = UDim.new(0, 10), PaddingRight = UDim.new(0, 10), PaddingTop = UDim.new(0, 10) }) }) }), createInstance("TextButton", { FontFace = Font.new("rbxasset://fonts/families/SourceSansPro.json"), Text = "", TextColor3 = Color3.fromRGB(0, 0, 0), TextSize = 14, AutoButtonColor = false, AnchorPoint = Vector2.new(0.5, 1), BackgroundColor3 = Color3.fromRGB(28, 28, 28), BackgroundTransparency = 0.1, BorderColor3 = Color3.fromRGB(0, 0, 0), BorderSizePixel = 0, Position = UDim2.new(0.5, 0, 1, -5), Size = UDim2.new(1, -20, 0, 45), ZIndex = 3, Name = "ButtonsContainer" }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 5) }), createInstance("UIPadding", { PaddingBottom = UDim.new(0, 5), PaddingLeft = UDim.new(0, 10), PaddingRight = UDim.new(0, 10), PaddingTop = UDim.new(0, 5) }), createInstance("UIListLayout", { Padding = UDim.new(0, 1), FillDirection = Enum.FillDirection.Horizontal, HorizontalAlignment = Enum.HorizontalAlignment.Center }), createInstance("TextButton", { FontFace = Font.new("rbxasset://fonts/families/GothamSSm.json"), Text = modalConfig.NoText, TextColor3 = Color3.fromRGB(160, 160, 160), TextSize = 14, AutoButtonColor = false, BackgroundColor3 = Color3.fromRGB(28, 28, 28), BorderColor3 = Color3.fromRGB(0, 0, 0), BorderSizePixel = 0, ClipsDescendants = true, Size = UDim2.fromScale(0.5, 1), ZIndex = 3, Name = "NoButton" }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 5) }) }), createInstance("Frame", { BackgroundColor3 = Color3.fromRGB(255, 255, 255), BackgroundTransparency = 0.93, BorderColor3 = Color3.fromRGB(0, 0, 0), BorderSizePixel = 0, Size = UDim2.new(0, 1, 1, 0), ZIndex = 3, Name = "Divider" }), createInstance("TextButton", { FontFace = Font.new("rbxasset://fonts/families/GothamSSm.json"), Text = modalConfig.YesText, TextColor3 = Color3.fromRGB(160, 160, 160), TextSize = 14, AutoButtonColor = false, BackgroundColor3 = Color3.fromRGB(28, 28, 28), BorderColor3 = Color3.fromRGB(0, 0, 0), BorderSizePixel = 0, ClipsDescendants = true, Size = UDim2.fromScale(0.5, 1), ZIndex = 3, Name = "YesButton" }, { createInstance("UICorner", { CornerRadius = UDim.new(0, 5) }) }) }) }) });
        local modalContainer = modalBackgroundButton.ModalContainer;
        local closeButton = modalContainer.TopBar.CloseButton;
        local yesButton = modalContainer.ButtonsContainer.YesButton;
        local noButton = modalContainer.ButtonsContainer.NoButton;
        local textContentLabel = modalContainer.Content.TextContent;
        local titleLabel = modalContainer.TopBar.TitleLabel;
        connectEvent(closeButton.MouseEnter, function()
            tweenServiceWrapper:Create(closeButton.Hover, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { Size = UDim2.new(1, 0, 1, 0), BackgroundTransparency = 0 }):Play();
            tweenServiceWrapper:Create(closeButton.Icon, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { ImageColor3 = Color3.fromRGB(255, 0, 68) }):Play();
            return ;
        end);
        connectEvent(closeButton.MouseLeave, function()
            tweenServiceWrapper:Create(closeButton.Hover, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { Size = UDim2.new(0.8, 0, 0.8, 0), BackgroundTransparency = 1 }):Play();
            tweenServiceWrapper:Create(closeButton.Icon, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { ImageColor3 = Color3.fromRGB(180, 180, 180) }):Play();
            return ;
        end);
        connectEvent(yesButton.MouseEnter, function()
            tweenServiceWrapper:Create(yesButton, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { BackgroundColor3 = Color3.fromRGB(30, 30, 30), TextColor3 = Color3.fromRGB(255, 255, 255) }):Play();
            return ;
        end);
        connectEvent(yesButton.MouseLeave, function()
            tweenServiceWrapper:Create(yesButton, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { BackgroundColor3 = Color3.fromRGB(28, 28, 28), TextColor3 = Color3.fromRGB(160, 160, 160) }):Play();
            return ;
        end);
        connectEvent(noButton.MouseEnter, function()
            tweenServiceWrapper:Create(noButton, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { BackgroundColor3 = Color3.fromRGB(30, 30, 30), TextColor3 = Color3.fromRGB(255, 255, 255) }):Play();
            return ;
        end);
        connectEvent(noButton.MouseLeave, function()
            tweenServiceWrapper:Create(noButton, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { BackgroundColor3 = Color3.fromRGB(28, 28, 28), TextColor3 = Color3.fromRGB(160, 160, 160) }):Play();
            return ;
        end);
        connectEvent(closeButton.MouseButton1Click, function()
            modal:Hide();
            return ;
        end);
        connectEvent(yesButton.MouseButton1Click, function()
            modalConfig.YesCallback();
            modal:Hide();
            return ;
        end);
        connectEvent(noButton.MouseButton1Click, function()
            modalConfig.NoCallback();
            modal:Hide();
            return ;
        end);
        connectEvent(modalBackgroundButton.MouseButton1Click, function()
            modal:Hide();
            return ;
        end);
        connectEvent(modalContainer.MouseButton1Click, function()
            return ;
        end);
        modal.Show = function(L_2703)
            if isInitialized then
                return ;
            end;
            isInitialized = true;
            modalBackgroundButton.Visible = true;
            tweenServiceWrapper:Create(modalBackgroundButton, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { BackgroundTransparency = 0.85 }):Play();
            modalContainer.GroupTransparency = 1;
            modalContainer.Size = UDim2.fromOffset(320, 260);
            tweenServiceWrapper:Create(modalContainer, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { GroupTransparency = 0, Size = UDim2.fromOffset(380, 300) }):Play();
            return ;
        end;
        modal.Hide = function(L_2704)
            if not isInitialized then
                return ;
            end;
            isInitialized = false;
            tweenServiceWrapper:Create(modalBackgroundButton, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { BackgroundTransparency = 1 }):Play();
            tweenServiceWrapper:Create(modalContainer, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { GroupTransparency = 1, Size = UDim2.fromOffset(320, 260) }):Play();
            wait(0.25);
            modalBackgroundButton.Visible = false;
            return ;
        end;
        modal.SetTitle = function(L_2705, textValue)
            titleLabel.Text = textValue;
            return ;
        end;
        modal.SetText = function(L_2707, textValue)
            textContentLabel.Text = textValue;
            return ;
        end;
        modal.SetButtons = function(L_2709, textString, textValue)
            if textString then
                yesButton.Text = textString;
            end;
            if textValue then
                noButton.Text = textValue;
            end;
            return ;
        end;
        return modal;
    end;
    return connectionManager;
end);
createInstance("LibraryWrapper", "Folder", "rbxts-bundle-example.LKHUB.Library.LibraryWrapper", "rbxts-bundle-example.LKHUB.Library");
registerModule("LibraryWrapper", "ModuleScript", "rbxts-bundle-example.LKHUB.Library.LibraryWrapper.LibraryWrapper", "rbxts-bundle-example.LKHUB.Library.LibraryWrapper", function()
    local libraryWrapper = getModuleGlobals("rbxts-bundle-example.LKHUB.Library.LibraryWrapper.LibraryWrapper");
    local scriptReference2 = libraryWrapper.script;
    local requireFunction2 = libraryWrapper.require;
    local unknownValue6 = nil;
    local LibraryTab = setmetatableFunction({}, {
        __tostring = function()
            return "LibraryTab";
        end
    });
    LibraryTab.__index = LibraryTab;
    LibraryTab.new = function(...)
        local newObject = setmetatableFunction({}, LibraryTab);
        return newObject:constructor(...) or newObject;
    end;
    LibraryTab.constructor = function(self, tabContainer, tabName)
        self.Sections = {};
        self.Parent = tabContainer;
        self.Instance = tabContainer.Instance.AddTab(tabName);
        self.LibraryMain = tabContainer;
        tabContainer.Tabs[tabName] = self;
        return ;
    end;
    local LibraryButton = nil;
    local LibraryToggle = nil;
    local LibrarySlider = nil;
    local LibraryRangeSlider = nil;
    local LibraryDropdown = nil;
    local LibraryBind = nil;
    local LibraryColorpicker = nil;
    local LibraryTextbox = nil;
    local LibraryParagraph = nil;
    local unknownValue7 = nil;
    local LibrarySection = setmetatableFunction({}, {
        __tostring = function()
            return "LibrarySection";
        end
    });
    LibrarySection.__index = LibrarySection;
    LibrarySection.new = function(...)
        local newSectionObject = setmetatableFunction({}, LibrarySection);
        return newSectionObject:constructor(...) or newSectionObject;
    end;
    LibrarySection.constructor = function(section, sectionContainer, sectionName)
        section.Objects = {};
        section.Parent = sectionContainer;
        section.Instance = sectionContainer.Instance.AddSection(sectionName);
        section.LibraryMain = sectionContainer.LibraryMain;
        sectionContainer.Sections[sectionName] = section;
        return ;
    end;
    LibrarySection.AddButton = function(parentObject, unknownValue8)
        local newObject = LibraryButton.new(parentObject, unknownValue8);
        local objectsList = parentObject.Objects;
        table.insert(objectsList, newObject);
        return newObject;
    end;
    LibrarySection.AddToggle = function(parentObject2, unknownValue9)
        local newObject2 = LibraryToggle.new(parentObject2, unknownValue9);
        local objectsList2 = parentObject2.Objects;
        table.insert(objectsList2, newObject2);
        return newObject2;
    end;
    LibrarySection.AddSlider = function(parentObject3, unknownValue10)
        local newObject3 = LibrarySlider.new(parentObject3, unknownValue10);
        local objectsList3 = parentObject3.Objects;
        table.insert(objectsList3, newObject3);
        return newObject3;
    end;
    LibrarySection.AddRangeSlider = function(parentObject4, unknownValue11)
        local newObject4 = LibraryRangeSlider.new(parentObject4, unknownValue11);
        local objectsList4 = parentObject4.Objects;
        table.insert(objectsList4, newObject4);
        return newObject4;
    end;
    LibrarySection.AddDropdown = function(parentObject5, unknownValue12)
        local newObject5 = LibraryDropdown.new(parentObject5, unknownValue12);
        local objectsList5 = parentObject5.Objects;
        table.insert(objectsList5, newObject5);
        return newObject5;
    end;
    LibrarySection.AddBind = function(parentObject6, unknownValue13)
        local newObject6 = LibraryBind.new(parentObject6, unknownValue13);
        local objectsList6 = parentObject6.Objects;
        table.insert(objectsList6, newObject6);
        return newObject6;
    end;
    LibrarySection.AddColorpicker = function(parentColorpicker, unknownValue14)
        local newColorpicker = LibraryColorpicker.new(parentColorpicker, unknownValue14);
        local objectsList7 = parentColorpicker.Objects;
        table.insert(objectsList7, newColorpicker);
        return newColorpicker;
    end;
    LibrarySection.AddTextbox = function(parentTextbox, unknownValue15)
        local newTextbox = LibraryTextbox.new(parentTextbox, unknownValue15);
        local objectsList8 = parentTextbox.Objects;
        table.insert(objectsList8, newTextbox);
        return newTextbox;
    end;
    LibrarySection.AddParagraph = function(parentParagraph, unknownValue16)
        local newParagraph = LibraryParagraph.new(parentParagraph, unknownValue16);
        local objectsList9 = parentParagraph.Objects;
        table.insert(objectsList9, newParagraph);
        return newParagraph;
    end;
    LibraryButton = setmetatableFunction({}, {
        __tostring = function()
            return "LibraryButton";
        end
    });
    LibraryButton.__index = LibraryButton;
    LibraryButton.new = function(...)
        local newObject2 = setmetatableFunction({}, LibraryButton);
        return newObject2:constructor(...) or newObject2;
    end;
    LibraryButton.constructor = function(button, parent, buttonName)
        button.Parent = parent;
        button.Instance = parent.Instance.AddButton(buttonName);
        return ;
    end;
    LibraryButton.Set = function(instanceSetter, setValue)
        return instanceSetter.Instance:Set(setValue);
    end;
    LibraryToggle = setmetatableFunction({}, {
        __tostring = function()
            return "LibraryToggle";
        end
    });
    LibraryToggle.__index = LibraryToggle;
    LibraryToggle.new = function(...)
        local newObject3 = setmetatableFunction({}, LibraryToggle);
        return newObject3:constructor(...) or newObject3;
    end;
    LibraryToggle.constructor = function(toggle, parent2, toggleConfig)
        toggle.Parent = parent2;
        toggle.ToggleConfig = table.clone(toggleConfig);
        local selfToggle = toggle;
        toggleConfig.Callback = function(toggleValue)
            selfToggle.Parent.LibraryMain:Save();
            if selfToggle.ToggleConfig.Callback then
                selfToggle.ToggleConfig.Callback(toggleValue);
            end;
            return ;
        end;
        toggle.Instance = parent2.Instance.AddToggle(toggleConfig);
        return ;
    end;
    LibraryToggle.Set = function(instanceWrapper, value1, valueToSet)
        return instanceWrapper.Instance:Set(value1, valueToSet);
    end;
    LibraryToggle._Save = function(toggleConfig, configTable)
        configTable[("Toggle/%*"):format(toggleConfig.ToggleConfig.Name)] = toggleConfig.Instance.Value;
        return ;
    end;
    LibraryToggle._Load = function(toggleConfig2, dataStoreValues)
        local savedToggleValue = dataStoreValues[("Toggle/%*"):format(toggleConfig2.ToggleConfig.Name)];
        if savedToggleValue ~= nil then
            toggleConfig2:Set(savedToggleValue);
        end;
        return ;
    end;
    LibrarySlider = setmetatableFunction({}, {
        __tostring = function()
            return "LibrarySlider";
        end
    });
    LibrarySlider.__index = LibrarySlider;
    LibrarySlider.new = function(...)
        local newObject4 = setmetatableFunction({}, LibrarySlider);
        return newObject4:constructor(...) or newObject4;
    end;
    LibrarySlider.constructor = function(slider, parent3, sliderConfigData)
        slider.Parent = parent3;
        slider.SliderConfig = table.clone(sliderConfigData);
        slider.Instance = parent3.Instance.AddSlider(sliderConfigData);
        return ;
    end;
    LibrarySlider.Set = function(instanceWrapper2, value2, sliderValue)
        return instanceWrapper2.Instance:Set(value2, sliderValue);
    end;
    LibrarySlider._Save = function(sliderConfig, sliderConfigTable)
        sliderConfigTable[("Slider/%*"):format(sliderConfig.SliderConfig.Name)] = sliderConfig.Instance.Value;
        return ;
    end;
    LibrarySlider._Load = function(sliderConfig3, dataStoreValues2)
        local savedSliderValue = dataStoreValues2[("Slider/%*"):format(sliderConfig3.SliderConfig.Name)];
        if savedSliderValue ~= nil then
            sliderConfig3:Set(savedSliderValue);
        end;
        return ;
    end;
    LibraryRangeSlider = setmetatableFunction({}, {
        __tostring = function()
            return "LibraryRangeSlider";
        end
    });
    LibraryRangeSlider.__index = LibraryRangeSlider;
    LibraryRangeSlider.new = function(...)
        local newObject5 = setmetatableFunction({}, LibraryRangeSlider);
        return newObject5:constructor(...) or newObject5;
    end;
    LibraryRangeSlider.constructor = function(rangeSlider, parent4, rangeSliderConfigData)
        rangeSlider.Parent = parent4;
        rangeSlider.RangeSliderConfig = table.clone(rangeSliderConfigData);
        rangeSlider.Instance = parent4.Instance.AddRangeSlider(rangeSliderConfigData);
        return ;
    end;
    LibraryRangeSlider.Set = function(instanceWrapper3, minValue, minValue, unknownValue17)
        return instanceWrapper3.Instance:Set(minValue, minValue, unknownValue17);
    end;
    LibraryRangeSlider._Save = function(rangeSliderConfig, rangeSliderConfigTable)
        rangeSliderConfigTable[("RangeSlider/%*"):format(rangeSliderConfig.RangeSliderConfig.Name)] = { rangeSliderConfig.Instance.MinValue, rangeSliderConfig.Instance.MaxValue };
        return ;
    end;
    LibraryRangeSlider._Load = function(rangeSliderInstance, dataStoreValues3)
        local savedRangeSliderValue = dataStoreValues3[("RangeSlider/%*"):format(rangeSliderInstance.RangeSliderConfig.Name)];
        if savedRangeSliderValue ~= nil then
            local rangeValues = savedRangeSliderValue;
            local savedMinValue = rangeValues[1];
            local savedMaxValue = rangeValues[2];
            rangeSliderInstance.Instance.MinValue = savedMinValue;
            rangeSliderInstance.Instance.MaxValue = savedMaxValue;
            rangeSliderInstance:Set(savedMinValue, savedMaxValue, true);
        end;
        return ;
    end;
    LibraryDropdown = setmetatableFunction({}, {
        __tostring = function()
            return "LibraryDropdown";
        end
    });
    LibraryDropdown.__index = LibraryDropdown;
    LibraryDropdown.new = function(...)
        local newObject6 = setmetatableFunction({}, LibraryDropdown);
        return newObject6:constructor(...) or newObject6;
    end;
    LibraryDropdown.constructor = function(dropdown, parent5, dropdownConfig)
        dropdown.Parent = parent5;
        dropdown.DropdownConfig = table.clone(dropdownConfig);
        local selfDropdown = dropdown;
        dropdownConfig.Callback = function(dropdownValue)
            selfDropdown.Parent.LibraryMain:Save();
            if selfDropdown.DropdownConfig.Callback then
                selfDropdown.DropdownConfig.Callback(dropdownValue);
            end;
            return ;
        end;
        dropdown.Instance = parent5.Instance.AddDropdown(dropdownConfig);
        return ;
    end;
    LibraryDropdown.Set = function(instanceWrapper4, value3, valueToSet2)
        return instanceWrapper4.Instance:Set(value3, valueToSet2);
    end;
    LibraryDropdown.SetChoices = function(instanceWrapper5, value4, refreshValue)
        return instanceWrapper5.Instance:Refresh(value4, refreshValue);
    end;
    LibraryDropdown._Save = function(dropdownConfig, dropdownConfigTable)
        dropdownConfigTable[("Dropdown/%*"):format(dropdownConfig.DropdownConfig.Name)] = dropdownConfig.Instance.Value;
        return ;
    end;
    LibraryDropdown._Load = function(dropdownConfig2, dataStoreValues4)
        local savedDropdownValue = dataStoreValues4[("Dropdown/%*"):format(dropdownConfig2.DropdownConfig.Name)];
        if savedDropdownValue ~= nil then
            dropdownConfig2:Set(savedDropdownValue, true);
        end;
        return ;
    end;
    LibraryBind = setmetatableFunction({}, {
        __tostring = function()
            return "LibraryBind";
        end
    });
    LibraryBind.__index = LibraryBind;
    LibraryBind.new = function(...)
        local newObject7 = setmetatableFunction({}, LibraryBind);
        return newObject7:constructor(...) or newObject7;
    end;
    LibraryBind.constructor = function(bind, bindParent, bindConfig)
        bind.Parent = bindParent;
        bind.BindConfig = table.clone(bindConfig);
        local bindInstance = bind;
        bindConfig.Callback = function(bindValue)
            bindInstance.Parent.LibraryMain:Save();
            if bindInstance.BindConfig.Callback then
                bindInstance.BindConfig.Callback(bindValue);
            end;
            return ;
        end;
        bind.Instance = bindParent.Instance.AddBind(bindConfig);
        return ;
    end;
    LibraryBind.Set = function(bindInstanceWrapper, bindKey, valueToSet3)
        return bindInstanceWrapper.Instance:Set(bindKey, valueToSet3);
    end;
    LibraryBind._Save = function(bindConfig, bindConfigTable)
        bindConfigTable[("Bind/%*"):format(bindConfig.BindConfig.Name)] = bindConfig.Instance.Value.Name;
        return ;
    end;
    LibraryBind._Load = function(bindInstance, profileData)
        local savedBindValue = profileData[("Bind/%*"):format(bindInstance.BindConfig.Name)];
        if savedBindValue ~= nil then
            local keyCodeOrInputType = Enum.KeyCode:FromName(savedBindValue) or Enum.UserInputType:FromName(savedBindValue);
            if keyCodeOrInputType then
                bindInstance:Set(keyCodeOrInputType, true);
            end;
        end;
        return ;
    end;
    LibraryColorpicker = setmetatableFunction({}, {
        __tostring = function()
            return "LibraryColorpicker";
        end
    });
    LibraryColorpicker.__index = LibraryColorpicker;
    LibraryColorpicker.new = function(...)
        local newObject8 = setmetatableFunction({}, LibraryColorpicker);
        return newObject8:constructor(...) or newObject8;
    end;
    LibraryColorpicker.constructor = function(colorPickerParent, colorPickerInstance, colorpickerConfigData)
        colorPickerParent.Parent = colorPickerInstance;
        colorPickerParent.ColorpickerConfig = table.clone(colorpickerConfigData);
        colorPickerParent.Instance = colorPickerInstance.Instance.AddColorpicker(colorpickerConfigData);
        return ;
    end;
    LibraryColorpicker.Set = function(colorPickerInstanceWrapper, colorPickerValue, valueToSet4)
        return colorPickerInstanceWrapper.Instance:Set(colorPickerValue, valueToSet4);
    end;
    LibraryColorpicker._Save = function(colorpickerConfig, colorpickerConfigTable)
        colorpickerConfigTable[("Colorpicker/%*"):format(colorpickerConfig.ColorpickerConfig.Name)] = colorpickerConfig.Instance.Value:ToHex();
        return ;
    end;
    LibraryColorpicker._Load = function(colorpickerConfig2, profileData)
        local savedColorPickerValue = profileData[("Colorpicker/%*"):format(colorpickerConfig2.ColorpickerConfig.Name)];
        if savedColorPickerValue ~= nil then
            colorpickerConfig2:Set(Color3.fromHex(savedColorPickerValue), true);
        end;
        return ;
    end;
    LibraryTextbox = setmetatableFunction({}, {
        __tostring = function()
            return "LibraryTextbox";
        end
    });
    LibraryTextbox.__index = LibraryTextbox;
    LibraryTextbox.new = function(...)
        local newObject9 = setmetatableFunction({}, LibraryTextbox);
        return newObject9:constructor(...) or newObject9;
    end;
    LibraryTextbox.constructor = function(textBoxParent, textBoxInstance, textBoxConfig)
        textBoxParent.Parent = textBoxInstance;
        textBoxParent.TextboxConfig = table.clone(textBoxConfig);
        local textBoxInstance = textBoxParent;
        textBoxConfig.Callback = function(textboxValue)
            textBoxInstance.Parent.LibraryMain:Save();
            if textBoxInstance.TextboxConfig.Callback then
                textBoxInstance.TextboxConfig.Callback(textboxValue);
            end;
            return ;
        end;
        textBoxParent.Instance = textBoxInstance.Instance.AddTextbox(textBoxConfig);
        return ;
    end;
    LibraryTextbox.Set = function(textBoxInstanceWrapper, textBoxValue, valueToSet5)
        return textBoxInstanceWrapper.Instance:Set(textBoxValue, valueToSet5);
    end;
    LibraryTextbox._Save = function(textboxConfig, textboxConfigTable)
        textboxConfigTable[("Textbox/%*"):format(textboxConfig.TextboxConfig.Name)] = textboxConfig.Instance.Value;
        return ;
    end;
    LibraryTextbox._Load = function(textboxConfig2, profileData)
        local savedTextBoxValue = profileData[("Textbox/%*"):format(textboxConfig2.TextboxConfig.Name)];
        if savedTextBoxValue ~= nil then
            textboxConfig2:Set(savedTextBoxValue, true);
        end;
        return ;
    end;
    LibraryParagraph = setmetatableFunction({}, {
        __tostring = function()
            return "LibraryParagraph";
        end
    });
    LibraryParagraph.__index = LibraryParagraph;
    LibraryParagraph.new = function(...)
        local newObject10 = setmetatableFunction({}, LibraryParagraph);
        return newObject10:constructor(...) or newObject10;
    end;
    LibraryParagraph.constructor = function(paragraphParent, paragraphInstance, paragraphInstance)
        paragraphParent.Parent = paragraphInstance;
        paragraphParent.Instance = paragraphInstance.Instance.AddParagraph(paragraphInstance);
        return ;
    end;
    return { LibraryTab = LibraryTab, LibrarySection = LibrarySection, LibraryButton = LibraryButton, LibraryToggle = LibraryToggle, LibrarySlider = LibrarySlider, LibraryRangeSlider = LibraryRangeSlider, LibraryDropdown = LibraryDropdown, LibraryBind = LibraryBind, LibraryColorpicker = LibraryColorpicker, LibraryTextbox = LibraryTextbox, LibraryParagraph = LibraryParagraph };
end);
registerModule("Main", "ModuleScript", "rbxts-bundle-example.LKHUB.Main", "rbxts-bundle-example.LKHUB", function()
    local lkhubMainModule = getModuleGlobals("rbxts-bundle-example.LKHUB.Main");
    local scriptReference = lkhubMainModule.script;
    local runtimeLibRequire = lkhubMainModule.require(scriptReference.Parent.Parent.include.RuntimeLib);
    local libraryImport = runtimeLibRequire.import(scriptReference, scriptReference.Parent, "Library", "Library");
    local uncGlobalsImport = runtimeLibRequire.import(scriptReference, scriptReference.Parent, "UNCGlobals");
    local clonerefFunction = uncGlobalsImport.cloneref;
    local isFileFunction = uncGlobalsImport.isfile;
    local libraryTab = runtimeLibRequire.import(scriptReference, scriptReference.Parent, "Library", "LibraryWrapper", "LibraryWrapper").LibraryTab;
    local defaultTabs = runtimeLibRequire.import(scriptReference, scriptReference.Parent, "DefaultTabs", "Settings", "SectionProfiles").default;
    local utilsImport = runtimeLibRequire.import(scriptReference, scriptReference.Parent, "Utils");
    local makeSafeFileNameFunction = utilsImport.makeSafeFileName;
    local loadJsonFunction = utilsImport.loadJson;
    local httpServiceEncoded = clonerefFunction(game:GetService("HttpService"));
    for folderIndex, folderPath in { "lkhub", "lkhub/profiles" }, nil, nil do
        if not isfolder(folderPath) then
            makefolder(folderPath);
        end;
    end;
    local unknownValue18 = nil;
    local lkhubInstance = setmetatableFunction({}, {
        __tostring = function()
            return "LKHUB";
        end
    });
    lkhubInstance.__index = lkhubInstance;
    lkhubInstance.new = function(...)
        local constructedObject = setmetatableFunction({}, lkhubInstance);
        return constructedObject:constructor(...) or constructedObject;
    end;
    lkhubInstance.constructor = function(lkhubConstructor, gameName)
        lkhubConstructor.Tabs = {};
        lkhubConstructor.Profile = "Default";
        lkhubConstructor.Profiles = { "Default", "testProfile" };
        lkhubConstructor.LoadedProfile = false;
        lkhubConstructor.gameName = gameName;
        lkhubConstructor.Instance = libraryImport.Load({ Title = ("LKHUB - <b>%*</b>"):format(gameName) });
        local lkhubInstance = lkhubConstructor;
        local uninjectFunction = libraryImport.Uninject;
        libraryImport.Uninject = function()
            lkhubInstance:Save();
            uninjectFunction();
            return ;
        end;
        return ;
    end;
    lkhubInstance.Notification = function(L_2904, notificationTitle, notificationContent, notificationDelay)
        if notificationTitle == nil then
            notificationTitle = "LKHUB";
        end;
        if notificationContent == nil then
            notificationContent = "";
        end;
        if notificationDelay == nil then
            notificationDelay = 5;
        end;
        return libraryImport.Notification({ Title = notificationTitle, Content = notificationContent, Delay = notificationDelay });
    end;
    lkhubInstance.Clean = function(L_2908, cleanArgument)
        libraryImport.Clean(cleanArgument);
        return ;
    end;
    lkhubInstance.CreateModal = function(L_2910, modalArgument)
        return libraryImport.CreateModal(modalArgument);
    end;
    lkhubInstance.errHandler = function(lkhubInstance, functionToPCall, notificationTitle)
        if notificationTitle == nil then
            notificationTitle = "LKHUB";
        end;
        local success, result = pcall(functionToPCall);
        if not success then
            lkhubInstance:Notification(("%* Error"):format(notificationTitle), tostring(result), 10);
            return nil;
        end;
        return result;
    end;
    lkhubInstance.LoadTabs = function(tabController, tabData)
        for tabIndex, tabData in tabData, nil, nil do
            local currentTabData = tabData;
            local tabName = currentTabData[1];
            local tabContent = currentTabData[2];
            if type(tabName) == "string" and type(tabContent) == "table" then
                local newTab = tabController:AddTab(tabName);
                for nestedLoopIndex, module in tabContent, nil, nil do
                    module:Load(newTab);
                end;
            end;
        end;
        tabController:Load();
        return ;
    end;
    lkhubInstance.AddTab = function(unknownValue, newValue)
        return libraryTab.new(unknownValue, newValue);
    end;
    lkhubInstance.Save = function(profileData, unknownValue1)
        if not profileData.LoadedProfile then
            return nil;
        end;
        local savedTabData = {};
        local guiProfileData = {};
        local currentProfile = unknownValue1;
        if currentProfile == nil then
            currentProfile = profileData.Profile;
        end;
        guiProfileData.Profile = currentProfile;
        guiProfileData.Profiles = profileData.Profiles;
        for tabNameIndex, tabSectionData in profileData.Tabs, nil, nil do
            for sectionNameIndex, sectionObjectData in tabSectionData.Sections, nil, nil do
                for objectIndex, objectData in sectionObjectData.Objects, nil, nil do
                    if objectData._Save ~= nil then
                        local tabDataEntry = savedTabData[tabNameIndex];
                        if not tabDataEntry then
                            savedTabData[tabNameIndex] = {};
                            tabDataEntry = savedTabData[tabNameIndex];
                        end;
                        local sectionDataEntry = tabDataEntry[sectionNameIndex];
                        if not sectionDataEntry then
                            tabDataEntry[sectionNameIndex] = {};
                            sectionDataEntry = tabDataEntry[sectionNameIndex];
                        end;
                        objectData:_Save(sectionDataEntry);
                    end;
                end;
            end;
        end;
        local guiProfilePath = ("lkhub/profiles/%*"):format(makeSafeFileNameFunction((("%*.gui.profile"):format(profileData.gameName))));
        local profilePath = ("lkhub/profiles/%*"):format(makeSafeFileNameFunction((("%*_%*.profile"):format(profileData.Profile, profileData.gameName))));
        writefile(guiProfilePath, httpServiceEncoded:JSONEncode(guiProfileData));
        writefile(profilePath, httpServiceEncoded:JSONEncode(savedTabData));
        return ;
    end;
    lkhubInstance.Load = function(localProfileData, unknownValue2)
        local guiConfigPath = ("lkhub/profiles/%*"):format(makeSafeFileNameFunction((("%*.gui.profile"):format(localProfileData.gameName))));
        local loadedGuiConfig = {};
        local dataList = {};
        if isFileFunction(guiConfigPath) then
            loadedGuiConfig = loadJsonFunction(guiConfigPath);
            if not loadedGuiConfig then
                loadedGuiConfig = {};
                lkhubInstance:Notification("LKHUB | Error", "Failed to load GUI config", 10);
            end;
        end;
        local currentProfileName = unknownValue2;
        if currentProfileName == nil then
            currentProfileName = loadedGuiConfig.Profile;
            if currentProfileName == nil then
                currentProfileName = "Default";
            end;
        end;
        localProfileData.Profile = currentProfileName;
        localProfileData.Profiles = loadedGuiConfig.Profiles or { [1] = "Default" };
        defaultTabs.Instance.ProfilesDropdown:SetChoices(localProfileData.Profiles, true);
        defaultTabs.Instance.ProfilesDropdown:Set(localProfileData.Profile, true);
        local profileConfigPath = ("lkhub/profiles/%*"):format(makeSafeFileNameFunction((("%*_%*.profile"):format(localProfileData.Profile, localProfileData.gameName))));
        if isFileFunction(profileConfigPath) then
            local loadedProfileConfig = loadJsonFunction(profileConfigPath);
            if not loadedProfileConfig then
                loadedProfileConfig = {};
                lkhubInstance:Notification("LKHUB | Error", ("Failed to load %* config"):format(localProfileData.Profile), 10);
            end;
            for tabIndex, tabData in loadedProfileConfig, nil, nil do
                for sectionIndex, objectToLoad in tabData, nil, nil do
                    local tabSection = localProfileData.Tabs[tabIndex];
                    if tabSection ~= nil then
                        tabSection = tabSection.Sections[sectionIndex];
                    end;
                    local sectionObjects = tabSection;
                    if sectionObjects then
                        for objectIndex, sectionObject in sectionObjects.Objects, nil, nil do
                            if sectionObject._Load ~= nil then
                                sectionObject:_Load(objectToLoad);
                            end;
                        end;
                    end;
                end;
            end;
        end;
        localProfileData.LoadedProfile = true;
        return ;
    end;
    lkhubInstance.Library = libraryImport;
    return { default = lkhubInstance };
end);
registerModule("Services", "ModuleScript", "rbxts-bundle-example.LKHUB.Services", "rbxts-bundle-example.LKHUB", function()
    local servicesModule = getModuleGlobals("rbxts-bundle-example.LKHUB.Services");
    local scriptReference = servicesModule.script;
    local cloneRefFunction = servicesModule.require(scriptReference.Parent.Parent.include.RuntimeLib).import(scriptReference, scriptReference.Parent, "UNCGlobals").cloneref;
    local playersService = cloneRefFunction(game:GetService("Players"));
    local replicatedStorageService = cloneRefFunction(game:GetService("ReplicatedStorage"));
    local workspaceService = cloneRefFunction(game:GetService("Workspace"));
    local httpService = cloneRefFunction(game:GetService("HttpService"));
    local runService = cloneRefFunction(game:GetService("RunService"));
    local lightingService = cloneRefFunction(game:GetService("Lighting"));
    local userInputService = cloneRefFunction(game:GetService("UserInputService"));
    local marketplaceService = cloneRefFunction(game:GetService("MarketplaceService"));
    local teleportService = cloneRefFunction(game:GetService("TeleportService"));
    return { Players = playersService, ReplicatedStorage = replicatedStorageService, Workspace = workspaceService, HttpService = httpService, RunService = runService, Lighting = lightingService, UserInputService = userInputService, MarketplaceService = marketplaceService, TeleportService = teleportService };
end);
registerModule("UNCGlobals", "ModuleScript", "rbxts-bundle-example.LKHUB.UNCGlobals", "rbxts-bundle-example.LKHUB", function()
    local uncGlobalsModule = getModuleGlobals("rbxts-bundle-example.LKHUB.UNCGlobals");
    local scriptReference3 = uncGlobalsModule.script;
    local requireFunction3 = uncGlobalsModule.require;
    local cloneRef = cloneref or function(unknownValue3)
        return unknownValue3;
    end;
    local isFile = isfile or function(filePath)
        local success, fileContent = pcall(function()
            return readfile(filePath);
        end);
        return success and fileContent ~= nil and fileContent ~= "";
    end;
    local closureCheckFunction = isexecutorclosure or checkclosure or isourclosure;
    local fireProximityPromptFunction = fireproximityprompt or function(proximityPrompt)
        local proximityPromptEnabled = proximityPrompt.Enabled;
        local maxActivationDistance = proximityPrompt.MaxActivationDistance;
        proximityPrompt.Enabled = true;
        proximityPrompt.MaxActivationDistance = math.huge;
        if pcall(function()
            return proximityPrompt:InputHoldBegin();
        end) then
            local holdDuration = proximityPrompt.HoldDuration;
            if 0 < holdDuration then
                task.wait(holdDuration);
            end;
            pcall(function()
                return proximityPrompt:InputHoldEnd();
            end);
        end;
        proximityPrompt.Enabled = proximityPromptEnabled;
        proximityPrompt.MaxActivationDistance = maxActivationDistance;
        return ;
    end;
    return { cloneref = cloneRef, isfile = isFile, checkclosure = closureCheckFunction, fireproximityprompt = fireProximityPromptFunction };
end);
registerModule("Utils", "ModuleScript", "rbxts-bundle-example.LKHUB.Utils", "rbxts-bundle-example.LKHUB", function()
    local utilsModule = getModuleGlobals("rbxts-bundle-example.LKHUB.Utils");
    local scriptReference = utilsModule.script;
    local jsonDecodeFunction = utilsModule.require(scriptReference.Parent.Parent.include.RuntimeLib).import(scriptReference, scriptReference.Parent, "UNCGlobals").cloneref(game:GetService("HttpService"));
    local makeSafeFileName = function(unsanitizedString)
        local sanitizedString = string.gsub(unsanitizedString, "[<>:\"/\\|?*]+", "_");
        return string.gsub(string.gsub(sanitizedString, "^[%s.]+", ""), "[%s.]+$", "");
    end;
    local loadJson = function(filePath)
        local successJson, jsonData = pcall(function()
            return jsonDecodeFunction:JSONDecode(readfile(filePath));
        end);
        return if not successJson or type(jsonData) ~= "table" then nil else jsonData;
    end;
    local printTable;
    printTable = function(data, maxDepth, indentationLevel)
        if maxDepth == nil then
            maxDepth = math.huge;
        end;
        if indentationLevel == nil then
            indentationLevel = 0;
        end;
        local indentationString = string.rep(" ", indentationLevel);
        if type(data) ~= "table" then
            printFunction(indentationString .. tostring(data));
            return nil;
        end;
        if maxDepth * 4 <= indentationLevel then
            printFunction(indentationString .. "{ ... }");
            return nil;
        end;
        printFunction(indentationString .. "{");
        for key, value in data, nil, nil do
            local keyString = if type(key) ~= "string" then "[" .. (tostring(key) .. "]") else "[\"" .. (key .. "\"]");
            if type(value) == "table" then
                printFunction(indentationString .. ("  " .. (keyString .. " = ")));
                printTable(value, maxDepth, indentationLevel + 4);
            else
                printFunction(indentationString .. ("  " .. (keyString .. (" = " .. (tostring(value) .. ",")))));
            end;
        end;
        printFunction(indentationString .. "}");
        return ;
    end;
    return { makeSafeFileName = makeSafeFileName, loadJson = loadJson, printTable = printTable };
end);
registerModule("Closures", "ModuleScript", "rbxts-bundle-example.LKHUB.Utils.Closures", "rbxts-bundle-example.LKHUB.Utils", function()
    local closuresModule = getModuleGlobals("rbxts-bundle-example.LKHUB.Utils.Closures");
    local scriptReference = closuresModule.script;
    local checkClosure = closuresModule.require(scriptReference.Parent.Parent.Parent.include.RuntimeLib).import(scriptReference, scriptReference.Parent.Parent, "UNCGlobals").checkclosure;
    local booleanValue = newproxyFunction(false);
    local closureValidatorFunction = function(debugInfo, constants)
        if constants == nil then
            return true;
        end;
        local debugConstants = debug.getconstants(debugInfo);
        for constantIndex = 0, #constants - 1, 1 do
            local constantValue = constants[constantIndex + 1];
            if debugConstants[constantIndex + 1] ~= constantValue and constantValue ~= booleanValue then
                return false;
            end;
        end;
        return true;
    end;
    return {
        searchClosure = function(unknownValue19, functionName, upvalueIndex, unknownValue20)
            if functionName == nil then
                functionName = "Unnamed function";
            end;
            for garbageCollectionIndex, garbageCollectedFunction in getgc() do
                if type(garbageCollectedFunction) == "function" then
                    local scriptFromEnvironment = rawgetFunction(getfenv(garbageCollectedFunction), "script");
                    if islclosure(garbageCollectedFunction) and not checkClosure(garbageCollectedFunction) and (unknownValue19 == nil and scriptFromEnvironment.Parent == nil or unknownValue19 == scriptFromEnvironment) and pcall(function()
                        return debug.getupvalue(garbageCollectedFunction, upvalueIndex);
                    end) and (functionName == "Unnamed function" or debug.getinfo(garbageCollectedFunction).name == functionName) and closureValidatorFunction(garbageCollectedFunction, unknownValue20) then
                        return garbageCollectedFunction;
                    end;
                end;
            end;
            return ;
        end
    };
end);
registerModule("NumberFormat", "ModuleScript", "rbxts-bundle-example.LKHUB.Utils.NumberFormat", "rbxts-bundle-example.LKHUB.Utils", function()
    local numberFormatModule = getModuleGlobals("rbxts-bundle-example.LKHUB.Utils.NumberFormat");
    local scriptReference = numberFormatModule.script;
    local requireFunction = numberFormatModule.require;
    local formatCommas = function(numberValue)
        if tonumber(numberValue) ~= nil then
            return string.reverse((string.gsub(string.gsub(string.reverse(tostring(math.floor(numberValue))), "(%d%d%d)", "%1,"), ",(%-?)$", "%1")));
        end;
        return "?";
    end;
    local reduceDecimals = function(numberToFormat, exponentValue)
        local decimalMultiplier = 10 ^ exponentValue;
        return math.floor(numberToFormat * decimalMultiplier) / decimalMultiplier;
    end;
    local abbreviationSuffixes = { "M", "B", "T", "Qa", "Qi", "Sx", "Sp", "Oc", "No", "Dc" };
    local formatAbrvShort = function(numberToFormat)
        if numberToFormat < 1000000 then
            return formatCommas(numberToFormat);
        end;
        local shortenedNumber = numberToFormat / 1000000;
        for abbreviationIndex = 1, #abbreviationSuffixes, 1 do
            if shortenedNumber < 1000 or abbreviationIndex == #abbreviationSuffixes then
                if 100 <= shortenedNumber then
                    return tostring(math.floor(shortenedNumber)) .. abbreviationSuffixes[abbreviationIndex];
                end;
                return tostring(reduceDecimals(shortenedNumber, 1)) .. abbreviationSuffixes[abbreviationIndex];
            end;
            shortenedNumber = shortenedNumber / 1000;
        end;
        return "?";
    end;
    local formatAbbreviatedLong = function(absoluteValue)
        local absoluteNumber = math.abs(absoluteValue);
        if absoluteNumber < 1000000 then
            return formatCommas(absoluteNumber);
        end;
        local longShortenedNumber = absoluteNumber / 1000000;
        for i = 1, #abbreviationSuffixes, 1 do
            if longShortenedNumber < 1000 or i == #abbreviationSuffixes then
                if 100 <= longShortenedNumber then
                    return tostring(reduceDecimals(longShortenedNumber, 1)) .. abbreviationSuffixes[i];
                end;
                return tostring(reduceDecimals(longShortenedNumber, 2)) .. abbreviationSuffixes[i];
            end;
            longShortenedNumber = longShortenedNumber / 1000;
        end;
        return "?";
    end;
    return { formatCommas = formatCommas, reduceDecimals = reduceDecimals, formatAbrvShort = formatAbrvShort, formatAbrvLong = formatAbbreviatedLong };
end);
registerModule("RegExp", "ModuleScript", "rbxts-bundle-example.LKHUB.Utils.RegExp", "rbxts-bundle-example.LKHUB.Utils", function()
    local regExpModule = getModuleGlobals("rbxts-bundle-example.LKHUB.Utils.RegExp");
    local scriptReference = regExpModule.script;
    local regExConstructor = regExpModule.require(scriptReference.RegEx);
    local regExpMetatable = {};
    local regExpInstanceMetatable = {
        __index = regExpMetatable,
        __tostring = function(innerRegEx)
            return tostring(innerRegEx._innerRegEx);
        end
    };
    regExpMetatable.exec = function(regExpInstance, inputString)
        local matchResult = regExpInstance._innerRegEx:match(inputString);
        if not matchResult then
            return nil;
        end;
        local span = matchResult:span();
        local groupArray = matchResult:grouparr();
        local matchTable = { groupArray[0] };
        for i = 1, groupArray.n, 1 do
            matchTable[i + 1] = groupArray[i];
        end;
        matchTable.n = groupArray.n + 1;
        matchTable.index = span;
        matchTable.input = inputString;
        return matchTable;
    end;
    regExpMetatable.test = function(regexExecutor, inputString)
        return regexExecutor:exec(inputString) ~= nil;
    end;
    regExpMetatable.new = function(regExpSource, regexOptionsString)
        local regExpOptions = regexOptionsString or "";
        local regexObject = regExConstructor.new(regExpSource, regExpOptions);
        local regExpProperties = { source = regExpSource, ignoreCase = regExpOptions:find("i") ~= nil, global = regExpOptions:find("g") ~= nil, multiline = regExpOptions:find("m") ~= nil, _innerRegEx = regexObject };
        return setmetatableFunction(regExpProperties, regExpInstanceMetatable);
    end;
    return { default = regExpMetatable };
end);
registerModule("RegEx", "ModuleScript", "rbxts-bundle-example.LKHUB.Utils.RegExp.RegEx", "rbxts-bundle-example.LKHUB.Utils.RegExp", function()
    local regExModule = getModuleGlobals("rbxts-bundle-example.LKHUB.Utils.RegExp.RegEx");
    local scriptReference = regExModule.script;
    local regExRequire = regExModule.require;
    local unicodeDataOptions = { cacheSize = 256, unicodeData = false };
    local unicodeCategoryData = unicodeDataOptions.unicodeData and regExRequire(scriptReference:WaitForChild("_unicodechar_category"));
    local unicodeScriptsData = unicodeDataOptions.unicodeData and regExRequire(scriptReference:WaitForChild("_scripts"));
    local unicodeXucData = unicodeDataOptions.unicodeData and regExRequire(scriptReference:WaitForChild("_xuc"));
    local matchCache = setmetatableFunction({}, { __mode = "k" });
    local regexModule = {};
    local regexMetatable = {};
    local matchMetatable = {};
    local metatableLockRegex = nil;
    local utf8Substring = function(inputString, startIndex)
        if startIndex then
            inputString = string.sub(inputString, utf8.offset(inputString, startIndex));
        end;
        local stringLength = utf8.len(inputString);
        if stringLength <= 1999 then
            return { n = stringLength, s = inputString, utf8.codepoint(inputString, 1, #inputString) };
        end;
        local chunkCount = math.ceil(stringLength / 1999);
        local charTable = table.create(stringLength);
        local tableIndex = 1;
        for i = 1, chunkCount, 1 do
            local codePoints = table.pack(utf8.codepoint(inputString, utf8.offset(inputString, i * 1999 - 1998), utf8.offset(inputString, i * 1999 - (i == chunkCount and 1998 - ((stringLength - 1) % 1999 + 1) or -1)) - 1));
            table.move(codePoints, 1, codePoints.n, tableIndex, charTable);
            tableIndex = tableIndex + codePoints.n;
        end;
        charTable.s = inputString;
        charTable.n = stringLength;
        return charTable;
    end;
    local utf8CharFromTable = function(codePointTable)
        local tableLength = codePointTable.n or #codePointTable;
        if tableLength <= 7997 then
            return utf8.char(table.unpack(codePointTable));
        end;
        local chunkCount2 = math.ceil(tableLength / 7997);
        local charChunks = table.create(chunkCount2);
        for chunkIndex = 1, chunkCount2, 1 do
            charChunks[chunkIndex] = utf8.char(table.unpack(codePointTable, chunkIndex * 7997 - 7996, chunkIndex * 7997 - (chunkIndex == chunkCount2 and 7997 - ((tableLength - 1) % 7997 + 1) or 0)));
        end;
        return table.concat(charChunks);
    end;
    local substringByCodePoints = function(fullString, startIndex, offset)
        local endOffset = utf8.offset(fullString, offset);
        return string.sub(fullString, utf8.offset(fullString, startIndex), endOffset and endOffset - 1);
    end;
    local regexFlagsMap = { a = "anchored", i = "caseless", m = "multiline", s = "dotall", u = "unicode", U = "ungreedy", x = "extended" };
    local posixClasses = { alnum = true, alpha = true, ascii = true, blank = true, cntrl = true, digit = true, graph = true, lower = true, print = true, punct = true, space = true, upper = true, word = true, xdigit = true };
    local characterClasses = { [68] = { "class", "digit", true }, [83] = { "class", "space", true }, [87] = { "class", "word", true }, [100] = { "class", "digit", false }, [115] = { "class", "space", false }, [119] = { "class", "word", false }, [72] = { "class", "blank", true }, [86] = { "class", "vertical_tab", true }, [104] = { "class", "blank", false }, [118] = { "class", "vertical_tab", false }, [78] = { 78 }, [82] = { 82 }, [66] = 8, [110] = 10, [114] = 13, [116] = 9 };
    local characterClassMap = { [98] = { 98, { "class", "word", false } }, [66] = { 66, { "class", "word", false } }, [75] = { 75 }, [71] = { 71 }, [74] = { 74 }, [90] = { 90 }, [122] = { 122 } };
    local unicodeCategories = { C = true, Cc = true, Cf = true, Cn = true, Co = true, Cs = true, L = true, Ll = true, Lm = true, Lo = true, Lt = true, Lu = true, M = true, Mc = true, Me = true, Mn = true, N = true, Nd = true, Nl = true, No = true, P = true, Pc = true, Pd = true, Pe = true, Pf = true, Pi = true, Po = true, Ps = true, S = true, Sc = true, Sk = true, Sm = true, So = true, Z = true, Zl = true, Zp = true, Zs = true, Xan = true, Xps = true, Xsp = true, Xuc = true, Xwd = true };
    local specialCharacterMap = { [33] = true, [34] = true, [35] = true, [36] = true, [37] = true, [38] = true, [39] = true, [40] = true, [41] = true, [42] = true, [43] = true, [44] = true, [45] = true, [46] = true, [47] = true, [58] = true, [59] = true, [60] = true, [61] = true, [62] = true, [63] = true, [64] = true, [91] = true, [92] = true, [93] = true, [94] = true, [95] = true, [96] = true, [123] = true, [124] = true, [125] = true, [126] = true };
    local defaultValues = { 36 };
    local numberArray = { 46 };
    local caretCharacter = { 94 };
    local pipeCharacter = { 124 };
    local createMethod = function(className, argumentName, regexFunction)
        if className == "Match" then
            return function(...)
                if select("#", ...) < 1 then
                    errorFunction("missing argument #1 (Match expected)", 2);
                end;
                local matchObject, groupIndex, arg1 = ...;
                if not matchCache[matchObject] or matchCache[matchObject].name ~= "Match" then
                    errorFunction(string.format("invalid argument #1 to %q (Match expected, got %s)", argumentName, typeofFunction(matchObject)), 2);
                else
                    matchObject = matchCache[matchObject];
                end;
                if (argumentName == "group" or argumentName == "span") and groupIndex == nil then
                    groupIndex = 0;
                end;
                return regexFunction(matchObject, groupIndex);
            end;
        end;
        return function(...)
            local argumentCount = select("#", ...);
            if argumentCount < 1 then
                errorFunction("missing argument #1 (RegEx expected)", 2);
            elseif argumentCount < 2 then
                errorFunction("missing argument #2 (string expected)", 2);
            end;
            local regexPattern, replacementString, replacementValue, argument4, arg5, arg6, arg7 = ...;
            if not matchCache[regexPattern] or matchCache[regexPattern].name ~= "RegEx" then
                if type(regexPattern) ~= "string" and type(regexPattern) ~= "number" then
                    errorFunction(string.format("invalid argument #1 to %q (RegEx expected, got %s)", argumentName, typeofFunction(regexPattern)), 2);
                end;
                regexPattern = regexModule.fromstring(regexPattern);
            elseif argumentName == "sub" then
                if type(replacementValue) == "number" then
                    replacementValue = replacementValue .. "";
                elseif type(replacementValue) ~= "string" then
                    errorFunction(string.format("invalid argument #3 to 'sub' (string expected, got %s)", typeofFunction(replacementValue)), 2);
                end;
            elseif type(replacementString) == "number" then
                replacementString = replacementString .. "";
            elseif type(replacementString) ~= "string" then
                errorFunction(string.format("invalid argument #2 to %q (string expected, got %s)", argumentName, typeofFunction(replacementString)), 2);
            end;
            if argumentName ~= "sub" and argumentName ~= "split" then
                local replacementValueType = typeofFunction(replacementValue);
                if replacementValueType ~= "nil" then
                    replacementValue = tonumber(replacementValue);
                    if not replacementValue then
                        errorFunction(string.format("invalid argument #3 to %q (number expected, got %s)", argumentName, replacementValueType), 2);
                    elseif replacementValue < 0 then
                        replacementValue = #replacementString + math.floor(replacementValue + 0.5) + 1;
                    else
                        replacementValue = math.max(math.floor(replacementValue + 0.5), 1);
                    end;
                end;
            end;
            local regexMatchObject = matchCache[regexPattern];
            if argumentName == "match" or argumentName == "matchiter" then
                argument4 = ...;
            elseif argumentName == "sub" then
                arg6 = ...;
            end;
            return regexFunction(regexMatchObject, replacementString, replacementValue, argument4, arg5, arg6);
        end;
    end;
    local matchToString = function(groupId)
        local matchSpans = matchCache[groupId].spans;
        local matchStartIndex = matchSpans[0][1];
        local matchEndIndex = matchSpans[0][2];
        if matchEndIndex <= matchStartIndex then
            return string.format("Match (%d..%d, empty)", matchStartIndex, matchEndIndex - 1);
        end;
        return string.format("Match (%d..%d): %s", matchStartIndex, matchEndIndex - 1, substringByCodePoints(matchSpans.input, matchStartIndex, matchEndIndex));
    end;
    local createMatchObject = function(matchSource, groupId, sourceString, inputValue)
        matchSource.source = sourceString;
        matchSource.input = inputValue;
        local matchId = newproxyFunction(true);
        local matchObject = getmetatableFunction(matchId);
        matchObject.__metatable = metatableLockRegex;
        matchObject.__index = setmetatableFunction(matchSource, matchMetatable);
        matchObject.__tostring = matchToString;
        matchCache[matchId] = { name = "Match", spans = matchSource, group_id = groupId };
        return matchId;
    end;
    matchMetatable.group = createMethod("Match", "group", function(matchData, groupNameOrIndex)
        local spanData = matchData.spans[type(groupNameOrIndex) == "number" and groupNameOrIndex or matchData.group_id[groupNameOrIndex]];
        if not spanData then
            return nil;
        end;
        return substringByCodePoints(matchData.spans.input, spanData[1], spanData[2]);
    end);
    matchMetatable.span = createMethod("Match", "span", function(matchObject, spanNameOrIndex)
        local spanIndices = matchObject.spans[type(spanNameOrIndex) == "number" and spanNameOrIndex or matchObject.group_id[spanNameOrIndex]];
        if not spanIndices then
            return nil;
        end;
        return spanIndices[1], spanIndices[2] - 1;
    end);
    matchMetatable.groups = createMethod("Match", "groups", function(spanData)
        local matchSpansTable = spanData.spans;
        if 0 < matchSpansTable.n then
            local matchesTable = table.create(matchSpansTable.n);
            for matchIndex = 0, matchSpansTable.n, 1 do
                local matchValue = matchSpansTable[matchIndex];
                if matchValue then
                    matchesTable[matchIndex] = substringByCodePoints(matchSpansTable.input, matchValue[1], matchValue[2]);
                end;
            end;
            return table.unpack(matchesTable, 1, matchSpansTable.n);
        end;
        return substringByCodePoints(matchSpansTable.input, matchSpansTable[0][1], matchSpansTable[0][2]);
    end);
    matchMetatable.groupdict = createMethod("Match", "groupdict", function(groupData)
        local matchSpansData = groupData.spans;
        local namedMatches = {};
        for groupName, spanIndex in pairsFunction(groupData.group_id) do
            spanIndex = matchSpansData[spanIndex];
            if spanIndex then
                namedMatches[groupName] = substringByCodePoints(matchSpansData.input, spanIndex[1], spanIndex[2]);
            end;
        end;
        return namedMatches;
    end);
    matchMetatable.grouparr = createMethod("Match", "groupdict", function(spanData2)
        local spansData = spanData2.spans;
        local spansTable = table.create(spansData.n);
        for spanIndexLoop = 0, spansData.n, 1 do
            local spanValue = spansData[spanIndexLoop];
            if spanValue then
                spansTable[spanIndexLoop] = substringByCodePoints(spansData.input, spanValue[1], spanValue[2]);
            end;
        end;
        spansTable.n = spansData.n;
        return spansTable;
    end);
    local newlineConstants = { CR = 0, LF = 1, CRLF = 2, ANYRLF = 3, ANY = 4, NUL = 5 };
    local isNewlineCharacter = function(characterCodes, charIndex, newlineType)
        local newlineType = newlineType.newline;
        local characterCode = characterCodes[charIndex];
        if newlineType == 0 then
            return characterCode == 13;
        end;
        if newlineType == 2 then
            return characterCode == 10 and characterCodes[charIndex - 1] == 32;
        end;
        if newlineType == 3 then
            return characterCode == 10 or characterCode == 13;
        end;
        if newlineType == 4 then
            return characterCode == 10 or characterCode == 11 or characterCode == 12 or characterCode == 13 or characterCode == 133 or characterCode == 8232 or characterCode == 8233;
        end;
        if newlineType == 5 then
            return characterCode == 0;
        end;
        return characterCode == 10;
    end;
    local isCharacterMatching;
    isCharacterMatching = function(charsetDefinition, inputString, stringIndex, regexOptions, regexState)
        local charCode = inputString[stringIndex];
        if not charCode then
            return false;
        end;
        if regexOptions.ignoreCase and 97 <= charCode and charCode <= 122 then
            charCode = charCode - 32;
        end;
        if type(charsetDefinition) == "number" then
            return charsetDefinition == charCode;
        end;
        if charsetDefinition[1] == "charset" then
            for i, characterCodeFromSet in ipairs(charsetDefinition[3]) do
                if isCharacterMatching(characterCodeFromSet, inputString, stringIndex, regexOptions, regexState) then
                    return not charsetDefinition[2];
                end;
            end;
            return charsetDefinition[2];
        end;
        if charsetDefinition[1] == "range" then
            return charCode >= charsetDefinition[2] and charCode <= charsetDefinition[3] or regexOptions.ignoreCase and charCode >= 65 and charCode <= 90 and charCode + 32 >= charsetDefinition[2] and charCode + 32 <= charsetDefinition[3];
        end;
        if charsetDefinition[1] == "class" then
            local characterType = charsetDefinition[2];
            local alternates = charsetDefinition[3];
            local isMatching = false;
            if characterType == "xdigit" then
                isMatching = charCode >= 48 and charCode <= 57 or charCode >= 65 and charCode <= 70 or charCode >= 97 and charCode <= 102;
            elseif characterType == "ascii" then
                isMatching = charCode <= 127;
            elseif characterType == "vertical_tab" then
                isMatching = charCode >= 10 and charCode <= 13 or charCode == 8232 or charCode == 8233;
            elseif regexOptions.unicode then
                local unicodeCategory = unicodeCategoryData[charCode] or "Cn";
                local unicodeCategoryPrefix = unicodeCategory:sub(1, 1);
                if characterType == "alnum" then
                    isMatching = unicodeCategoryPrefix == "L" or unicodeCategory == "Nl" or unicodeCategory == "Nd";
                elseif characterType == "alpha" then
                    isMatching = unicodeCategoryPrefix == "L" or unicodeCategory == "Nl";
                elseif characterType == "blank" then
                    isMatching = unicodeCategory == "Zs" or charCode == 9;
                elseif characterType == "cntrl" then
                    isMatching = unicodeCategory == "Cc";
                elseif characterType == "digit" then
                    isMatching = unicodeCategory == "Nd";
                elseif characterType == "graph" then
                    isMatching = unicodeCategoryPrefix ~= "P" and unicodeCategoryPrefix ~= "C";
                elseif characterType == "lower" then
                    isMatching = unicodeCategory == "Ll";
                elseif characterType == "print" then
                    isMatching = unicodeCategoryPrefix ~= "C";
                elseif characterType == "punct" then
                    isMatching = unicodeCategoryPrefix == "P";
                elseif characterType == "space" then
                    isMatching = unicodeCategoryPrefix == "Z" or charCode >= 9 and charCode <= 13;
                elseif characterType == "upper" then
                    isMatching = unicodeCategory == "Lu";
                elseif characterType == "word" then
                    isMatching = unicodeCategoryPrefix == "L" or unicodeCategory == "Nl" or unicodeCategory == "Nd" or unicodeCategory == "Pc";
                end;
            elseif characterType == "alnum" then
                isMatching = charCode >= 48 and charCode <= 57 or charCode >= 65 and charCode <= 90 or charCode >= 97 and charCode <= 122;
            elseif characterType == "alpha" then
                isMatching = charCode >= 65 and charCode <= 90 or charCode >= 97 and charCode <= 122;
            elseif characterType == "blank" then
                isMatching = charCode == 9 or charCode == 32;
            elseif characterType == "cntrl" then
                isMatching = charCode <= 31 or charCode == 127;
            elseif characterType == "digit" then
                isMatching = charCode >= 48 and charCode <= 57;
            elseif characterType == "graph" then
                isMatching = charCode >= 33 and charCode <= 126;
            elseif characterType == "lower" then
                isMatching = charCode >= 97 and charCode <= 122;
            elseif characterType == "print" then
                isMatching = charCode >= 32 and charCode <= 126;
            elseif characterType == "punct" then
                isMatching = specialCharacterMap[charCode];
            elseif characterType == "space" then
                isMatching = charCode >= 9 and charCode <= 13 or charCode == 32;
            elseif characterType == "upper" then
                isMatching = charCode >= 65 and charCode <= 90;
            elseif characterType == "word" then
                isMatching = charCode >= 48 and charCode <= 57 or charCode >= 65 and charCode <= 90 or charCode >= 97 and charCode <= 122 or charCode == 95;
            end;
            if alternates then
                return not isMatching;
            end;
            return isMatching;
        end;
        if charsetDefinition[1] == "category" then
            local unicodeCategoryLookup = unicodeCategoryData[charCode] or "Cn";
            local characterSetName = charsetDefinition[3];
            local characterSetNameLength = #characterSetName;
            if characterSetNameLength == 3 then
                local isCharInCategory = false;
                if characterSetName == "Xan" or characterSetName == "Xwd" then
                    isCharInCategory = unicodeCategoryLookup:find("^[LN]") or characterSetName == "Xwd" and charCode == 95;
                elseif characterSetName == "Xps" or characterSetName == "Xsp" then
                    isCharInCategory = unicodeCategoryLookup:sub(1, 1) == "Z" or charCode >= 9 and charCode <= 13;
                elseif characterSetName == "Xuc" then
                    isCharInCategory = isCharacterMatching(unicodeXucData, inputString, stringIndex, regexOptions, regexState);
                end;
                if charsetDefinition[2] then
                    return not isCharInCategory;
                end;
                return isCharInCategory;
            end;
            if unicodeCategoryLookup:sub(1, characterSetNameLength) == characterSetName then
                return not charsetDefinition[2];
            end;
            return charsetDefinition[2];
        end;
        if charsetDefinition[1] == 46 then
            return regexOptions.dotAll or not isNewlineCharacter(inputString, stringIndex, regexState);
        end;
        if charsetDefinition[1] == 78 then
            return not isNewlineCharacter(inputString, stringIndex, regexState);
        end;
        if charsetDefinition[1] == 82 then
            if regexState.newline_seq == 0 then
                return charCode == 10 or charCode == 13;
            end;
            return charCode == 10 or charCode == 11 or charCode == 12 or charCode == 13 or charCode == 133 or charCode == 8232 or charCode == 8233;
        end;
        return false;
    end;
    local processAlternation = function(expressionList, expressionIndex, captureCount)
        while true do
            local currentExpression = expressionList[expressionIndex];
            local isTable = type(currentExpression) == "table";
            if currentExpression == pipeCharacter then
                break;
            end;
            if isTable and currentExpression[1] == 40 then
                if captureCount then
                    captureCount = captureCount + currentExpression.count;
                end;
                expressionIndex = currentExpression[3];
            elseif isTable and currentExpression[1] == "quantifier" and type(currentExpression[5]) == "table" and currentExpression[5][1] == 40 then
                if captureCount then
                    captureCount = captureCount + currentExpression[5].count;
                end;
                expressionIndex = currentExpression[5][3];
            else
                if not currentExpression or isTable and currentExpression[1] == 41 then
                    return nil, captureCount;
                end;
                if captureCount then
                    if isTable and currentExpression[1] == "quantifier" then
                        captureCount = captureCount + currentExpression[3];
                    else
                        captureCount = captureCount + 1;
                    end;
                end;
            end;
            expressionIndex = expressionIndex + 1;
        end;
        return expressionIndex, captureCount;
    end;
    local matchRegexPattern = function(regexData, regexState, unknownValue1, unknownValue2, unknownValue21, unknownBoolean)
        local isAlternationMatched = false;
        local isQuantifierSatisfied = false;
        local isGroupMatched = false;
        local expressionListIndex = 0;
        local currentIndex = unknownValue1;
        local currentIndex = unknownValue1;
        local stateStack = {};
        while expressionListIndex do
            if expressionListIndex == 0 then
                expressionListIndex = expressionListIndex + 1;
                local alternationResult = processAlternation(regexData, expressionListIndex);
                if alternationResult then
                    table.insert(stateStack, 1, { "alternation", alternationResult, currentIndex });
                end;
            else
                local currentRegexNode = regexData[expressionListIndex];
                local nodeType = type(currentRegexNode) == "table" and currentRegexNode[1];
                if not currentRegexNode then
                    break;
                end;
                if currentRegexNode == "ACCEPT" then
                    local breakLoop = true;
                    local nextNodeIndex = expressionListIndex;
                    repeat
                        nextNodeIndex = nextNodeIndex + 1;
                        local isNextNodeTable = type(regexData[nextNodeIndex]) == "table";
                        local nextNodeData = regexData[nextNodeIndex];
                        if isNextNodeTable and (nextNodeData[1] == 40 or nextNodeData[1] == "quantifier" and type(nextNodeData[5]) == "table" and nextNodeData[5][1] == 40) then
                            nextNodeIndex = nextNodeData[1] == "quantifier" and nextNodeData[5][3] or nextNodeData[3];
                        elseif isNextNodeTable and nextNodeData[1] == 41 and (nextNodeData[4] == 33 or nextNodeData[4] == 61) then
                            breakLoop = false;
                            expressionListIndex = nextNodeIndex;
                            break;
                        end;
                    until not nextNodeData;
                    if breakLoop then
                        break;
                    end;
                elseif currentRegexNode == "PRUNE" or currentRegexNode == "SKIP" then
                    table.insert(stateStack, 1, { currentRegexNode, currentIndex });
                    expressionListIndex = expressionListIndex + 1;
                elseif nodeType == 40 then
                    table.insert(stateStack, 1, { "group", expressionListIndex, currentIndex, nil, currentRegexNode[2], currentRegexNode[3], currentRegexNode[4] });
                    expressionListIndex = expressionListIndex + 1;
                    local alternationMatch, alternationLength = processAlternation(regexData, expressionListIndex, (currentRegexNode[4] == 33 or currentRegexNode[4] == 61) and currentRegexNode[5] and 0);
                    if alternationMatch then
                        table.insert(stateStack, 1, { "alternation", alternationMatch, currentIndex });
                    end;
                    if alternationLength then
                        currentIndex = currentIndex - alternationLength;
                    end;
                elseif nodeType == 41 and currentRegexNode[4] ~= 33 then
                    if currentRegexNode[4] == 33 or currentRegexNode[4] == 61 then
                        local matchStart, stackItem;
                        while true do
                            matchStart = nil;
                            stackItem = table.remove(stateStack, 1);
                            if stackItem[1] == "group" and stackItem[2] == currentRegexNode[3] then
                                break;
                            end;
                            if stackItem[1] == "matchStart" and not matchStart and currentRegexNode[4] == 61 then
                                local tempValue = stackItem;
                            end;
                        end;
                        if (currentRegexNode[4] == 33 or currentRegexNode[4] == 61) and not currentRegexNode[5] then
                            currentIndex = stackItem[3];
                        end;
                        if matchStart then
                            table.insert(stateStack, 1, matchStart);
                        end;
                    elseif currentRegexNode[4] == 62 then
                        repeat
                            local removedItem = table.remove(stateStack, 1);
                        until not removedItem or removedItem[1] == "group" and removedItem[2] == currentRegexNode[3];
                    else
                        for groupIndex, groupState in ipairs(stateStack) do
                            if groupState[1] == "group" and groupState[2] == currentRegexNode[3] then
                                if groupState.jmp then
                                    expressionListIndex = groupState.jmp;
                                end;
                                groupState[4] = currentIndex;
                                if groupState[7] == "quantifier" and groupState[10] + 1 < groupState[9] then
                                    if regexData[currentRegexNode[3]][4] ~= "lazy" or groupState[10] + 1 < groupState[8] then
                                        expressionListIndex = currentRegexNode[3];
                                    end;
                                    local groupData = regexData[currentRegexNode[3]];
                                    local newGroupState = { "group", groupState[2], currentIndex, nil, groupData[5][2], groupData[5][3], "quantifier", groupData[2], groupData[3], groupState[10] + 1, groupState[11], groupData[4] };
                                    table.insert(stateStack, 1, newGroupState);
                                    if groupState[11] then
                                        table.insert(stateStack, 1, { "alternation", groupState[11], currentIndex });
                                    end;
                                end;
                                break;
                            end;
                        end;
                    end;
                    expressionListIndex = expressionListIndex + 1;
                elseif nodeType == 75 then
                    table.insert(stateStack, 1, { "matchStart", currentIndex });
                    expressionListIndex = expressionListIndex + 1;
                elseif nodeType == 124 then
                    local quantifierIndex = expressionListIndex;
                    repeat
                        quantifierIndex = quantifierIndex + 1;
                        local isQuantifierTable = type(regexData[quantifierIndex]) == "table";
                        local quantifierData = regexData[quantifierIndex];
                        if isQuantifierTable and (quantifierData[1] == 40 or quantifierData[1] == "quantifier" and type(quantifierData[5]) == "table" and quantifierData[5][1] == 40) then
                            quantifierIndex = quantifierData[1] == "quantifier" and quantifierData[5][3] or quantifierData[3];
                        end;
                    until isQuantifierTable and quantifierData[1] == 41 or not quantifierData;
                    if regexData[quantifierIndex] then
                        for groupIndex, groupItem in ipairs(stateStack) do
                            if groupItem[1] == "group" and groupItem[6] == quantifierIndex then
                                expressionListIndex = groupItem[6];
                                break;
                            end;
                        end;
                    else
                        expressionListIndex = quantifierIndex;
                    end;
                elseif nodeType == "recurmatch" then
                    table.insert(stateStack, 1, { "group", currentRegexNode[3], currentIndex, nil, nil, regexData[currentRegexNode[3]][3], nil, jmp = expressionListIndex });
                    expressionListIndex = currentRegexNode[3] + 1;
                    local alternationResult2, success = processAlternation(regexData, expressionListIndex);
                    if alternationResult2 then
                        table.insert(stateStack, 1, { "alternation", alternationResult2, currentIndex });
                    end;
                else
                    local isMatch = nil;
                    if currentRegexNode == "FAIL" then
                        isMatch = false;
                    elseif nodeType == 41 then
                        repeat
                            local removedGroup = table.remove(stateStack, 1);
                        until removedGroup[1] == "group" and removedGroup[2] == currentRegexNode[3];
                    elseif nodeType == "quantifier" then
                        if type(currentRegexNode[5]) == "table" and currentRegexNode[5][1] == 40 then
                            local alternationResult3 = processAlternation(regexData, expressionListIndex + 1);
                            if alternationResult3 then
                                table.insert(stateStack, 1, { "alternation", alternationResult3, currentIndex });
                            end;
                            table.insert(stateStack, alternationResult3 and 2 or 1, { "group", expressionListIndex, currentIndex, nil, currentRegexNode[5][2], currentRegexNode[5][3], "quantifier", currentRegexNode[2], currentRegexNode[3], 0, alternationResult3, currentRegexNode[4] });
                            if currentRegexNode[4] == "lazy" and currentRegexNode[2] == 0 then
                                expressionListIndex = currentRegexNode[5][3];
                            end;
                            isMatch = true;
                        else
                            local groupStart = nil;
                            local groupEnd = nil;
                            local groupLength = 1;
                            local isBackReference = type(currentRegexNode[5]) == "table" and currentRegexNode[5][1] == "backref";
                            if isBackReference then
                                groupLength = 0;
                                local backReferenceIndex = currentRegexNode[5][2];
                                for groupIndex2, groupItem2 in ipairs(stateStack) do
                                    if groupItem2[1] == "group" and groupItem2[5] == backReferenceIndex then
                                        groupStart, groupEnd = groupItem2[3], groupItem2[4];
                                        groupLength = groupEnd - groupStart;
                                        break;
                                    end;
                                end;
                            end;
                            local quantifierEnd = currentIndex + currentRegexNode[2] * groupLength;
                            local loopCounter = 0;
                            while loopCounter < currentRegexNode[3] do
                                if isBackReference then
                                    if not groupStart or not groupEnd or substringByCodePoints(regexState.s, groupStart, groupEnd) ~= substringByCodePoints(regexState.s, currentIndex, currentIndex + groupLength) then
                                        break;
                                    end;
                                elseif not isCharacterMatching(currentRegexNode[5], regexState, currentIndex, unknownValue2, unknownValue21) then
                                    break;
                                end;
                                currentIndex = currentIndex + groupLength;
                                loopCounter = loopCounter + 1;
                            end;
                            isMatch = loopCounter >= currentRegexNode[2];
                            if isMatch and currentRegexNode[4] ~= "possessive" then
                                if currentRegexNode[4] == "lazy" then
                                    local startIndex = quantifierEnd;
                                    quantifierEnd = currentIndex;
                                    currentIndex = startIndex;
                                end;
                                table.insert(stateStack, 1, { "quantifier", expressionListIndex, currentIndex, math.min(quantifierEnd, regexState.n + 1), (currentRegexNode[4] == "lazy" and 1 or -1) * groupLength });
                            end;
                        end;
                    elseif nodeType == "backref" then
                        local groupStart = nil;
                        local groupEnd = nil;
                        local groupId = currentRegexNode[2];
                        for groupIndex3, captureGroup in ipairs(stateStack) do
                            if captureGroup[1] == "group" and captureGroup[5] == groupId then
                                groupStart, groupEnd = captureGroup[3], captureGroup[4];
                                break;
                            end;
                        end;
                        if groupStart and groupEnd then
                            local originalIndex = currentIndex;
                            currentIndex = currentIndex + (groupEnd - groupStart);
                            isMatch = substringByCodePoints(regexState.s, groupStart, groupEnd) == substringByCodePoints(regexState.s, originalIndex, currentIndex);
                        end;
                    else
                        local characterData = regexState[currentIndex];
                        if nodeType == 36 or nodeType == 90 or nodeType == 122 then
                            isMatch = currentIndex == regexState.n + 1 or nodeType == 36 and unknownValue2.multiline and isNewlineCharacter(regexState, currentIndex + 1, unknownValue21) or nodeType == 90 and currentIndex == regexState.n and isNewlineCharacter(regexState, currentIndex, unknownValue21);
                        elseif nodeType == 94 or nodeType == 65 or nodeType == 71 then
                            isMatch = currentIndex == 1 or nodeType == 94 and unknownValue2.multiline and isNewlineCharacter(regexState, currentIndex - 1, unknownValue21) or nodeType == 71 and currentIndex == unknownValue1;
                        elseif nodeType == 66 or nodeType == 98 then
                            local isFirstCharacterOrMultilineStart = currentIndex == 1 or unknownValue2.multiline and isNewlineCharacter(regexState, currentIndex - 1, unknownValue21);
                            local isLastCharacterOrMultilineEnd = currentIndex == regexState.n + 1 or unknownValue2.multiline and isNewlineCharacter(regexState, currentIndex, unknownValue21);
                            local isPreviousCharValid = isCharacterMatching(currentRegexNode[2], regexState[currentIndex - 1], unknownValue2) and 0 or isCharacterMatching(currentRegexNode[2], characterData, unknownValue2) and 1;
                            if isPreviousCharValid == 0 then
                                isMatch = isLastCharacterOrMultilineEnd or not isCharacterMatching(currentRegexNode[2], characterData, unknownValue2);
                            elseif isPreviousCharValid then
                                isMatch = isFirstCharacterOrMultilineStart or not isCharacterMatching(currentRegexNode[2], regexState[currentIndex - 1], unknownValue2);
                            end;
                            if nodeType == 66 then
                                isMatch = not isMatch;
                            end;
                        else
                            isMatch = isCharacterMatching(currentRegexNode, regexState, currentIndex, unknownValue2, unknownValue21);
                            currentIndex = currentIndex + 1;
                        end;
                    end;
                    if not isMatch then
                        local firstElement, firstCapture;
                        while true do
                            firstElement = stateStack[1] and stateStack[1][1];
                            firstCapture = stateStack[1];
                            if not firstElement or firstElement == "PRUNE" or firstElement == "SKIP" then
                                break;
                            end;
                            if firstElement == "alternation" then
                                expressionListIndex, currentIndex = firstCapture[2], firstCapture[3];
                                local alternativeMatch, alternativeLength = processAlternation(regexData, expressionListIndex + 1);
                                if alternativeMatch then
                                    firstCapture[2] = alternativeMatch;
                                else
                                    table.remove(stateStack, 1);
                                end;
                                if alternativeLength then
                                    currentIndex = currentIndex - alternativeLength;
                                end;
                                isAlternationMatched = true;
                            end;
                            if isAlternationMatched then
                                break;
                            end;
                            if firstElement == "group" then
                                if firstCapture[7] == "quantifier" then
                                    if firstCapture[12] == "greedy" then
                                        local value10_1 = firstCapture[10];
                                        if not (firstCapture[8] <= value10_1) then
                                            isGroupMatched = true;
                                        end;
                                        if not isGroupMatched then
                                            isQuantifierSatisfied = true;
                                        end;
                                    end;
                                    if not isQuantifierSatisfied then
                                        isGroupMatched = false;
                                    end;
                                    if isQuantifierSatisfied or not (firstCapture[12] ~= "lazy" or not (firstCapture[10] < firstCapture[9]) or firstCapture[13]) then
                                        isQuantifierSatisfied = false;
                                        expressionListIndex, currentIndex = firstCapture[12] == "greedy" and firstCapture[6] or firstCapture[2], firstCapture[3];
                                        if firstCapture[12] == "greedy" then
                                            table.remove(stateStack, 1);
                                            isAlternationMatched = true;
                                        end;
                                        if not isAlternationMatched then
                                            local value10_2 = firstCapture[10];
                                            if firstCapture[8] <= value10_2 then
                                                firstCapture[13] = true;
                                                isAlternationMatched = true;
                                            end;
                                        end;
                                    end;
                                elseif firstCapture[7] == 33 then
                                    table.remove(stateStack, 1);
                                    expressionListIndex, currentIndex = firstCapture[6], firstCapture[3];
                                    isAlternationMatched = true;
                                end;
                            elseif firstElement == "quantifier" and math.sign(firstCapture[4] - firstCapture[3]) == math.sign(firstCapture[5]) then
                                regexData = firstCapture[3];
                                firstCapture[3] = regexData + firstCapture[5];
                                expressionListIndex, currentIndex = firstCapture[2], firstCapture[3];
                                isAlternationMatched = true;
                            end;
                            if isAlternationMatched then
                                break;
                            end;
                            if isAlternationMatched then
                                break;
                            end;
                            if isAlternationMatched then
                                break;
                            end;
                            if isAlternationMatched then
                                break;
                            end;
                            table.remove(stateStack, 1);
                        end;
                        if not isAlternationMatched then
                            if not isAlternationMatched then
                                if not isAlternationMatched then
                                    if not isAlternationMatched then
                                        if not isAlternationMatched then
                                            if firstElement then
                                                table.clear(stateStack);
                                            end;
                                            if regexState.n < currentIndex then
                                                if unknownBoolean then
                                                    return false;
                                                end;
                                                return nil;
                                            end;
                                            currentIndex = firstElement == "SKIP" and firstCapture[2] or currentIndex + 1;
                                            expressionListIndex = 0;
                                            currentIndex = currentIndex;
                                        end;
                                    end;
                                end;
                            end;
                        end;
                    end;
                    isAlternationMatched = false;
                    expressionListIndex = expressionListIndex + 1;
                end;
            end;
        end;
        if unknownBoolean then
            return true;
        end;
        local matchStartFound = false;
        local captureTable = table.create(regexData.group_n);
        captureTable[0], captureTable.n = { currentIndex, currentIndex }, regexData.group_n;
        for patternIndex, capture in ipairs(stateStack) do
            if capture[1] == "matchStart" and not matchStartFound then
                local firstCaptureData = captureTable[0];
                firstCaptureData[1] = capture[2]
                matchStartFound = true;
            elseif capture[1] == "group" and capture[5] and not captureTable[capture[5]] then
                captureTable[capture[5]] = { capture[3], capture[4] };
            end;
        end;
        return captureTable;
    end;
    regexMetatable.test = createMethod("RegEx", "test", function(tokenData, token1, token2)
        return matchRegexPattern(tokenData.token, utf8Substring(token1, token2), 1, tokenData.flags, tokenData.verb_flags, true);
    end);
    regexMetatable.match = createMethod("RegEx", "match", function(tokenData, token3, token4, token5)
        local matchResult = matchRegexPattern(tokenData.token, utf8Substring(token3, token4), 1, tokenData.flags, tokenData.verb_flags, false);
        if not matchResult then
            return nil;
        end;
        return createMatchObject(matchResult, tokenData.group_id, token5, token3);
    end);
    regexMetatable.matchall = createMethod("RegEx", "matchall", function(unknownValue4, unknownValue3, token6, token7)
        local substring = utf8Substring(unknownValue3, token6);
        local currentIndex = 1;
        return function()
            local tokenMatch = currentIndex <= substring.n + 1 and matchRegexPattern(unknownValue4.token, substring, currentIndex, unknownValue4.flags, unknownValue4.verb_flags, false);
            if not tokenMatch then
                return nil;
            end;
            currentIndex = tokenMatch[0][2] + (tokenMatch[0][1] >= tokenMatch[0][2] and 1 or 0);
            return createMatchObject(tokenMatch, unknownValue4.group_id, token7, substring.s);
        end;
    end);
    local applyCondition;
    applyCondition = function(resultTable, sourceTable, conditionTable, unknownTable)
        for index, element in ipairs(unknownTable) do
            if type(element) == "table" then
                if element[1] == "condition" then
                    if conditionTable[element[2]] then
                        if element[3] then
                            applyCondition(resultTable, sourceTable, conditionTable, element[3]);
                        else
                            table.move(sourceTable, conditionTable[element[2]][1], conditionTable[element[2]][2] - 1, #resultTable + 1, resultTable);
                        end;
                    elseif element[4] then
                        applyCondition(resultTable, sourceTable, conditionTable, element[4]);
                    end;
                else
                    table.move(element, 1, #element, #resultTable + 1, resultTable);
                end;
            elseif conditionTable[element] then
                table.move(sourceTable, conditionTable[element][1], conditionTable[element][2] - 1, #resultTable + 1, resultTable);
            end;
        end;
        resultTable.n = #resultTable;
        return resultTable;
    end;
    regexMetatable.sub = createMethod("RegEx", "sub", function(tokenData, stringArgument, stringOrFunctionArgument, numberArgument, substitutionString, unknownValue24)
        if substitutionString ~= nil and (type(substitutionString) ~= "number" and type(substitutionString) ~= "string") then
            errorFunction(string.format("invalid argument #5 to 'sub' (string expected, got %s)", typeofFunction(substitutionString)), 3);
        end;
        local substitutionFlags = { l = false, o = false, u = false };
        for flagCharacter, flagChar in string.gmatch(substitutionString or "", utf8.charpattern) do
            if substitutionFlags[flagCharacter] ~= false then
                errorFunction("invalid regular expression substitution flag " .. flagCharacter, 3);
            end;
            substitutionFlags[flagCharacter] = true;
        end;
        local substitutionType = type(stringArgument);
        if substitutionType == "number" then
            stringArgument = stringArgument .. "";
        elseif substitutionType ~= "string" and substitutionType ~= "function" and (not substitutionFlags.o or substitutionType ~= "table") then
            errorFunction(string.format("invalid argument #2 to 'sub' (string/function%s expected, got %s)", substitutionFlags.o and "/table" or "", typeofFunction(stringArgument)), 3);
        end;
        if tonumber(numberArgument) then
            numberArgument = tonumber(numberArgument);
            if numberArgument <= -1 or numberArgument ~= numberArgument then
                numberArgument = math.huge;
            end;
        elseif numberArgument ~= nil then
            errorFunction(string.format("invalid argument #4 to 'sub' (number expected, got %s)", typeofFunction(numberArgument)), 3);
        else
            numberArgument = math.huge;
        end;
        if numberArgument < 1 then
            return stringOrFunctionArgument, 0;
        end;
        local offset = 0;
        if substitutionType == "string" then
            stringArgument = utf8Substring(stringArgument);
            if not substitutionFlags.l then
                local startIndex = 0;
                local substringList = table.create(3);
                local groupNumber = tokenData.token.group_n;
                local substitutionStack = {};
                while startIndex < stringArgument.n do
                    local currentIndex = startIndex;
                    repeat
                        currentIndex = currentIndex + 1;
                    until not stringArgument[currentIndex] or stringArgument[currentIndex] == 36 or stringArgument[currentIndex] == 92 or (stringArgument[currentIndex] == 58 or stringArgument[currentIndex] == 125) and substitutionStack[1];
                    offset = offset + (currentIndex - startIndex - 1);
                    if 1 < currentIndex - startIndex then
                        table.insert(substringList, table.move(stringArgument, startIndex + 1, currentIndex - 1, 1, table.create(currentIndex - startIndex - 1)));
                    end;
                    if stringArgument[currentIndex] == 58 then
                        local substitutionData = substitutionStack[1];
                        if substitutionData[2] then
                            errorFunction("malformed substitution pattern", 3);
                        end;
                        substitutionData[2] = table.move(substringList, substitutionData[3], #substringList, 1, table.create(#substringList + 1 - substitutionData[3]));
                        local substringListLength = #substringList;
                        for index = substringListLength, substitutionData[3], -1 do
                            substringList[index] = nil;
                        end;
                    elseif stringArgument[currentIndex] == 125 then
                        local removedSubstitution = table.remove(substitutionStack, 1);
                        local movedTable = table.move(substringList, removedSubstitution[3], #substringList, 1, table.create(#substringList + 1 - removedSubstitution[3]));
                        local substringListLength2 = #substringList;
                        for index2 = substringListLength2, removedSubstitution[3], -1 do
                            substringList[index2] = nil;
                        end;
                        table.insert(substringList, { "condition", removedSubstitution[1], removedSubstitution[2] ~= true and (removedSubstitution[2] or movedTable), removedSubstitution[2] and movedTable });
                    elseif stringArgument[currentIndex] then
                        currentIndex = currentIndex + 1;
                        local currentChar = stringArgument[currentIndex];
                        if not currentChar then
                            if stringArgument[currentIndex - 1] == 92 then
                                errorFunction("replacement string must not end with a trailing backslash", 3);
                            end;
                            local lastSubstring = substringList[#substringList];
                            if type(lastSubstring) == "table" then
                                table.insert(lastSubstring, stringArgument[currentIndex - 1]);
                            else
                                table.insert(substringList, { stringArgument[currentIndex - 1] });
                            end;
                        elseif currentChar == 92 and stringArgument[currentIndex - 1] == 36 then
                            local lastItem = substringList[#substringList];
                            if type(lastItem) == "table" then
                                table.insert(lastItem, 36);
                            else
                                table.insert(substringList, { 36 });
                            end;
                            currentIndex = currentIndex - 1;
                            offset = offset + 1;
                        elseif currentChar == 48 then
                            table.insert(substringList, 0);
                        elseif 48 < currentChar and currentChar <= 57 then
                            local tempValue2 = currentIndex;
                            local captureNumberString = currentChar - 48;
                            while stringArgument[currentIndex + 1] and 48 <= stringArgument[currentIndex + 1] and stringArgument[currentIndex + 1] <= 57 do
                                captureNumberString = captureNumberString .. stringArgument[currentIndex + 1] - 48;
                                currentIndex = currentIndex + 1;
                            end;
                            local captureNumber = tonumber(captureNumberString);
                            if not substitutionFlags.u and groupNumber < captureNumber then
                                errorFunction("reference to non-existent subpattern", 3);
                            end;
                            table.insert(substringList, captureNumber);
                        elseif currentChar == 123 and stringArgument[currentIndex - 1] == 36 then
                            currentIndex = currentIndex + 1;
                            local startIndex = currentIndex;
                            while stringArgument[currentIndex] and (48 <= stringArgument[currentIndex] and stringArgument[currentIndex] <= 57 or 65 <= stringArgument[currentIndex] and stringArgument[currentIndex] <= 90 or 97 <= stringArgument[currentIndex] and stringArgument[currentIndex] <= 122 or stringArgument[currentIndex] == 95) do
                                currentIndex = currentIndex + 1;
                            end;
                            if (stringArgument[currentIndex] == 125 or stringArgument[currentIndex] == 58 and (stringArgument[currentIndex + 1] == 43 or stringArgument[currentIndex + 1] == 45)) and currentIndex ~= startIndex then
                                local captureString = substringByCodePoints(stringArgument.s, startIndex, currentIndex);
                                local groupId;
                                if 48 <= stringArgument[startIndex] and stringArgument[startIndex] <= 57 then
                                    groupId = tonumber(captureString);
                                    if not substitutionFlags.u and groupNumber < groupId then
                                        errorFunction("reference to non-existent subpattern", 3);
                                    end;
                                else
                                    groupId = tokenData.group_id[captureString];
                                    if not substitutionFlags.u and (not groupId or groupNumber < groupId) then
                                        errorFunction("reference to non-existent subpattern", 3);
                                    end;
                                end;
                                if stringArgument[currentIndex] == 58 then
                                    currentIndex = currentIndex + 1;
                                    table.insert(substitutionStack, { groupId, stringArgument[currentIndex] == 45, #substringList + 1 });
                                else
                                    table.insert(substringList, groupId);
                                end;
                            else
                                errorFunction("malformed substitution pattern", 3);
                            end;
                        else
                            local escapeCharacter = nil;
                            if stringArgument[currentIndex - 1] == 36 then
                                if currentChar ~= 36 then
                                    local lastElement = substringList[#substringList];
                                    if type(lastElement) == "table" then
                                        table.insert(lastElement, 36);
                                    else
                                        table.insert(substringList, { 36 });
                                    end;
                                end;
                            else
                                escapeCharacter = characterClasses[stringArgument[currentIndex]];
                                if type(escapeCharacter) ~= "number" then
                                    escapeCharacter = nil;
                                end;
                            end;
                            local lastSubstring2 = substringList[#substringList];
                            if type(lastSubstring2) == "table" then
                                table.insert(lastSubstring2, escapeCharacter or stringArgument[currentIndex]);
                            else
                                table.insert(substringList, { escapeCharacter or stringArgument[currentIndex] });
                            end;
                            offset = offset + 1;
                        end;
                    end;
                    startIndex = currentIndex;
                end;
                if substitutionStack[1] then
                    errorFunction("malformed substitution pattern", 3);
                end;
                if not substringList[2] and type(substringList[1]) == "table" and substringList[1][1] ~= "condition" then
                    stringArgument, stringArgument.n = substringList[1], #substringList[1];
                else
                    stringArgument = substringList;
                    substitutionType = "subst_string";
                end;
            end;
        end;
        local processedString = utf8Substring(stringOrFunctionArgument);
        local offset = 0;
        local searchIndex = 1;
        local substitutionCount = 0;
        while searchIndex <= processedString.n + offset + 1 do
            local matchResult = matchRegexPattern(tokenData.token, processedString, searchIndex, tokenData.flags, tokenData.verb_flags, false);
            if not matchResult then
                return utf8CharFromTable(processedString), substitutionCount;
            end;
            local replacementString = nil;
            if substitutionType == "string" then
                replacementString = stringArgument;
            elseif substitutionType == "subst_string" then
                replacementString = applyCondition(table.create(offset), processedString, matchResult, stringArgument);
            else
                local unknownValue22 = nil;
                local unknownValue23 = nil;
                local capturedSubstring, tableValue;
                if substitutionType == "table" then
                    capturedSubstring = substringByCodePoints(processedString.s, matchResult[0][1], matchResult[0][2]);
                    tableValue = stringArgument[capturedSubstring];
                else
                    capturedSubstring = createMatchObject(matchResult, tokenData.group_id, unknownValue24, processedString.s);
                    tableValue = stringArgument(capturedSubstring);
                end;
                if tableValue == capturedSubstring or substitutionFlags.o and not tableValue then
                    local matchedLength = matchResult[0][2] - matchResult[0][1];
                    replacementString = table.move(processedString, matchResult[0][1], matchResult[0][2] - 1, 1, table.create(matchedLength));
                    replacementString.n = matchedLength;
                elseif type(tableValue) == "string" then
                    replacementString = utf8Substring(tableValue);
                elseif type(tableValue) == "number" then
                    replacementString = utf8Substring(tableValue .. "");
                elseif substitutionFlags.o then
                    errorFunction(string.format("invalid replacement value (a %s)", type(tableValue)), 3);
                else
                    replacementString = { n = 0 };
                end;
            end;
            local rangeDifference = matchResult[0][2] - matchResult[0][1];
            local minimumRange = math.min(replacementString.n, rangeDifference);
            for index = 0, minimumRange - 1, 1 do
                processedString[matchResult[0][1] + index] = replacementString[index + 1];
            end;
            local startIndex = matchResult[0][1] + minimumRange;
            searchIndex = matchResult[0][2];
            if replacementString.n < rangeDifference then
                for removeIndex = 1, rangeDifference - replacementString.n, 1 do
                    table.remove(processedString, startIndex);
                    offset = offset - 1;
                    searchIndex = searchIndex - 1;
                end;
            elseif rangeDifference < replacementString.n then
                for insertIndex = 1, replacementString.n - rangeDifference, 1 do
                    table.insert(processedString, startIndex + insertIndex - 1, replacementString[minimumRange + insertIndex]);
                    offset = offset + 1;
                    searchIndex = searchIndex + 1;
                end;
            end;
            if rangeDifference <= 0 then
                searchIndex = searchIndex + 1;
            end;
            substitutionCount = substitutionCount + 1;
            if numberArgument < substitutionCount + 1 then
                return utf8CharFromTable(processedString), substitutionCount;
            end;
        end;
        return utf8CharFromTable(processedString), substitutionCount;
    end);
    regexMetatable.split = createMethod("RegEx", "split", function(token8, unknownValue5, limit)
        if tonumber(limit) then
            limit = tonumber(limit);
            if limit <= -1 or limit ~= limit then
                limit = math.huge;
            end;
        elseif limit ~= nil then
            errorFunction(string.format("invalid argument #3 to 'split' (number expected, got %s)", typeofFunction(limit)), 3);
        else
            limit = math.huge;
        end;
        local tokenizedString = utf8Substring(unknownValue5);
        local currentIndex = 1;
        local splitCount = 0;
        local substringsList = {};
        local isFirstCharGreaterOrEqual = 0;
        while currentIndex <= tokenizedString.n + 1 do
            splitCount = splitCount + 1;
            local tokenResult = limit >= splitCount and matchRegexPattern(token8.token, tokenizedString, currentIndex, token8.flags, token8.verb_flags, false);
            if not tokenResult then
                break;
            end;
            table.insert(substringsList, substringByCodePoints(tokenizedString.s, currentIndex - isFirstCharGreaterOrEqual, tokenResult[0][1]));
            isFirstCharGreaterOrEqual = tokenResult[0][1] >= tokenResult[0][2] and 1 or 0;
            currentIndex = tokenResult[0][2] + isFirstCharGreaterOrEqual;
        end;
        table.insert(substringsList, string.sub(tokenizedString.s, utf8.offset(tokenizedString.s, currentIndex - isFirstCharGreaterOrEqual)));
        return substringsList;
    end);
    local getFlag = function(flag1, flagIndex)
        return regexMetatable[flagIndex] or matchCache[flag1].flags[flagIndex];
    end;
    local toStringFunction = function(patternIndex)
        return matchCache[patternIndex].pattern_repr .. matchCache[patternIndex].flag_repr;
    end;
    local characterSet = { [58] = true, [33] = true, [61] = true, [62] = true, [124] = true };
    local parseRegex = function(stringData, options)
        local isParsing = false;
        local isOptional = false;
        local isOptional = false;
        if options.unicode and not unicodeDataOptions.unicodeData then
            return "options.unicodeData cannot be turned off while having unicode flag";
        end;
        local parseIndex = 1;
        local stringLength = stringData.n;
        local subpatternIndex = 0;
        local subpatternList = {};
        local subpatternMap = {};
        local newlineSettings = { newline = 1, newline_seq = 1, not_empty = 0 };
        while parseIndex <= stringLength do
            local currentChar = stringData[parseIndex];
            repeat
                if not isOptional and currentChar == 40 then
                    local subpatternData = nil;
                    if stringData[parseIndex + 1] == 42 then
                        parseIndex = parseIndex + 2;
                        local startIndex2 = parseIndex;
                        while stringData[parseIndex] and (48 <= stringData[parseIndex] and stringData[parseIndex] <= 57 or 65 <= stringData[parseIndex] and stringData[parseIndex] <= 90 or 97 <= stringData[parseIndex] and stringData[parseIndex] <= 122 or stringData[parseIndex] == 95 or stringData[parseIndex] == 58) do
                            parseIndex = parseIndex + 1;
                        end;
                        if stringData[parseIndex] ~= 41 and stringData[parseIndex - 1] ~= 58 then
                            return "quantifier doesn't follow a repeatable pattern";
                        end;
                        local tokenString = substringByCodePoints(stringData.s, startIndex2, parseIndex);
                        if tokenString == "positive_lookahead:" or tokenString == "negative_lookhead:" or tokenString == "positive_lookbehind:" or tokenString == "negative_lookbehind:" or tokenString:find("^[pn]l[ab]:$") then
                            subpatternData = { 40, nil, nil, tokenString:find("^n") and 33 or 61, tokenString:find("b", 3, true) and 1 };
                        elseif tokenString == "atomic:" then
                            subpatternData = { 40, nil, nil, 62, nil };
                        elseif tokenString == "ACCEPT" or tokenString == "FAIL" or tokenString == "F" or tokenString == "PRUNE" or tokenString == "SKIP" then
                            subpatternData = tokenString == "F" and "FAIL" or tokenString;
                        else
                            if newlineConstants[tokenString] then
                                newlineSettings.newline = tokenString;
                            elseif tokenString == "BSR_ANYCRLF" or tokenString == "BSR_UNICODE" then
                                newlineSettings.newline_seq = tokenString == "BSR_UNICODE" and 1 or 0;
                            else
                                if tokenString ~= "NOTEMPTY" and tokenString ~= "NOTEMPTY_ATSTART" then
                                    return "unknown or malformed verb";
                                end;
                                newlineSettings.not_empty = tokenString == "NOTEMPTY" and 1 or 2;
                            end;
                            if subpatternList[1] then
                                return "this verb must be placed at the beginning of the regex";
                            end;
                        end;
                        isOptional = true;
                    end;
                    repeat
                        if isOptional or (isOptional or stringData[parseIndex + 1] ~= 63) then
                            if not isOptional then
                                if not isOptional then
                                    subpatternIndex = subpatternIndex + 1;
                                    subpatternData = { 40, subpatternIndex, nil, nil };
                                end;
                            end;
                            isOptional = false;
                            if subpatternData then
                                table.insert(subpatternList, subpatternData);
                            end;
                            isOptional = true;
                        end;
                        if isOptional then
                            break;
                        end;
                        parseIndex = parseIndex + 2;
                        if stringData[parseIndex] ~= 35 then
                            if not stringData[parseIndex] then
                                return "unterminated parenthetical";
                            end;
                            subpatternData = { 40, nil, nil, stringData[parseIndex], nil };
                            if stringData[parseIndex] == 48 and stringData[parseIndex + 1] == 41 then
                                local nilValue = nil;
                                subpatternData[1] = "recurmatch";
                                subpatternData[2] = 0;
                                subpatternData[3] = 0;
                                subpatternData[5] = nilValue;
                            elseif 48 < stringData[parseIndex] and stringData[parseIndex] <= 57 then
                                local startIndex3 = parseIndex;
                                parseIndex = parseIndex + 1;
                                while 48 <= stringData[parseIndex] and stringData[parseIndex] <= 48 do
                                    parseIndex = parseIndex + 1;
                                end;
                                if stringData[parseIndex] ~= 41 then
                                    return "invalid group structure";
                                end;
                                local subpatternNumber = tonumber(substringByCodePoints(stringData.s, startIndex3, parseIndex));
                                local nilValue2 = nil;
                                subpatternData[1] = "recurmatch";
                                subpatternData[2] = subpatternNumber;
                                subpatternData[4] = nilValue2;
                            elseif stringData[parseIndex] == 60 and stringData[parseIndex + 1] == 33 or stringData[parseIndex + 1] == 61 then
                                parseIndex = parseIndex + 1;
                                subpatternData[4] = stringData[parseIndex];
                                subpatternData[5] = 1;
                            elseif stringData[parseIndex] == 124 then
                                subpatternData[5] = subpatternIndex;
                            elseif stringData[parseIndex] == 80 or stringData[parseIndex] == 60 or stringData[parseIndex] == 39 then
                                if stringData[parseIndex] == 80 then
                                    parseIndex = parseIndex + 1;
                                end;
                                if stringData[parseIndex] == 61 then
                                    local nextIndex = parseIndex + 1;
                                    while stringData[parseIndex] and (48 <= stringData[parseIndex] and stringData[parseIndex] <= 57 or 65 <= stringData[parseIndex] and stringData[parseIndex] <= 90 or 97 <= stringData[parseIndex] and stringData[parseIndex] <= 122 or stringData[parseIndex] == 95) do
                                        parseIndex = parseIndex + 1;
                                    end;
                                    if not stringData[parseIndex] then
                                        return "unterminated parenthetical";
                                    end;
                                    if stringData[parseIndex] ~= 41 or parseIndex == nextIndex then
                                        return "invalid group structure";
                                    end;
                                    subpatternData = { "backref", substringByCodePoints(stringData.s, nextIndex, parseIndex) };
                                else
                                    if stringData[parseIndex] ~= 60 and (stringData[parseIndex - 1] == 80 or stringData[parseIndex] ~= 39) then
                                        return "invalid group structure";
                                    end;
                                    local subpatternDelimiter = stringData[parseIndex] == 39 and 39 or 62;
                                    local nextIndex = parseIndex + 1;
                                    local subpatternNameIndex = parseIndex + 1;
                                    if stringData[subpatternNameIndex] == 41 then
                                        return "missing character in subpattern";
                                    end;
                                    if 48 <= stringData[subpatternNameIndex] and stringData[subpatternNameIndex] <= 57 then
                                        return "subpattern name must not begin with a digit";
                                    end;
                                    if (not (65 <= stringData[subpatternNameIndex]) or not (stringData[subpatternNameIndex] <= 90)) and (not (97 <= stringData[subpatternNameIndex]) or not (stringData[subpatternNameIndex] <= 122)) and stringData[subpatternNameIndex] ~= 95 then
                                        return "invalid character in subpattern";
                                    end;
                                    parseIndex = subpatternNameIndex + 1;
                                    while stringData[parseIndex] and (48 <= stringData[parseIndex] and stringData[parseIndex] <= 57 or 65 <= stringData[parseIndex] and stringData[parseIndex] <= 90 or 97 <= stringData[parseIndex] and stringData[parseIndex] <= 122 or stringData[parseIndex] == 95) do
                                        parseIndex = parseIndex + 1;
                                    end;
                                    if not stringData[parseIndex] then
                                        return "unterminated parenthetical";
                                    end;
                                    if stringData[parseIndex] ~= subpatternDelimiter then
                                        return "invalid character in subpattern";
                                    end;
                                    local subpatternName = substringByCodePoints(stringData.s, nextIndex, parseIndex);
                                    subpatternIndex = subpatternIndex + 1;
                                    if (subpatternMap[subpatternName] or subpatternIndex) ~= subpatternIndex then
                                        return "subpattern name already exists";
                                    end;
                                    for existingName, existingSubpatternNumber in pairsFunction(subpatternMap) do
                                        if subpatternName ~= existingName and subpatternIndex == existingSubpatternNumber then
                                            return "different names for subpatterns of the same number aren't permitted";
                                        end;
                                    end;
                                    subpatternMap[subpatternName] = subpatternIndex;
                                    local nilValue3 = nil;
                                    subpatternData[2] = subpatternIndex;
                                    subpatternData[4] = nilValue3;
                                end;
                            elseif not characterSet[stringData[parseIndex]] then
                                return "invalid group structure";
                            end;
                            isOptional = true;
                        end;
                    until not isOptional;
                    if not isOptional then
                        local closingParenthesisIndex = table.find(stringData, 41, parseIndex);
                        if not closingParenthesisIndex then
                            return "unterminated parenthetical";
                        end;
                        parseIndex = closingParenthesisIndex + 1;
                    end;
                else
                    if not isOptional then
                        if currentChar == 41 then
                            local currentIndex = #subpatternList + 1;
                            local captureIndex = -1;
                            local characterCount = 0;
                            local maxCount = 0;
                            local count = 0;
                            repeat
                                currentIndex = currentIndex - 1;
                                local element = subpatternList[currentIndex];
                                local isTable = type(subpatternList[currentIndex]) == "table";
                                if isTable and element[1] == 40 then
                                    count = count + 1;
                                    if characterCount and element.count then
                                        characterCount = characterCount + element.count;
                                    end;
                                    if not element[3] then
                                        if element[4] == 124 then
                                            subpatternIndex = element[5] + math.max(maxCount, count);
                                        end;
                                        if characterCount ~= captureIndex and captureIndex ~= -1 then
                                            captureIndex = nil;
                                        else
                                            captureIndex = characterCount;
                                        end;
                                        break;
                                    end;
                                elseif element == pipeCharacter then
                                    if characterCount ~= captureIndex and captureIndex ~= -1 then
                                        captureIndex, characterCount = nil, nil;
                                    else
                                        captureIndex = characterCount;
                                        characterCount = 0;
                                    end;
                                    maxCount = math.max(maxCount, count);
                                    count = 0;
                                elseif characterCount then
                                    if isTable and element[1] == "quantifier" then
                                        if element[2] == element[3] then
                                            characterCount = characterCount + element[2];
                                        else
                                            characterCount = nil;
                                        end;
                                    else
                                        characterCount = characterCount + 1;
                                    end;
                                end;
                            until currentIndex < 1;
                            if currentIndex < 1 then
                                return "unmatched ) in regular expression";
                            end;
                            local elementData = subpatternList[currentIndex];
                            local newGroupIndex = #subpatternList + 1;
                            local newElement = { 41, elementData[2], currentIndex, elementData[4], elementData[5], count = captureIndex };
                            if (elementData[4] == 33 or elementData[4] == 61) and elementData[5] and not captureIndex then
                                return "lookbehind assertion is not fixed width";
                            end;
                            elementData[3] = newGroupIndex;
                            table.insert(subpatternList, newElement);
                        elseif currentChar == 46 then
                            table.insert(subpatternList, numberArray);
                        elseif currentChar == 91 then
                            local isCharset = false;
                            local currentCode = nil;
                            parseIndex = parseIndex + 1;
                            local startIndex4 = parseIndex;
                            if stringData[parseIndex] == 94 then
                                isCharset = true;
                                parseIndex = parseIndex + 1;
                            elseif stringData[parseIndex] == 46 or stringData[parseIndex] == 58 or stringData[parseIndex] == 61 then
                                currentCode = stringData[parseIndex];
                            end;
                            local unknownValue25 = nil;
                            local characterClass;
                            if stringData[parseIndex] == 91 or stringData[parseIndex] == 92 then
                                characterClass = {};
                            else
                                characterClass = { stringData[parseIndex] };
                                parseIndex = parseIndex + 1;
                            end;
                            while stringData[parseIndex] ~= 93 do
                                if not stringData[parseIndex] then
                                    return "unterminated character class";
                                end;
                                if stringData[parseIndex] == 45 and characterClass[1] and type(characterClass[1]) == "number" then
                                    if stringData[parseIndex + 1] == 93 then
                                        table.insert(characterClass, 1, 45);
                                    else
                                        parseIndex = parseIndex + 1;
                                        local characterCode = stringData[parseIndex];
                                        if characterCode == 91 then
                                            if stringData[parseIndex + 1] == 46 or stringData[parseIndex + 1] == 58 or stringData[parseIndex + 1] == 61 then
                                                local closingBracketIndex = parseIndex + 2;
                                                repeat
                                                    closingBracketIndex = table.find(stringData, 93, closingBracketIndex);
                                                until not closingBracketIndex or stringData[closingBracketIndex - 1] ~= 92;
                                                if not closingBracketIndex then
                                                    return "unterminated character class";
                                                end;
                                                if stringData[closingBracketIndex - 1] == stringData[parseIndex + 1] and closingBracketIndex - 1 ~= parseIndex + 1 then
                                                    return "invalid range in character class";
                                                end;
                                            end;
                                            if 91 < characterClass[1] then
                                                return "invalid range in character class";
                                            end;
                                        elseif characterCode == 92 then
                                            parseIndex = parseIndex + 1;
                                            if stringData[parseIndex] == 120 then
                                                local hexDigit1 = nil;
                                                local hexDigit2 = nil;
                                                local hexDigit1Index = parseIndex + 1;
                                                if stringData[hexDigit1Index] and 48 <= stringData[hexDigit1Index] and stringData[hexDigit1Index] <= 57 or 65 <= stringData[hexDigit1Index] and stringData[hexDigit1Index] <= 70 or 97 <= stringData[hexDigit1Index] and stringData[hexDigit1Index] <= 102 then
                                                    hexDigit1 = stringData[hexDigit1Index] - (stringData[hexDigit1Index] >= 65 and stringData[hexDigit1Index] <= 90 and 55 or stringData[hexDigit1Index] >= 97 and stringData[hexDigit1Index] <= 122 and 87 or 48);
                                                    parseIndex = hexDigit1Index + 1;
                                                    if stringData[parseIndex] and 48 <= stringData[parseIndex] and stringData[parseIndex] <= 57 or 65 <= stringData[parseIndex] and stringData[parseIndex] <= 70 or 97 <= stringData[parseIndex] and stringData[parseIndex] <= 102 then
                                                        hexDigit2 = stringData[parseIndex] - (stringData[parseIndex] >= 65 and stringData[parseIndex] <= 90 and 55 or stringData[parseIndex] >= 97 and stringData[parseIndex] <= 122 and 87 or 48);
                                                    else
                                                        parseIndex = parseIndex - 1;
                                                    end;
                                                else
                                                    parseIndex = hexDigit1Index - 1;
                                                end;
                                                characterCode = hexDigit1 and (hexDigit2 and 16 * hexDigit1 + hexDigit2 or hexDigit1) or 0;
                                            elseif 48 <= stringData[parseIndex] and stringData[parseIndex] <= 55 then
                                                local digitValue = stringData[parseIndex] - 48;
                                                local octalDigit1 = nil;
                                                local octalDigit2 = nil;
                                                local octalDigit1Index = parseIndex + 1;
                                                if stringData[octalDigit1Index] and 48 <= stringData[octalDigit1Index] and stringData[octalDigit1Index] <= 55 then
                                                    octalDigit1 = stringData[octalDigit1Index] - 48;
                                                    parseIndex = octalDigit1Index + 1;
                                                    if stringData[parseIndex] and 48 <= stringData[parseIndex] and stringData[parseIndex] <= 55 then
                                                        octalDigit2 = stringData[parseIndex] - 48;
                                                    else
                                                        parseIndex = parseIndex - 1;
                                                    end;
                                                else
                                                    parseIndex = octalDigit1Index - 1;
                                                end;
                                                characterCode = octalDigit1 and (octalDigit2 and 64 * digitValue + 8 * octalDigit1 + octalDigit2 or 8 * digitValue + octalDigit1) or digitValue;
                                            else
                                                characterCode = characterClasses[stringData[parseIndex]] or stringData[parseIndex];
                                                if type(characterCode) ~= "number" then
                                                    return "invalid range in character class";
                                                end;
                                            end;
                                        elseif characterCode < characterClass[1] then
                                            return "invalid range in character class";
                                        end;
                                        characterClass[1] = { "range", characterClass[1], characterCode };
                                    end;
                                elseif stringData[parseIndex] == 91 then
                                    if stringData[parseIndex + 1] == 46 or stringData[parseIndex + 1] == 58 or stringData[parseIndex + 1] == 61 then
                                        local closingBracketIndex = parseIndex + 2;
                                        repeat
                                            closingBracketIndex = table.find(stringData, 93, closingBracketIndex);
                                        until not closingBracketIndex or stringData[closingBracketIndex - 1] ~= 92;
                                        if not closingBracketIndex then
                                            return "unterminated character class";
                                        end;
                                        if stringData[closingBracketIndex - 1] ~= stringData[parseIndex + 1] or closingBracketIndex - 1 == parseIndex + 1 then
                                            table.insert(characterClass, 1, 91);
                                        else
                                            if stringData[closingBracketIndex - 1] == 46 or stringData[closingBracketIndex - 1] == 61 then
                                                return "POSIX collating elements aren't supported";
                                            end;
                                            if stringData[closingBracketIndex - 1] == 58 then
                                                local isNegated = stringData[parseIndex + 3] == 94;
                                                local posixClassName = substringByCodePoints(stringData.s, parseIndex + (isNegated and 3 or 2), closingBracketIndex - 1);
                                                if not posixClasses[posixClassName] then
                                                    return "unknown POSIX class name";
                                                end;
                                                table.insert(characterClass, 1, { "class", posixClassName, isNegated });
                                                parseIndex = closingBracketIndex;
                                            end;
                                        end;
                                    else
                                        table.insert(characterClass, 1, 91);
                                    end;
                                elseif stringData[parseIndex] == 92 then
                                    parseIndex = parseIndex + 1;
                                    if stringData[parseIndex] == 120 then
                                        local hexDigit1Value = nil;
                                        local hexDigit2Value = nil;
                                        local hexDigit1Index2 = parseIndex + 1;
                                        if stringData[hexDigit1Index2] == 123 then
                                            parseIndex = hexDigit1Index2 + 1;
                                            local hexStartIndex = parseIndex;
                                            while stringData[parseIndex] and (48 <= stringData[parseIndex] and stringData[parseIndex] <= 57 or 65 <= stringData[parseIndex] and stringData[parseIndex] <= 70 or 97 <= stringData[parseIndex] and stringData[parseIndex] <= 102) do
                                                parseIndex = parseIndex + 1;
                                            end;
                                            if stringData[parseIndex] ~= 125 or parseIndex == hexStartIndex then
                                                return "malformed hexadecimal character";
                                            end;
                                            if 4 < parseIndex - hexStartIndex then
                                                return "character offset too large";
                                            end;
                                            table.insert(characterClass, 1, tonumber(substringByCodePoints(stringData.s, hexStartIndex, parseIndex), 16));
                                        else
                                            if stringData[hexDigit1Index2] and 48 <= stringData[hexDigit1Index2] and stringData[hexDigit1Index2] <= 57 or 65 <= stringData[hexDigit1Index2] and stringData[hexDigit1Index2] <= 70 or 97 <= stringData[hexDigit1Index2] and stringData[hexDigit1Index2] <= 102 then
                                                hexDigit1Value = stringData[hexDigit1Index2] - (stringData[hexDigit1Index2] >= 65 and stringData[hexDigit1Index2] <= 90 and 55 or stringData[hexDigit1Index2] >= 97 and stringData[hexDigit1Index2] <= 122 and 87 or 48);
                                                parseIndex = hexDigit1Index2 + 1;
                                                if stringData[parseIndex] and 48 <= stringData[parseIndex] and stringData[parseIndex] <= 57 or 65 <= stringData[parseIndex] and stringData[parseIndex] <= 70 or 97 <= stringData[parseIndex] and stringData[parseIndex] <= 102 then
                                                    hexDigit2Value = stringData[parseIndex] - (stringData[parseIndex] >= 65 and stringData[parseIndex] <= 90 and 55 or stringData[parseIndex] >= 97 and stringData[parseIndex] <= 122 and 87 or 48);
                                                else
                                                    parseIndex = parseIndex - 1;
                                                end;
                                            else
                                                parseIndex = hexDigit1Index2 - 1;
                                            end;
                                            table.insert(characterClass, 1, hexDigit1Value and (hexDigit2Value and 16 * hexDigit1Value + hexDigit2Value or hexDigit1Value) or 0);
                                        end;
                                    elseif 48 <= stringData[parseIndex] and stringData[parseIndex] <= 55 then
                                        local digitValue = stringData[parseIndex] - 48;
                                        local octalDigit1Value = nil;
                                        local octalDigit2Value = nil;
                                        local octalDigit1Index2 = parseIndex + 1;
                                        if stringData[octalDigit1Index2] and 48 <= stringData[octalDigit1Index2] and stringData[octalDigit1Index2] <= 55 then
                                            octalDigit1Value = stringData[octalDigit1Index2] - 48;
                                            parseIndex = octalDigit1Index2 + 1;
                                            if stringData[parseIndex] and 48 <= stringData[parseIndex] and stringData[parseIndex] <= 55 then
                                                octalDigit2Value = stringData[parseIndex] - 48;
                                            else
                                                parseIndex = parseIndex - 1;
                                            end;
                                        else
                                            parseIndex = octalDigit1Index2 - 1;
                                        end;
                                        table.insert(characterClass, 1, octalDigit1Value and (octalDigit2Value and 64 * digitValue + 8 * octalDigit1Value + octalDigit2Value or 8 * digitValue + octalDigit1Value) or digitValue);
                                    elseif stringData[parseIndex] ~= 69 then
                                        if stringData[parseIndex] == 81 then
                                            local insertionIndex = parseIndex + 1;
                                            repeat
                                                parseIndex = table.find(stringData, 92, parseIndex + 1);
                                            until not parseIndex or stringData[parseIndex + 1] == 69;
                                            table.move(stringData, insertionIndex, parseIndex and parseIndex - 1 or #stringData, #subpatternList + 1, subpatternList);
                                            if not parseIndex then
                                                break;
                                            end;
                                            parseIndex = parseIndex + 1;
                                        elseif stringData[parseIndex] == 78 then
                                            if stringData[parseIndex + 1] ~= 123 or stringData[parseIndex + 2] ~= 85 or stringData[parseIndex + 3] ~= 43 or not options.unicode then
                                                return "invalid escape sequence";
                                            end;
                                            parseIndex = parseIndex + 4;
                                            local unicodeStartIndex = parseIndex;
                                            while stringData[parseIndex] and (48 <= stringData[parseIndex] and stringData[parseIndex] <= 57 or 65 <= stringData[parseIndex] and stringData[parseIndex] <= 70 or 97 <= stringData[parseIndex] and stringData[parseIndex] <= 102) do
                                                parseIndex = parseIndex + 1;
                                            end;
                                            if stringData[parseIndex] ~= 125 or parseIndex == unicodeStartIndex then
                                                return "malformed Unicode code point";
                                            end;
                                            local unicodeValue = tonumber(substringByCodePoints(stringData.s, unicodeStartIndex, parseIndex));
                                            table.insert(characterClass, 1, unicodeValue);
                                        elseif stringData[parseIndex] == 80 or stringData[parseIndex] == 112 then
                                            if not unicodeDataOptions.unicodeData then
                                                return "options.unicodeData cannot be turned off when using \\p";
                                            end;
                                            parseIndex = parseIndex + 1;
                                            if stringData[parseIndex] ~= 123 then
                                                local utf8Character = utf8.char(stringData[parseIndex] or 0);
                                                if not unicodeCategories[utf8Character] then
                                                    return "unknown or malformed script name";
                                                end;
                                                table.insert(characterClass, 1, { "category", false, utf8Character });
                                            else
                                                local isCategoryNegated = stringData[parseIndex] == 80;
                                                parseIndex = parseIndex + 1;
                                                if stringData[parseIndex] == 94 then
                                                    parseIndex = parseIndex + 1;
                                                    isCategoryNegated = not isCategoryNegated;
                                                end;
                                                local escapeSequence = parseIndex;
                                                while stringData[parseIndex] and (48 <= stringData[parseIndex] and stringData[parseIndex] <= 57 or 65 <= stringData[parseIndex] and stringData[parseIndex] <= 90 or 97 <= stringData[parseIndex] and stringData[parseIndex] <= 122 or stringData[parseIndex] == 95) do
                                                    parseIndex = parseIndex + 1;
                                                end;
                                                if stringData[parseIndex] ~= 125 then
                                                    return "unknown or malformed script name";
                                                end;
                                                local scriptName = substringByCodePoints(stringData.s, escapeSequence, parseIndex);
                                                local characterSet = unicodeScriptsData[scriptName];
                                                if characterSet then
                                                    table.insert(characterClass, 1, { "charset", isCategoryNegated, characterSet });
                                                else
                                                    if not unicodeCategories[scriptName] then
                                                        return "unknown or malformed script name";
                                                    end;
                                                    table.insert(characterClass, 1, { "category", isCategoryNegated, scriptName });
                                                end;
                                            end;
                                        elseif stringData[parseIndex] == 111 then
                                            local octalCodeIndex = parseIndex + 1;
                                            if stringData[octalCodeIndex] ~= 123 then
                                                return "malformed octal code";
                                            end;
                                            parseIndex = octalCodeIndex + 1;
                                            local octalStartIndex = parseIndex;
                                            while stringData[parseIndex] and 48 <= stringData[parseIndex] and stringData[parseIndex] <= 55 do
                                                parseIndex = parseIndex + 1;
                                            end;
                                            if stringData[parseIndex] ~= 125 or parseIndex == octalStartIndex then
                                                return "malformed octal code";
                                            end;
                                            local characterOffset = tonumber(substringByCodePoints(stringData.s, octalStartIndex, parseIndex), 8);
                                            if 65535 < characterOffset then
                                                return "character offset too large";
                                            end;
                                            table.insert(characterClass, 1, characterOffset);
                                        else
                                            local lookupValue = characterClasses[stringData[parseIndex]];
                                            table.insert(characterClass, 1, type(lookupValue) == "string" and { "class", lookupValue, false } or lookupValue or stringData[parseIndex]);
                                        end;
                                    end;
                                elseif options.ignoreCase and 97 <= stringData[parseIndex] and stringData[parseIndex] <= 122 then
                                    table.insert(characterClass, 1, stringData[parseIndex] - 32);
                                else
                                    table.insert(characterClass, 1, stringData[parseIndex]);
                                end;
                                parseIndex = parseIndex + 1;
                            end;
                            if stringData[parseIndex - 1] == currentCode and parseIndex - 1 ~= startIndex4 then
                                return currentCode == 58 and "POSIX named classes are only support within a character set" or "POSIX collating elements aren't supported";
                            end;
                            if not characterClass[2] and not isCharset then
                                table.insert(subpatternList, characterClass[1]);
                            else
                                table.insert(subpatternList, { "charset", isCharset, characterClass });
                            end;
                        elseif currentChar == 92 then
                            parseIndex = parseIndex + 1;
                            local currentCharacterCode = stringData[parseIndex];
                            if not currentCharacterCode then
                                return "pattern may not end with a trailing backslash";
                            end;
                            if 48 <= currentCharacterCode and currentCharacterCode <= 57 then
                                local octalStartIndex = parseIndex;
                                while stringData[parseIndex + 1] and 48 <= stringData[parseIndex + 1] and stringData[parseIndex + 1] <= 57 do
                                    parseIndex = parseIndex + 1;
                                end;
                                local numberFromPattern = tonumber(substringByCodePoints(stringData.s, octalStartIndex, parseIndex + 1));
                                if subpatternIndex < numberFromPattern and parseIndex ~= octalStartIndex then
                                    parseIndex = octalStartIndex;
                                    local digit1 = nil;
                                    local digit2 = nil;
                                    local digitValue = nil;
                                    if stringData[parseIndex] <= 55 then
                                        digit1 = stringData[parseIndex] - 48;
                                        local nextIndex = parseIndex + 1;
                                        if stringData[nextIndex] and 48 <= stringData[nextIndex] and stringData[nextIndex] <= 55 then
                                            digit2 = stringData[nextIndex] - 48;
                                            parseIndex = nextIndex + 1;
                                            if stringData[parseIndex] and 48 <= stringData[parseIndex] and stringData[parseIndex] <= 55 then
                                                digitValue = stringData[parseIndex] - 48;
                                            else
                                                parseIndex = parseIndex - 1;
                                            end;
                                        else
                                            parseIndex = nextIndex - 1;
                                        end;
                                    end;
                                    table.insert(subpatternList, digit1 and (digit2 and (digitValue and 64 * digit1 + 8 * digit2 + digitValue or 8 * digit1 + digit2) or digit1) or stringData[octalStartIndex]);
                                else
                                    table.insert(subpatternList, { "backref", numberFromPattern });
                                end;
                            elseif currentCharacterCode ~= 69 then
                                if currentCharacterCode == 81 then
                                    local startIndex = parseIndex + 1;
                                    repeat
                                        parseIndex = table.find(stringData, 92, parseIndex + 1);
                                    until not parseIndex or stringData[parseIndex + 1] == 69;
                                    table.move(stringData, startIndex, parseIndex and parseIndex - 1 or #stringData, #subpatternList + 1, subpatternList);
                                    if not parseIndex then
                                        isParsing = true;
                                        break;
                                    end;
                                    parseIndex = parseIndex + 1;
                                elseif currentCharacterCode == 78 then
                                    if stringData[parseIndex + 1] == 123 and stringData[parseIndex + 2] == 85 and stringData[parseIndex + 3] == 43 and options.unicode then
                                        parseIndex = parseIndex + 4;
                                        local unicodeStartIndex2 = parseIndex;
                                        while stringData[parseIndex] and (48 <= stringData[parseIndex] and stringData[parseIndex] <= 57 or 65 <= stringData[parseIndex] and stringData[parseIndex] <= 70 or 97 <= stringData[parseIndex] and stringData[parseIndex] <= 102) do
                                            parseIndex = parseIndex + 1;
                                        end;
                                        if stringData[parseIndex] ~= 125 or parseIndex == unicodeStartIndex2 then
                                            return "malformed Unicode code point";
                                        end;
                                        local numberValue = tonumber(substringByCodePoints(stringData.s, unicodeStartIndex2, parseIndex));
                                        table.insert(subpatternList, numberValue);
                                    else
                                        table.insert(subpatternList, characterClasses[78]);
                                    end;
                                elseif currentCharacterCode == 80 or currentCharacterCode == 112 then
                                    if not unicodeDataOptions.unicodeData then
                                        return "options.unicodeData cannot be turned off when using \\p";
                                    end;
                                    parseIndex = parseIndex + 1;
                                    if stringData[parseIndex] ~= 123 then
                                        local characterFromCode = utf8.char(stringData[parseIndex] or 0);
                                        if not unicodeCategories[characterFromCode] then
                                            return "unknown or malformed script name";
                                        end;
                                        table.insert(subpatternList, { "category", false, characterFromCode });
                                    else
                                        local isCharset = currentCharacterCode == 80;
                                        parseIndex = parseIndex + 1;
                                        if stringData[parseIndex] == 94 then
                                            parseIndex = parseIndex + 1;
                                            isCharset = not isCharset;
                                        end;
                                        local escapeSequence2 = parseIndex;
                                        while stringData[parseIndex] and (48 <= stringData[parseIndex] and stringData[parseIndex] <= 57 or 65 <= stringData[parseIndex] and stringData[parseIndex] <= 90 or 97 <= stringData[parseIndex] and stringData[parseIndex] <= 122 or stringData[parseIndex] == 95) do
                                            parseIndex = parseIndex + 1;
                                        end;
                                        if stringData[parseIndex] ~= 125 then
                                            return "unknown or malformed script name";
                                        end;
                                        local scriptName = substringByCodePoints(stringData.s, escapeSequence2, parseIndex);
                                        local scriptCategory = unicodeScriptsData[scriptName];
                                        if scriptCategory then
                                            table.insert(subpatternList, { "charset", isCharset, scriptCategory });
                                        else
                                            if not unicodeCategories[scriptName] then
                                                return "unknown or malformed script name";
                                            end;
                                            table.insert(subpatternList, { "category", isCharset, scriptName });
                                        end;
                                    end;
                                elseif currentCharacterCode == 103 and (stringData[parseIndex + 1] == 123 or 48 <= stringData[parseIndex + 1] and stringData[parseIndex + 1] <= 57) then
                                    local isBraced = false;
                                    parseIndex = parseIndex + 1;
                                    if stringData[parseIndex] == 123 then
                                        parseIndex = parseIndex + 1;
                                        isBraced = true;
                                    elseif stringData[parseIndex] < 48 or 57 < stringData[parseIndex] then
                                        return "malformed reference code";
                                    end;
                                    local octalStartIndex2 = parseIndex;
                                    while stringData[parseIndex] and (48 <= stringData[parseIndex] and stringData[parseIndex] <= 57 or 65 <= stringData[parseIndex] and stringData[parseIndex] <= 70 or 97 <= stringData[parseIndex] and stringData[parseIndex] <= 102) do
                                        parseIndex = parseIndex + 1;
                                    end;
                                    if isBraced and stringData[parseIndex] ~= 125 then
                                        return "malformed reference code";
                                    end;
                                    local backReferenceNumber = tonumber(substringByCodePoints(stringData.s, octalStartIndex2, parseIndex + (isBraced and 0 or 1)));
                                    table.insert(subpatternList, { "backref", backReferenceNumber });
                                    if not isBraced then
                                        parseIndex = parseIndex - 1;
                                    end;
                                elseif currentCharacterCode == 111 then
                                    local octalCodeIndex = parseIndex + 1;
                                    if stringData[octalCodeIndex + 1] ~= 123 then
                                        return "malformed octal code";
                                    end;
                                    parseIndex = octalCodeIndex + 1;
                                    local octalStartIndex3 = parseIndex;
                                    while stringData[parseIndex] and 48 <= stringData[parseIndex] and stringData[parseIndex] <= 55 do
                                        parseIndex = parseIndex + 1;
                                    end;
                                    if stringData[parseIndex] ~= 125 or parseIndex == octalStartIndex3 then
                                        return "malformed octal code";
                                    end;
                                    local characterOffset2 = tonumber(substringByCodePoints(stringData.s, octalStartIndex3, parseIndex), 8);
                                    if 65535 < characterOffset2 then
                                        return "character offset too large";
                                    end;
                                    table.insert(subpatternList, characterOffset2);
                                elseif currentCharacterCode == 120 then
                                    local hexDigit1 = nil;
                                    local hexDigit2 = nil;
                                    local nextIndex2 = parseIndex + 1;
                                    if stringData[nextIndex2] == 123 then
                                        parseIndex = nextIndex2 + 1;
                                        local hexStartIndex2 = parseIndex;
                                        while stringData[parseIndex] and (48 <= stringData[parseIndex] and stringData[parseIndex] <= 57 or 65 <= stringData[parseIndex] and stringData[parseIndex] <= 70 or 97 <= stringData[parseIndex] and stringData[parseIndex] <= 102) do
                                            parseIndex = parseIndex + 1;
                                        end;
                                        if stringData[parseIndex] ~= 125 or parseIndex == hexStartIndex2 then
                                            return "malformed hexadecimal code";
                                        end;
                                        if 4 < parseIndex - hexStartIndex2 then
                                            return "character offset too large";
                                        end;
                                        table.insert(subpatternList, tonumber(substringByCodePoints(stringData.s, hexStartIndex2, parseIndex), 16));
                                    else
                                        if stringData[nextIndex2] and (48 <= stringData[nextIndex2] and stringData[nextIndex2] <= 57 or 65 <= stringData[nextIndex2] and stringData[nextIndex2] <= 70 or 97 <= stringData[nextIndex2] and stringData[nextIndex2] <= 102) then
                                            hexDigit1 = stringData[nextIndex2] - (stringData[nextIndex2] >= 65 and stringData[nextIndex2] <= 90 and 55 or stringData[nextIndex2] >= 97 and stringData[nextIndex2] <= 122 and 87 or 48);
                                            parseIndex = nextIndex2 + 1;
                                            if stringData[parseIndex] and (48 <= stringData[parseIndex] and stringData[parseIndex] <= 57 or 65 <= stringData[parseIndex] and stringData[parseIndex] <= 70 or 97 <= stringData[parseIndex] and stringData[parseIndex] <= 102) then
                                                hexDigit2 = stringData[parseIndex] - (stringData[parseIndex] >= 65 and stringData[parseIndex] <= 90 and 55 or stringData[parseIndex] >= 97 and stringData[parseIndex] <= 122 and 87 or 48);
                                            else
                                                parseIndex = parseIndex - 1;
                                            end;
                                        else
                                            parseIndex = nextIndex2 - 1;
                                        end;
                                        table.insert(subpatternList, hexDigit1 and (hexDigit2 and 16 * hexDigit1 + hexDigit2 or hexDigit1) or 0);
                                    end;
                                else
                                    local lookupValue2 = characterClassMap[currentCharacterCode] or characterClasses[currentCharacterCode];
                                    table.insert(subpatternList, lookupValue2 or currentCharacterCode);
                                end;
                            end;
                        elseif currentChar == 42 or currentChar == 43 or currentChar == 63 or currentChar == 123 then
                            local minQuantifier = nil;
                            local maxQuantifier = nil;
                            if currentChar == 123 then
                                local startIndex2 = parseIndex + 1;
                                local commaIndex = nil;
                                while stringData[parseIndex + 1] and (48 <= stringData[parseIndex + 1] and stringData[parseIndex + 1] <= 57 or stringData[parseIndex + 1] == 44 and not commaIndex and parseIndex + 1 ~= startIndex2) do
                                    parseIndex = parseIndex + 1;
                                    if stringData[parseIndex] == 44 then
                                        commaIndex = parseIndex;
                                    end;
                                end;
                                if stringData[parseIndex + 1] == 125 then
                                    parseIndex = parseIndex + 1;
                                    if not commaIndex then
                                        minQuantifier = tonumber(substringByCodePoints(stringData.s, startIndex2, parseIndex));
                                        maxQuantifier = minQuantifier;
                                    else
                                        minQuantifier, maxQuantifier = tonumber(substringByCodePoints(stringData.s, startIndex2, commaIndex)), commaIndex + 1 == parseIndex and math.huge or tonumber(substringByCodePoints(stringData.s, commaIndex + 1, parseIndex));
                                        if maxQuantifier < minQuantifier then
                                            return "numbers out of order in {} quantifier";
                                        end;
                                    end;
                                else
                                    table.move(stringData, startIndex2 - 1, parseIndex, #subpatternList + 1, subpatternList);
                                end;
                            else
                                minQuantifier, maxQuantifier = currentChar == 43 and 1 or 0, currentChar == 63 and 1 or math.huge;
                            end;
                            if minQuantifier then
                                local quantifierType = options.ungreedy and "lazy" or "greedy";
                                if stringData[parseIndex + 1] == 43 or stringData[parseIndex + 1] == 63 then
                                    parseIndex = parseIndex + 1;
                                    quantifierType = stringData[parseIndex] == 43 and "possessive" or options.ungreedy and "greedy" or "lazy";
                                end;
                                local quantifierIndex = #subpatternList;
                                local patternElement = subpatternList[quantifierIndex];
                                if not patternElement or type(patternElement) == "table" and (patternElement[1] == "quantifier" or patternElement[1] == 40 or characterClassMap[patternElement[1]]) or patternElement == pipeCharacter or type(patternElement) == "string" then
                                    return "quantifier doesn't follow a repeatable pattern";
                                end;
                                if maxQuantifier == 0 then
                                    table.remove(subpatternList);
                                elseif minQuantifier ~= 1 or maxQuantifier ~= 1 then
                                    if type(patternElement) == "table" and patternElement[1] == 41 then
                                        quantifierIndex = patternElement[3];
                                    end;
                                    subpatternList[quantifierIndex] = { "quantifier", minQuantifier, maxQuantifier, quantifierType, subpatternList[quantifierIndex] };
                                end;
                            end;
                        elseif currentChar == 124 then
                            table.insert(subpatternList, pipeCharacter);
                            local lastIndex = #subpatternList;
                            repeat
                                lastIndex = lastIndex - 1;
                                local lastElement = subpatternList[lastIndex];
                                local isLastElementTable = type(subpatternList[lastIndex]) == "table";
                                if isLastElementTable and lastElement[1] == 41 then
                                    lastIndex = subpatternList[lastIndex][3];
                                elseif isLastElementTable and lastElement[1] == 40 then
                                    if lastElement[4] == 124 then
                                        subpatternIndex = lastElement[5];
                                    end;
                                    break;
                                end;
                            until not lastElement;
                        elseif currentChar == 36 or currentChar == 94 then
                            table.insert(subpatternList, currentChar == 94 and caretCharacter or defaultValues);
                        elseif options.ignoreCase and 97 <= currentChar and currentChar <= 122 then
                            table.insert(subpatternList, currentChar - 32);
                        elseif options.extended and (9 <= currentChar and currentChar <= 13 or currentChar == 32 or currentChar == 35) then
                            if currentChar == 35 then
                                repeat
                                    parseIndex = parseIndex + 1;
                                until not stringData[parseIndex] or stringData[parseIndex] == 10 or stringData[parseIndex] == 13;
                            end;
                        else
                            table.insert(subpatternList, currentChar);
                        end;
                    end;
                    isOptional = false;
                    parseIndex = parseIndex + 1;
                end;
            until not isOptional;
            if isParsing then
                isParsing = false;
                break;
            end;
        end;
        local groupCount = 0;
        for patternElementIndex, element in ipairs(subpatternList) do
            if type(element) == "table" and (element[1] == 40 or element[1] == "quantifier" and type(element[5]) == "table" and element[5][1] == 40) then
                if element[1] == "quantifier" then
                    element = element[5];
                end;
                if not element[3] then
                    return "unterminated parenthetical";
                end;
                if element[2] then
                    groupCount = math.max(groupCount, element[2]);
                end;
            elseif type(element) == "table" and (element[1] == "backref" or element[1] == "recurmatch") then
                if not subpatternMap[element[2]] and (type(element[2]) ~= "number" or subpatternIndex < element[2]) then
                    return "reference to a non-existent or invalid subpattern";
                end;
                if element[1] == "recurmatch" and element[2] ~= 0 then
                    for index, existingGroupIndex in ipairs(subpatternList) do
                        if type(existingGroupIndex) == "table" and existingGroupIndex[1] == 40 and existingGroupIndex[2] == element[2] then
                            element[3] = index;
                            break;
                        end;
                    end;
                elseif type(element[2]) == "string" then
                    element[2] = subpatternMap[element[2]];
                end;
            end;
        end;
        subpatternList.group_n = groupCount;
        return subpatternList, subpatternMap, newlineSettings;
    end;
    if not tonumber(unicodeDataOptions.cacheSize) then
        errorFunction(string.format("expected number for options.cacheSize, got %s", typeofFunction(unicodeDataOptions.cacheSize)), 2);
    end;
    local isCacheEnabled = math.floor(unicodeDataOptions.cacheSize or 0) ~= 0 and tonumber(unicodeDataOptions.cacheSize);
    local cacheKeys = nil;
    local cacheValues = nil;
    if isCacheEnabled then
        if isCacheEnabled < 0 or isCacheEnabled ~= isCacheEnabled then
            errorFunction("cache size cannot be a negative number or a NaN", 2);
        elseif isCacheEnabled == math.huge then
            cacheKeys, cacheValues = { nil }, { nil };
        elseif 4294967296 <= isCacheEnabled then
            errorFunction("cache size too large", 2);
        else
            cacheKeys, cacheValues = table.create(unicodeDataOptions.cacheSize), table.create(unicodeDataOptions.cacheSize);
        end;
    end;
    if isCacheEnabled then
        regexModule.pruge = function()
            table.clear(cacheValues);
            table.clear(cacheKeys);
            return ;
        end;
    end;
    local getCachedValue = function(regexPattern, flags, flagRepresentation, patternRepresentation)
        local tempValue = nil;
        local tempValue2 = nil;
        local unknownValue26 = nil;
        local cacheKey = isCacheEnabled and string.format("%s|%s", regexPattern.s, flagRepresentation);
        local cachedValue = isCacheEnabled and cacheKeys[table.find(cacheValues, cacheKey)];
        local token, groupId, verbFlags;
        if cachedValue then
            local cachedToken, cachedGroupId, cachedVerbFlags = table.unpack(cachedValue, 1, 3);
            token = cachedToken;
            groupId = cachedGroupId;
            verbFlags = cachedVerbFlags;
        else
            local newValues, newGroupId, newVerbFlags = parseRegex(regexPattern, flags);
            token = newValues;
            groupId = newGroupId;
            verbFlags = newVerbFlags;
            if type(token) == "string" then
                errorFunction(token, 2);
            end;
            if isCacheEnabled and token[1] then
                table.insert(cacheValues, 1, cacheKey);
                table.insert(cacheKeys, 1, { token, groupId, verbFlags });
                if isCacheEnabled ~= math.huge then
                    table.remove(cacheValues, isCacheEnabled + 1);
                    table.remove(cacheKeys, isCacheEnabled + 1);
                end;
            end;
        end;
        local regexId = newproxyFunction(true);
        matchCache[regexId] = { name = "RegEx", flags = flags, flag_repr = flagRepresentation, pattern_repr = patternRepresentation, token = token, group_id = groupId, verb_flags = verbFlags };
        local regexMetatable = getmetatableFunction(regexId);
        regexMetatable.__index = setmetatableFunction(flags, regexMetatable);
        regexMetatable.__tostring = toStringFunction;
        regexMetatable.__metatable = metatableLockRegex;
        return regexId;
    end;
    local gsubFunction = function(gsubMatch)
        return (#gsubMatch % 2 == 0 and "\\" or "") .. (gsubMatch .. ".");
    end;
    local compareStringsCaseInsensitive = function(stringA, string1LessThanString2)
        return stringA:lower() < string1LessThanString2:lower();
    end;
    regexModule.new = function(...)
        if select("#", ...) == 0 then
            errorFunction("missing argument #1 (string expected)", 2);
        end;
        local pattern, flagString, unknownValue3 = ...;
        if type(pattern) == "number" then
            pattern = pattern .. "";
        elseif type(pattern) ~= "string" then
            errorFunction(string.format("invalid argument #1 (string expected, got %s)", typeofFunction(pattern)), 2);
        end;
        if type(flagString) ~= "string" and type(flagString) ~= "number" and flagString ~= nil then
            errorFunction(string.format("invalid argument #2 (string expected, got %s)", typeofFunction(flagString)), 2);
        end;
        local regexOptions = { anchored = false, caseless = false, multiline = false, dotall = false, unicode = false, ungreedy = false, extended = false };
        local flagList = {};
        for flagChar, regexFlagValue in string.gmatch(flagString or "", utf8.charpattern) do
            if regexOptions[regexFlagsMap[flagChar]] ~= false then
                errorFunction("invalid regular expression flag " .. flagChar, 3);
            end;
            regexOptions[regexFlagsMap[flagChar]] = true;
            table.insert(flagList, flagChar);
        end;
        table.sort(flagList, compareStringsCaseInsensitive);
        local concatenatedString = table.concat(flagList);
        return getCachedValue(utf8Substring(pattern), regexOptions, concatenatedString, string.format("/%s/", pattern:gsub("(\\*)/", gsubFunction)));
    end;
    regexModule.fromstring = function(...)
        if select("#", ...) == 0 then
            errorFunction("missing argument #1 (string expected)", 2);
        end;
        local inputString = ...;
        if type(inputString) == "number" then
            inputString = inputString .. "";
        elseif type(inputString) ~= "string" then
            errorFunction(string.format("invalid argument #1 (string expected, got %s)", typeofFunction(inputString), 2));
        end;
        local utf8CodePoints = utf8Substring(inputString);
        local delimiterCodePoint = utf8CodePoints[1];
        if not delimiterCodePoint then
            errorFunction("empty regex", 2);
        elseif delimiterCodePoint == 92 or 48 <= delimiterCodePoint and delimiterCodePoint <= 57 or 65 <= delimiterCodePoint and delimiterCodePoint <= 90 or 97 <= delimiterCodePoint and delimiterCodePoint <= 122 then
            errorFunction("delimiter must not be alphanumeric or a backslash", 2);
        end;
        local endingDelimiterIndex = 1;
        repeat
            endingDelimiterIndex = table.find(utf8CodePoints, delimiterCodePoint, endingDelimiterIndex + 1);
            if not endingDelimiterIndex then
                errorFunction(string.format("no ending delimiter ('%s') found", utf8.char(delimiterCodePoint)), 2);
            end;
            local escapeCharacterCount = 1;
            while utf8CodePoints[endingDelimiterIndex - escapeCharacterCount] == 92 do
                escapeCharacterCount = escapeCharacterCount + 1;
            end;
        until escapeCharacterCount % 2 == 1;
        local regexFlags = { anchored = false, caseless = false, multiline = false, dotall = false, unicode = false, ungreedy = false, extended = false };
        local sortedFlags = {};
        while endingDelimiterIndex < utf8CodePoints.n do
            local flagCharacter = utf8.char(table.remove(utf8CodePoints));
            utf8CodePoints.n = utf8CodePoints.n - 1;
            if regexFlags[regexFlagsMap[flagCharacter]] ~= false then
                errorFunction("invalid regular expression flag " .. flagCharacter, 3);
            end;
            regexFlags[regexFlagsMap[flagCharacter]] = true;
            table.insert(sortedFlags, flagCharacter);
        end;
        table.sort(sortedFlags, compareStringsCaseInsensitive);
        local concatenatedString = table.concat(sortedFlags);
        table.remove(utf8CodePoints, 1);
        table.remove(utf8CodePoints);
        utf8CodePoints.n = utf8CodePoints.n - 2;
        utf8CodePoints.s = string.sub(utf8CodePoints.s, 2, 1 + utf8CodePoints.n);
        return getCachedValue(utf8CodePoints, regexFlags, concatenatedString, string.sub(inputString, 1, 2 + utf8CodePoints.n));
    end;
    local escapeSequencesMap = { ["\000"] = "\\x00", ["\n"] = "\\n", ["\t"] = "\\t", ["\r"] = "\\r", ["\f"] = "\\f" };
    regexModule.escape = function(...)
        if select("#", ...) == 0 then
            errorFunction("missing argument #1 (string expected)", 2);
        end;
        local escapedString, isPercentEncoded, percentEncodingCharacters, arg8 = ...;
        if type(escapedString) == "number" then
            escapedString = escapedString .. "";
        elseif type(escapedString) ~= "string" then
            errorFunction(string.format("invalid argument #1 to 'escape' (string expected, got %s)", typeofFunction(escapedString)), 2);
        end;
        if percentEncodingCharacters == nil then
            percentEncodingCharacters = "";
        elseif type(percentEncodingCharacters) == "number" then
            percentEncodingCharacters = percentEncodingCharacters .. "";
        elseif type(percentEncodingCharacters) ~= "string" then
            errorFunction(string.format("invalid argument #3 to 'escape' (string expected, got %s)", typeofFunction(percentEncodingCharacters)), 2);
        end;
        if 1 < utf8.len(percentEncodingCharacters) or percentEncodingCharacters:match("^[%a\\]$") then
            errorFunction("delimiter have not be alphanumeric", 2);
        end;
        return string.gsub(escapedString, "[\000\f\n\r\t]", escapeSequencesMap):gsub(string.format("[\\%s#()%%%%*+.?[%%]^{|%s]", isPercentEncoded and "%s" or "", (percentEncodingCharacters:find("^[%%%]]$") and "%" or "") .. percentEncodingCharacters), "\\%1");
    end;
    regexModule.type = function(...)
        if select("#", ...) == 0 then
            errorFunction("missing argument #1", 2);
        end;
        return matchCache[...] and matchCache[...].name;
    end;
    for index, value in pairsFunction(regexMetatable) do
        regexModule[index] = value;
    end;
    regexMetatable = { __index = regexMetatable };
    metatableLockRegex = regexModule.fromstring("/The\\s*metatable\\s*is\\s*(?:locked|inaccessible)(?#Nice try :])/i");
    getmetatableFunction(metatableLockRegex).__metatable = metatableLockRegex;
    local readOnlyTableNewIndexHandler = function()
        errorFunction("Attempt to modify a readonly table", 2);
        return ;
    end;
    matchMetatable = { __index = matchMetatable, __metatable = metatableLockRegex, __newindex = readOnlyTableNewIndexHandler };
    regexModule.Match = setmetatableFunction({}, matchMetatable);
    return setmetatableFunction({}, { __index = regexModule, __metatable = metatableLockRegex, __newindex = readOnlyTableNewIndexHandler });
end);
registerModule("RegExpUtils", "ModuleScript", "rbxts-bundle-example.LKHUB.Utils.RegExp.RegExpUtils", "rbxts-bundle-example.LKHUB.Utils.RegExp", function()
    local regExpUtilsModule = getModuleGlobals("rbxts-bundle-example.LKHUB.Utils.RegExp.RegExpUtils");
    local scriptInstance = regExpUtilsModule.script;
    local requireFunction = regExpUtilsModule.require;
    local unknownValue27 = nil;
    local regExpUtils = setmetatableFunction({}, {
        __tostring = function()
            return "RegExpUtils";
        end
    });
    regExpUtils.__index = regExpUtils;
    regExpUtils.new = function(...)
        local newObject = setmetatableFunction({}, regExpUtils);
        return newObject:constructor(...) or newObject;
    end;
    regExpUtils.constructor = function(L_3523)
        return ;
    end;
    regExpUtils.replaceAll = function(L_3524, regExpPattern, inputString, unknownValue28)
        local matchResult = regExpPattern:exec(inputString);
        local resultString = "";
        while true do
            local indexValue = matchResult ~= nil and matchResult.index;
            if indexValue == 0 or indexValue ~= indexValue or not indexValue then
                break;
            end;
            local previousString = resultString;
            local substringToProcess = inputString;
            local previousIndex = matchResult.index - 1;
            resultString = previousString .. (string.sub(substringToProcess, 1, previousIndex) .. unknownValue28);
            local originalString = inputString;
            local nextStartIndex = matchResult.index + #matchResult[1];
            inputString = string.sub(originalString, nextStartIndex);
            matchResult = regExpPattern:exec(inputString);
        end;
        return if not (0 < #resultString) then inputString else resultString;
    end;
    return { default = regExpUtils };
end);
registerModule("ThreadIdentity", "ModuleScript", "rbxts-bundle-example.LKHUB.Utils.ThreadIdentity", "rbxts-bundle-example.LKHUB.Utils", function()
    local threadIdentityModule = getModuleGlobals("rbxts-bundle-example.LKHUB.Utils.ThreadIdentity");
    local scriptInstance = threadIdentityModule.script;
    local threadIdentityRequire = threadIdentityModule.require;
    local threadIdentity = getthreadidentity();
    local identitySafe = function(callbackFunction)
        return function(...)
            local argumentsList = { ... };
            setidentity(2);
            local functionResult = callbackFunction(unpack(argumentsList));
            setidentity(threadIdentity);
            return functionResult;
        end;
    end;
    local identitySafeRequire = function(inputData)
        setidentity(2);
        local requiredModule = threadIdentityRequire(inputData);
        setidentity(threadIdentity);
        return requiredModule;
    end;
    return { identitySafe = identitySafe, identitySafeRequire = identitySafeRequire };
end);
createInstance("types", "Folder", "rbxts-bundle-example.LKHUB.types", "rbxts-bundle-example.LKHUB");
createInstance("Tabs", "Folder", "rbxts-bundle-example.Tabs", "rbxts-bundle-example");
createInstance("Boss", "Folder", "rbxts-bundle-example.Tabs.Boss", "rbxts-bundle-example.Tabs");
registerModule("SectionBossFarm", "ModuleScript", "rbxts-bundle-example.Tabs.Boss.SectionBossFarm", "rbxts-bundle-example.Tabs.Boss", function()
    local sectionBossFarmModule = getModuleGlobals("rbxts-bundle-example.Tabs.Boss.SectionBossFarm");
    local sectionBossFarmScript = sectionBossFarmModule.script;
    local sectionBossFarmRequire = sectionBossFarmModule.require(sectionBossFarmScript.Parent.Parent.Parent.include.RuntimeLib);
    local librarySection = sectionBossFarmRequire.import(sectionBossFarmScript, sectionBossFarmScript.Parent.Parent.Parent, "LKHUB", "Library", "LibraryWrapper", "LibraryWrapper").LibrarySection;
    local bossFarmService = sectionBossFarmRequire.import(sectionBossFarmScript, sectionBossFarmScript.Parent.Parent.Parent, "DeathBall", "BossFarmService");
    local setAutoFarmEnabled = bossFarmService.setAutoFarmEnabled;
    local setFarmHeight = bossFarmService.setFarmHeight;
    local reviveAllPlayersFunction = bossFarmService.reviveAllPlayers;
    local unknownValue29 = nil;
    local librarySectionInstance = librarySection;
    local sectionBossFarmClass = setmetatableFunction({}, {
        __tostring = function()
            return "SectionBossFarm";
        end,
        __index = librarySectionInstance
    });
    sectionBossFarmClass.__index = sectionBossFarmClass;
    sectionBossFarmClass.new = function(...)
        local newObject2 = setmetatableFunction({}, sectionBossFarmClass);
        return newObject2:constructor(...) or newObject2;
    end;
    sectionBossFarmClass.constructor = function(arg1, bossFarmName)
        librarySectionInstance.constructor(arg1, bossFarmName, "Boss Farm");
        return ;
    end;
    sectionBossFarmClass.Load = function(SectionBossFarm, bossData)
        local sectionBossFarmInstance = SectionBossFarm.new(bossData);
        sectionBossFarmInstance:InitObjects();
        SectionBossFarm.Instance = sectionBossFarmInstance;
        return sectionBossFarmInstance;
    end;
    sectionBossFarmClass.InitObjects = function(combatTab)
        combatTab.AutoFarmToggle = combatTab:AddToggle({
            Name = "Auto Farm",
            Default = false,
            IgnoreFirst = true,
            Callback = function(arg1)
                setAutoFarmEnabled(arg1);
                return ;
            end
        });
        combatTab.FarmHeightSlider = combatTab:AddSlider({
            Name = "Farm Height",
            Default = 50,
            Min = 40,
            Max = 280,
            Increment = 1,
            AllowInput = true,
            IgnoreFirst = true,
            Callback = function(arg2)
                setFarmHeight(arg2);
                return ;
            end
        });
        combatTab.ReviveAllButton = combatTab:AddButton({
            Name = "Revive All",
            Callback = function()
                reviveAllPlayersFunction();
                return ;
            end
        });
        return ;
    end;
    return { default = sectionBossFarmClass };
end);
createInstance("Combat", "Folder", "rbxts-bundle-example.Tabs.Combat", "rbxts-bundle-example.Tabs");
registerModule("SectionAutoAbility", "ModuleScript", "rbxts-bundle-example.Tabs.Combat.SectionAutoAbility", "rbxts-bundle-example.Tabs.Combat", function()
    local sectionAutoAbilityModule = getModuleGlobals("rbxts-bundle-example.Tabs.Combat.SectionAutoAbility");
    local sectionAutoAbilityScript = sectionAutoAbilityModule.script;
    local runtimeLib = sectionAutoAbilityModule.require(sectionAutoAbilityScript.Parent.Parent.Parent.include.RuntimeLib);
    local librarySection = runtimeLib.import(sectionAutoAbilityScript, sectionAutoAbilityScript.Parent.Parent.Parent, "LKHUB", "Library", "LibraryWrapper", "LibraryWrapper").LibrarySection;
    local setAutoAbilityEnabled = runtimeLib.import(sectionAutoAbilityScript, sectionAutoAbilityScript.Parent.Parent.Parent, "DeathBall", "AutoAbilityService").setAutoAbilityEnabled;
    local unknownValue30 = nil;
    local librarySectionConstructor = librarySection;
    local sectionAutoAbility = setmetatableFunction({}, {
        __tostring = function()
            return "SectionAutoAbility";
        end,
        __index = librarySectionConstructor
    });
    sectionAutoAbility.__index = sectionAutoAbility;
    sectionAutoAbility.new = function(...)
        local newObject3 = setmetatableFunction({}, sectionAutoAbility);
        return newObject3:constructor(...) or newObject3;
    end;
    sectionAutoAbility.constructor = function(parentObject, autoAbilityName)
        librarySectionConstructor.constructor(parentObject, autoAbilityName, "Auto Ability");
        return ;
    end;
    sectionAutoAbility.Load = function(SectionAutoAbilityClass, abilityData)
        local sectionAutoAbilityInstance = SectionAutoAbilityClass.new(abilityData);
        sectionAutoAbilityInstance:InitObjects();
        SectionAutoAbilityClass.Instance = sectionAutoAbilityInstance;
        return sectionAutoAbilityInstance;
    end;
    sectionAutoAbility.InitObjects = function(menuObject)
        menuObject.AutoAbilityToggle = menuObject:AddToggle({
            Name = "Auto Ability",
            Default = false,
            IgnoreFirst = true,
            Callback = function(arg3)
                setAutoAbilityEnabled(arg3);
                return ;
            end
        });
        return ;
    end;
    return { default = sectionAutoAbility };
end);
registerModule("SectionBallTracker", "ModuleScript", "rbxts-bundle-example.Tabs.Combat.SectionBallTracker", "rbxts-bundle-example.Tabs.Combat", function()
    local sectionBallTrackerModule = getModuleGlobals("rbxts-bundle-example.Tabs.Combat.SectionBallTracker");
    local sectionBallTrackerScript = sectionBallTrackerModule.script;
    local runtimeLibBallTracker = sectionBallTrackerModule.require(sectionBallTrackerScript.Parent.Parent.Parent.include.RuntimeLib);
    local librarySectionBallTracker = runtimeLibBallTracker.import(sectionBallTrackerScript, sectionBallTrackerScript.Parent.Parent.Parent, "LKHUB", "Library", "LibraryWrapper", "LibraryWrapper").LibrarySection;
    local ballService = runtimeLibBallTracker.import(sectionBallTrackerScript, sectionBallTrackerScript.Parent.Parent.Parent, "DeathBall", "BallService");
    local startBallTracking = ballService.startBallTracking;
    local stopBallTracking = ballService.stopBallTracking;
    local unknownValue31 = nil;
    local librarySectionBallTrackerConstructor = librarySectionBallTracker;
    local sectionBallTracker = setmetatableFunction({}, {
        __tostring = function()
            return "SectionBallTracker";
        end,
        __index = librarySectionBallTrackerConstructor
    });
    sectionBallTracker.__index = sectionBallTracker;
    sectionBallTracker.new = function(...)
        local newObject4 = setmetatableFunction({}, sectionBallTracker);
        return newObject4:constructor(...) or newObject4;
    end;
    sectionBallTracker.constructor = function(parentObjectBallTracker, ballTrackerName)
        librarySectionBallTrackerConstructor.constructor(parentObjectBallTracker, ballTrackerName, "Ball Tracker");
        return ;
    end;
    sectionBallTracker.Load = function(SectionBallTrackerClass, ballData)
        local sectionBallTrackerInstance = SectionBallTrackerClass.new(ballData);
        sectionBallTrackerInstance:InitObjects();
        SectionBallTrackerClass.Instance = sectionBallTrackerInstance;
        return sectionBallTrackerInstance;
    end;
    sectionBallTracker.InitObjects = function(menuObject2)
        menuObject2.BallTrackerToggle = menuObject2:AddToggle({
            Name = "Ball Tracker",
            Default = false,
            IgnoreFirst = true,
            Callback = function(isBallTrackingEnabled)
                if isBallTrackingEnabled then
                    startBallTracking();
                else
                    stopBallTracking();
                end;
                return ;
            end
        });
        return ;
    end;
    return { default = sectionBallTracker };
end);
registerModule("SectionParry", "ModuleScript", "rbxts-bundle-example.Tabs.Combat.SectionParry", "rbxts-bundle-example.Tabs.Combat", function()
    local sectionParryModule = getModuleGlobals("rbxts-bundle-example.Tabs.Combat.SectionParry");
    local sectionParryScript = sectionParryModule.script;
    local runtimeLibParry = sectionParryModule.require(sectionParryScript.Parent.Parent.Parent.include.RuntimeLib);
    local librarySectionParry = runtimeLibParry.import(sectionParryScript, sectionParryScript.Parent.Parent.Parent, "LKHUB", "Library", "LibraryWrapper", "LibraryWrapper").LibrarySection;
    local autoParryService = runtimeLibParry.import(sectionParryScript, sectionParryScript.Parent.Parent.Parent, "DeathBall", "AutoParry");
    local setAutoParryEnabled = autoParryService.setAutoParryEnabled;
    local setParryAccuracy = autoParryService.setParryAccuracy;
    local unknownValue32 = nil;
    local sectionParryBase = librarySectionParry;
    local SectionParry = setmetatableFunction({}, {
        __tostring = function()
            return "SectionParry";
        end,
        __index = sectionParryBase
    });
    SectionParry.__index = SectionParry;
    SectionParry.new = function(...)
        local newObject5 = setmetatableFunction({}, SectionParry);
        return newObject5:constructor(...) or newObject5;
    end;
    SectionParry.constructor = function(self, autoParryName)
        sectionParryBase.constructor(self, autoParryName, "Auto Parry");
        return ;
    end;
    SectionParry.Load = function(AutoParrySection, parryData)
        local autoParrySection = AutoParrySection.new(parryData);
        autoParrySection:InitObjects();
        AutoParrySection.Instance = autoParrySection;
        return autoParrySection;
    end;
    SectionParry.InitObjects = function(visualTab)
        visualTab.DeflectToggle = visualTab:AddToggle({
            Name = "Auto Parry",
            Default = false,
            IgnoreFirst = true,
            Callback = function(arg4)
                setAutoParryEnabled(arg4);
                return ;
            end
        });
        visualTab.ParryAccuracySlider = visualTab:AddSlider({
            Name = "Ping Compensation",
            Default = 0.1,
            Min = 0.01,
            Max = 0.5,
            Increment = 0.01,
            AllowInput = true,
            IgnoreFirst = true,
            Callback = function(arg5)
                setParryAccuracy(arg5);
                return ;
            end
        });
        return ;
    end;
    return { default = SectionParry };
end);
createInstance("Visual", "Folder", "rbxts-bundle-example.Tabs.Visual", "rbxts-bundle-example.Tabs");
registerModule("SectionSkins", "ModuleScript", "rbxts-bundle-example.Tabs.Visual.SectionSkins", "rbxts-bundle-example.Tabs.Visual", function()
    local sectionSkinsModule = getModuleGlobals("rbxts-bundle-example.Tabs.Visual.SectionSkins");
    local sectionSkinsScript = sectionSkinsModule.script;
    local runtimeLib = sectionSkinsModule.require(sectionSkinsScript.Parent.Parent.Parent.include.RuntimeLib);
    local librarySection = runtimeLib.import(sectionSkinsScript, sectionSkinsScript.Parent.Parent.Parent, "LKHUB", "Library", "LibraryWrapper", "LibraryWrapper").LibrarySection;
    local skinService = runtimeLib.import(sectionSkinsScript, sectionSkinsScript.Parent.Parent.Parent, "DeathBall", "SkinService");
    local getSwordData = skinService.getSwordData;
    local selectSword = skinService.selectSword;
    local getAnimationData = skinService.getAnimationData;
    local selectAnimation = skinService.selectAnimation;
    local setupCharacterRespawnHandler = skinService.setupCharacterRespawnHandler;
    local unknownValue33 = nil;
    local librarySectionBase = librarySection;
    local SectionSkins = setmetatableFunction({}, {
        __tostring = function()
            return "SectionSkins";
        end,
        __index = librarySectionBase
    });
    SectionSkins.__index = SectionSkins;
    SectionSkins.new = function(...)
        local newObject6 = setmetatableFunction({}, SectionSkins);
        return newObject6:constructor(...) or newObject6;
    end;
    SectionSkins.constructor = function(self, skinsName)
        librarySectionBase.constructor(self, skinsName, "Skins");
        return ;
    end;
    SectionSkins.Load = function(SkinsSection, skinData)
        local skinsSection = SkinsSection.new(skinData);
        skinsSection:InitObjects();
        SkinsSection.Instance = skinsSection;
        setupCharacterRespawnHandler();
        return skinsSection;
    end;
    SectionSkins.InitObjects = function(menuObject3)
        local swordDataList = getSwordData();
        local unknownValue34 = nil;
        local swordOptions;
        if 0 < #swordDataList then
            local defaultSwordList = { "Default" };
            local swordCount = #defaultSwordList;
            table.move(swordDataList, 1, #swordDataList, swordCount + 1, defaultSwordList);
            swordOptions = defaultSwordList;
        else
            swordOptions = { "Default" };
        end;
        menuObject3.SwordDropdown = menuObject3:AddDropdown({
            Name = "Select Sword",
            Options = swordOptions,
            Default = "Default",
            Callback = function(swordList)
                local selectedSwordValue = swordList;
                local unknownValue35 = nil;
                local selectedSword;
                if type(selectedSwordValue) == "string" then
                    selectedSword = swordList;
                else
                    local defaultSwordValue = swordList[1];
                    if defaultSwordValue == "" or not defaultSwordValue then
                        defaultSwordValue = "Default";
                    end;
                    selectedSword = defaultSwordValue;
                end;
                local finalSwordValue = selectedSword;
                if finalSwordValue ~= "Default" then
                    selectSword(finalSwordValue);
                else
                    selectSword("Default");
                end;
                return ;
            end
        });
        local animationDataList = getAnimationData();
        local promiseValue = nil;
        local animationOptions;
        if 0 < #animationDataList then
            local defaultAnimationList = { "Default" };
            local animationCount = #defaultAnimationList;
            table.move(animationDataList, 1, #animationDataList, animationCount + 1, defaultAnimationList);
            animationOptions = defaultAnimationList;
        else
            animationOptions = { "Default" };
        end;
        menuObject3.AnimationDropdown = menuObject3:AddDropdown({
            Name = "Select Animation",
            Options = animationOptions,
            Default = "Default",
            Callback = function(animationList)
                local selectedAnimationValue = animationList;
                local promiseResult = nil;
                local selectedAnimation;
                if type(selectedAnimationValue) == "string" then
                    selectedAnimation = animationList;
                else
                    local defaultSwordName = animationList[1];
                    if defaultSwordName == "" or not defaultSwordName then
                        defaultSwordName = "Default";
                    end;
                    selectedAnimation = defaultSwordName;
                end;
                local selectedSwordName = selectedAnimation;
                if selectedSwordName ~= "Default" then
                    selectAnimation(selectedSwordName);
                else
                    selectAnimation("Default");
                end;
                return ;
            end
        });
        task.wait(0.1);
        menuObject3:ApplySavedValues();
        return ;
    end;
    SectionSkins.ApplySavedValues = function(guiElements)
        local swordDataList2 = getSwordData();
        local promiseError = nil;
        local swordChoices;
        if 0 < #swordDataList2 then
            local defaultSwordList2 = { "Default" };
            local swordChoicesCount = #defaultSwordList2;
            table.move(swordDataList2, 1, #swordDataList2, swordChoicesCount + 1, defaultSwordList2);
            swordChoices = defaultSwordList2;
        else
            swordChoices = { "Default" };
        end;
        local swordChoicesList = swordChoices;
        local animationDataList2 = getAnimationData();
        local promiseFinally = nil;
        local animationChoices;
        if 0 < #animationDataList2 then
            local defaultAnimationList2 = { "Default" };
            local animationChoicesCount = #defaultAnimationList2;
            table.move(animationDataList2, 1, #animationDataList2, animationChoicesCount + 1, defaultAnimationList2);
            animationChoices = defaultAnimationList2;
        else
            animationChoices = { "Default" };
        end;
        local animationChoicesList = animationChoices;
        local selectedSwordValue = guiElements.SwordDropdown.Instance.Value;
        local animationDropdownValue = guiElements.AnimationDropdown.Instance.Value;
        if type(selectedSwordValue) == "string" and table.find(swordChoicesList, selectedSwordValue) == nil then
            guiElements.SwordDropdown:Set("Default", true);
            selectSword("Default");
        elseif type(selectedSwordValue) == "string" and selectedSwordValue ~= "Default" then
            selectSword(selectedSwordValue);
        end;
        if type(animationDropdownValue) == "string" and table.find(animationChoicesList, animationDropdownValue) == nil then
            guiElements.AnimationDropdown:Set("Default", true);
            selectAnimation("Default");
        elseif type(animationDropdownValue) == "string" and animationDropdownValue ~= "Default" then
            selectAnimation(animationDropdownValue);
        end;
        return ;
    end;
    SectionSkins.RefreshOptions = function(customizationMenu)
        local animationList = getSwordData();
        local promiseCancel = nil;
        local swordDropdownOptions;
        if 0 < #animationList then
            local defaultAnimationList = { "Default" };
            local swordOptionsCount = #defaultAnimationList;
            table.move(animationList, 1, #animationList, swordOptionsCount + 1, defaultAnimationList);
            swordDropdownOptions = defaultAnimationList;
        else
            swordDropdownOptions = { "Default" };
        end;
        customizationMenu.SwordDropdown:SetChoices(swordDropdownOptions, true);
        local skinList = getAnimationData();
        local promiseCleanup = nil;
        local animationDropdownOptions;
        if 0 < #skinList then
            local defaultSkinList = { "Default" };
            local animationOptionsCount = #defaultSkinList;
            table.move(skinList, 1, #skinList, animationOptionsCount + 1, defaultSkinList);
            animationDropdownOptions = defaultSkinList;
        else
            animationDropdownOptions = { "Default" };
        end;
        customizationMenu.AnimationDropdown:SetChoices(animationDropdownOptions, true);
        customizationMenu:ApplySavedValues();
        return ;
    end;
    return { default = SectionSkins };
end);
registerModule("main", "LocalScript", "rbxts-bundle-example.main", "rbxts-bundle-example", function()
    local rbxtsBundleExampleMain = getModuleGlobals("rbxts-bundle-example.main");
    local mainScript = rbxtsBundleExampleMain.script;
    local runtimeLibRequire = rbxtsBundleExampleMain.require(mainScript.Parent.include.RuntimeLib);
    local lkhubMainModule = runtimeLibRequire.import(mainScript, mainScript.Parent, "LKHUB", "Main").default;
    local combatSectionParryModule = runtimeLibRequire.import(mainScript, mainScript.Parent, "Tabs", "Combat", "SectionParry").default;
    local combatSectionAutoAbilityModule = runtimeLibRequire.import(mainScript, mainScript.Parent, "Tabs", "Combat", "SectionAutoAbility").default;
    local bossFarmSection = runtimeLibRequire.import(mainScript, mainScript.Parent, "Tabs", "Boss", "SectionBossFarm").default;
    local skinsSection = runtimeLibRequire.import(mainScript, mainScript.Parent, "Tabs", "Visual", "SectionSkins").default;
    local profilesSection = runtimeLibRequire.import(mainScript, mainScript.Parent, "LKHUB", "DefaultTabs", "Settings", "SectionProfiles").default;
    local toggleGuiSection = runtimeLibRequire.import(mainScript, mainScript.Parent, "LKHUB", "DefaultTabs", "Settings", "SectionToggleGUI").default;
    local creditsSection = runtimeLibRequire.import(mainScript, mainScript.Parent, "LKHUB", "DefaultTabs", "Settings", "SectionCredits").default;
    lkhubMainModule.new("Death Ball"):LoadTabs({ { "Combat", { combatSectionParryModule, combatSectionAutoAbilityModule } }, { "Boss", { bossFarmSection } }, { "Visual", { skinsSection } }, { "Settings", { toggleGuiSection, profilesSection, creditsSection } } });
    return ;
end);
createInstance("include", "Folder", "rbxts-bundle-example.include", "rbxts-bundle-example");
registerModule("Promise", "ModuleScript", "rbxts-bundle-example.include.Promise", "rbxts-bundle-example.include", function()
    local rbxtsBundleExamplePromise = getModuleGlobals("rbxts-bundle-example.include.Promise");
    local scriptInstance = rbxtsBundleExamplePromise.script;
    local requireFunction = rbxtsBundleExamplePromise.require;
    local weakValueTable = { __mode = "k" };
    local isFunctionType = function(potentialFunction)
        if type(potentialFunction) == "function" then
            return true;
        end;
        if type(potentialFunction) == "table" then
            local metatable = getmetatableFunction(potentialFunction);
            if metatable and type(rawgetFunction(metatable, "__call")) == "function" then
                return true;
            end;
        end;
        return false;
    end;
    local createEnum = function(itemContainer, itemList)
        local enumTable = {};
        for index, enumValue in ipairs(itemList) do
            enumTable[enumValue] = enumValue;
        end;
        return setmetatableFunction(enumTable, {
            __index = function(L_3711, itemName)
                errorFunction(string.format("%s is not in %s!", itemName, itemContainer), 2);
                return ;
            end,
            __newindex = function()
                errorFunction(string.format("Creating new members in %s is not allowed!", itemContainer), 2);
                return ;
            end
        });
    end;
    local promiseContext = nil;
    local PromiseError = { Kind = createEnum("Promise.Error.Kind", { "ExecutionError", "AlreadyCancelled", "NotResolvedInTime", "TimedOut" }) };
    PromiseError.__index = PromiseError;
    PromiseError.new = function(options, parentPromise)
        local errorOptions = options or {};
        return setmetatableFunction({ error = tostring(errorOptions.error) or "[This error has no error text.]", trace = errorOptions.trace, context = errorOptions.context, kind = errorOptions.kind, parent = parentPromise, createdTick = os.clock(), createdTrace = debug.traceback() }, PromiseError);
    end;
    PromiseError.is = function(potentialError)
        if type(potentialError) == "table" then
            local potentialErrorMetatable = getmetatableFunction(potentialError);
            if type(potentialErrorMetatable) == "table" then
                return rawgetFunction(potentialError, "error") ~= nil and type(rawgetFunction(potentialErrorMetatable, "extend")) == "function";
            end;
        end;
        return false;
    end;
    PromiseError.isKind = function(value, kind)
        assertFunction(kind ~= nil, "Argument #2 to Promise.Error.isKind must not be nil");
        return PromiseError.is(value) and value.kind == kind;
    end;
    PromiseError.extend = function(defaultOptions, optionsTable)
        local errorDetails = optionsTable or {};
        errorDetails.kind = errorDetails.kind or defaultOptions.kind;
        return PromiseError.new(errorDetails, defaultOptions);
    end;
    PromiseError.getErrorChain = function(instance)
        local parentChain = { [1] = instance };
        while parentChain[#parentChain].parent do
            table.insert(parentChain, parentChain[#parentChain].parent);
        end;
        return parentChain;
    end;
    PromiseError.__tostring = function(promiseError)
        local errorStringList = { string.format("-- Promise.Error(%s) --", promiseError.kind or "?") };
        for errorIndex, errorChainItem in ipairs(promiseError:getErrorChain()) do
            table.insert(errorStringList, table.concat({ errorChainItem.trace or errorChainItem.error, errorChainItem.context }, "\n"));
        end;
        return table.concat(errorStringList, "\n");
    end;
    local selectArguments = function(...)
        return select("#", ...), { ... };
    end;
    local xpcallResult = function(argList, ...)
        return argList, select("#", ...), { ... };
    end;
    local createTracebackHandler = function(traceback)
        assertFunction(traceback ~= nil, "traceback is nil");
        return function(errorValue)
            if type(errorValue) == "table" then
                return errorValue;
            end;
            return PromiseError.new({ error = errorValue, kind = PromiseError.Kind.ExecutionError, trace = debug.traceback(tostring(errorValue), 2), context = "Promise created at:\n\n" .. traceback });
        end;
    end;
    local xpcallWrapper = function(errorHandler, callbackFunction, ...)
        return xpcallResult(xpcall(callbackFunction, createTracebackHandler(errorHandler), ...));
    end;
    local createPromiseHandler = function(promiseResolver, promiseRejecter, resolveCallback, callbackFunction)
        return function(...)
            local success, valueCount, values = xpcallWrapper(promiseResolver, promiseRejecter, ...);
            if success then
                resolveCallback(unpack(values, 1, valueCount));
            else
                callbackFunction(values[1]);
            end;
            return ;
        end;
    end;
    local isTableEmpty = function(tableToCheck)
        return next(tableToCheck) == nil;
    end;
    local promiseUtils = { Error = PromiseError, Status = createEnum("Promise.Status", { "Started", "Resolved", "Rejected", "Cancelled" }), _getTime = os.clock, _timeEvent = game:GetService("RunService").Heartbeat, _unhandledRejectionCallbacks = {}, prototype = {} };
    promiseUtils.__index = promiseUtils.prototype;
    promiseUtils._new = function(source, promiseValue, parentPromise)
        if parentPromise ~= nil and not promiseUtils.is(parentPromise) then
            errorFunction("Argument #2 to Promise.new must be a promise or nil", 2);
        end;
        local promiseObject = { _thread = nil, _source = source, _status = promiseUtils.Status.Started, _values = nil, _valuesLength = -1, _unhandledRejection = true, _queuedResolve = {}, _queuedReject = {}, _queuedFinally = {}, _cancellationHook = nil, _parent = parentPromise, _consumers = setmetatableFunction({}, weakValueTable) };
        if parentPromise and parentPromise._status == promiseUtils.Status.Started then
            parentPromise._consumers[promiseObject] = true;
        end;
        setmetatableFunction(promiseObject, promiseUtils);
        local resolveFunction = function(...)
            promiseObject:_resolve(...);
            return ;
        end;
        local rejectPromise = function(...)
            promiseObject:_reject(...);
            return ;
        end;
        local cancellationHandler = function(cancellationHook)
            if cancellationHook then
                if promiseObject._status == promiseUtils.Status.Cancelled then
                    cancellationHook();
                else
                    promiseObject._cancellationHook = cancellationHook;
                end;
            end;
            return promiseObject._status == promiseUtils.Status.Cancelled;
        end;
        promiseObject._thread = coroutine.create(function()
            local executionSuccess, unusedValue, executionResults = xpcallWrapper(promiseObject._source, promiseValue, resolveFunction, rejectPromise, cancellationHandler);
            if not executionSuccess then
                rejectPromise(executionResults[1]);
            end;
            return ;
        end);
        task.spawn(promiseObject._thread);
        return promiseObject;
    end;
    promiseUtils.new = function(tracebackString)
        return promiseUtils._new(debug.traceback(nil, 2), tracebackString);
    end;
    promiseUtils.__tostring = function(promiseObject)
        return string.format("Promise(%s)", promiseObject._status);
    end;
    promiseUtils.defer = function(promiseValue)
        local stackTrace = debug.traceback(nil, 2);
        local timeoutConnection = nil;
        return promiseUtils._new(stackTrace, function(promiseValue, reject, promiseValue)
            local timeEventConnection = nil;
            timeEventConnection = promiseUtils._timeEvent:Connect(function()
                timeEventConnection:Disconnect();
                local asyncSuccess, promiseResults, asyncResults = xpcallWrapper(stackTrace, promiseValue, promiseValue, reject, promiseValue);
                if not asyncSuccess then
                    reject(asyncResults[1]);
                end;
                return ;
            end);
            return ;
        end);
    end;
    promiseUtils.async = promiseUtils.defer;
    promiseUtils.resolve = function(...)
        local resolveCount, resolveValues = selectArguments(...);
        return promiseUtils._new(debug.traceback(nil, 2), function(resolveFunction)
            resolveFunction(unpack(resolveValues, 1, resolveCount));
            return ;
        end);
    end;
    promiseUtils.reject = function(...)
        local rejectCount, rejectValues = selectArguments(...);
        return promiseUtils._new(debug.traceback(nil, 2), function(L_3780, rejectFunction)
            rejectFunction(unpack(rejectValues, 1, rejectCount));
            return ;
        end);
    end;
    promiseUtils._try = function(executor, resolve, ...)
        local finallyCount, finallyValues = selectArguments(...);
        return promiseUtils._new(executor, function(finallyFunction)
            finallyFunction(resolve(unpack(finallyValues, 1, finallyCount)));
            return ;
        end);
    end;
    promiseUtils.try = function(callbackFunction, ...)
        return promiseUtils._try(debug.traceback(nil, 2), callbackFunction, ...);
    end;
    promiseUtils._all = function(constructor, promiseList, concurrencyLimit)
        if type(promiseList) ~= "table" then
            errorFunction(string.format("Please pass a list of promises to %s", "Promise.all"), 3);
        end;
        for promiseIndex, promiseValue in pairsFunction(promiseList) do
            if not promiseUtils.is(promiseValue) then
                errorFunction(string.format("Non-promise value passed into %s at index %s", "Promise.all", tostring(promiseIndex)), 3);
            end;
        end;
        if #promiseList == 0 or concurrencyLimit == 0 then
            return promiseUtils.resolve({});
        end;
        return promiseUtils._new(constructor, function(callbackFunction, promiseResolveHandler, callbackFunction)
            local promiseResultsMap = {};
            local promiseCancellationList = {};
            local promiseCounter = 0;
            local retryCount = 0;
            local isCancelled = false;
            local cancelPromises = function()
                for promiseIndex, cancellablePromise in ipairs(promiseCancellationList) do
                    cancellablePromise:cancel();
                end;
                return ;
            end;
            local resolvePromise = function(index, ...)
                if isCancelled then
                    return ;
                end;
                promiseCounter = promiseCounter + 1;
                if concurrencyLimit == nil then
                    promiseResultsMap[index] = ...;
                else
                    promiseResultsMap[promiseCounter] = ...;
                end;
                local currentPromiseIndex = promiseCounter;
                if (concurrencyLimit or #promiseList) <= currentPromiseIndex then
                    isCancelled = true;
                    callbackFunction(promiseResultsMap);
                    cancelPromises();
                end;
                return ;
            end;
            callbackFunction(cancelPromises);
            for index, promise in ipairs(promiseList) do
                promiseCancellationList[index] = promise:andThen(function(...)
                    resolvePromise(index, ...);
                    return ;
                end, function(...)
                    retryCount = retryCount + 1;
                    if concurrencyLimit == nil or #promiseList - retryCount < concurrencyLimit then
                        cancelPromises();
                        isCancelled = true;
                        promiseResolveHandler(...);
                    end;
                    return ;
                end);
            end;
            if isCancelled then
                cancelPromises();
            end;
            return ;
        end);
    end;
    promiseUtils.all = function(promiseList)
        return promiseUtils._all(debug.traceback(nil, 2), promiseList);
    end;
    promiseUtils.fold = function(promisesTable, foldFunction, promiseResolver)
        assertFunction(type(promisesTable) == "table", "Bad argument #1 to Promise.fold: must be a table");
        assertFunction(isFunctionType(foldFunction), "Bad argument #2 to Promise.fold: must be a function");
        local accumulatorPromise = promiseUtils.resolve(promiseResolver);
        return promiseUtils.each(promisesTable, function(rejectFunction, promiseValue)
            accumulatorPromise = accumulatorPromise:andThen(function(resolveFunction)
                return foldFunction(resolveFunction, rejectFunction, promiseValue);
            end);
            return ;
        end):andThen(function()
            return accumulatorPromise;
        end);
    end;
    promiseUtils.some = function(traceback, count)
        assertFunction(type(count) == "number", "Bad argument #2 to Promise.some: must be a number");
        return promiseUtils._all(debug.traceback(nil, 2), traceback, count);
    end;
    promiseUtils.any = function(promise)
        return promiseUtils._all(debug.traceback(nil, 2), promise, 1):andThen(function(resolvedValue)
            return resolvedValue[1];
        end);
    end;
    promiseUtils.allSettled = function(promises)
        if type(promises) ~= "table" then
            errorFunction(string.format("Please pass a list of promises to %s", "Promise.allSettled"), 2);
        end;
        for promiseIndex, promiseValue in pairsFunction(promises) do
            if not promiseUtils.is(promiseValue) then
                errorFunction(string.format("Non-promise value passed into %s at index %s", "Promise.allSettled", tostring(promiseIndex)), 2);
            end;
        end;
        if #promises == 0 then
            return promiseUtils.resolve({});
        end;
        return promiseUtils._new(debug.traceback(nil, 2), function(onComplete, L_3825, callback)
            local results = {};
            local cancellablePromises = {};
            local index = 0;
            local resolveAllPromises = function(index, ...)
                index = index + 1;
                results[index] = ...;
                local maxConcurrent = index;
                if #promises <= maxConcurrent then
                    onComplete(results);
                end;
                return ;
            end;
            callback(function()
                for index, cancellablePromise in ipairs(cancellablePromises) do
                    cancellablePromise:cancel();
                end;
                return ;
            end);
            for index, promise in ipairs(promises) do
                cancellablePromises[index] = promise:finally(function(...)
                    resolveAllPromises(index, ...);
                    return ;
                end);
            end;
            return ;
        end);
    end;
    promiseUtils.race = function(promises)
        assertFunction(type(promises) == "table", string.format("Please pass a list of promises to %s", "Promise.race"));
        for promiseIndex, promise in pairsFunction(promises) do
            assertFunction(promiseUtils.is(promise), string.format("Non-promise value passed into %s at index %s", "Promise.race", tostring(promiseIndex)));
        end;
        return promiseUtils._new(debug.traceback(nil, 2), function(promiseValue, rejectFunction, validatorFunction)
            local cancellablePromises = {};
            local isResolved = false;
            local cancelPromises = function()
                for index, promise in ipairs(cancellablePromises) do
                    promise:cancel();
                end;
                return ;
            end;
            local createPromiseWrapper = function(resolveFunction)
                return function(...)
                    cancelPromises();
                    isResolved = true;
                    return resolveFunction(...);
                end;
            end;
            if validatorFunction(createPromiseWrapper(rejectFunction)) then
                return ;
            end;
            for index, promise in ipairs(promises) do
                cancellablePromises[index] = promise:andThen(createPromiseWrapper(promiseValue), createPromiseWrapper(rejectFunction));
            end;
            if isResolved then
                cancelPromises();
            end;
            return ;
        end);
    end;
    promiseUtils.each = function(promises, handlerFunction)
        assertFunction(type(promises) == "table", string.format("Please pass a list of promises to %s", "Promise.each"));
        assertFunction(isFunctionType(handlerFunction), string.format("Please pass a handler function to %s!", "Promise.each"));
        return promiseUtils._new(debug.traceback(nil, 2), function(callbackFunction, reject, cancelCallback)
            local resultsMap = {};
            local promiseList = {};
            local isCancelled = false;
            local cancelAllPromises = function()
                for index, promise in ipairs(promiseList) do
                    promise:cancel();
                end;
                return ;
            end;
            cancelCallback(function()
                isCancelled = true;
                cancelAllPromises();
                return ;
            end);
            local promiseMap = {};
            for index, promise in ipairs(promises) do
                if promiseUtils.is(promise) then
                    if promise:getStatus() == promiseUtils.Status.Cancelled then
                        cancelAllPromises();
                        return reject(PromiseError.new({ error = "Promise is cancelled", kind = PromiseError.Kind.AlreadyCancelled, context = string.format("The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s", index, promise._source) }));
                    end;
                    if promise:getStatus() == promiseUtils.Status.Rejected then
                        cancelAllPromises();
                        return reject(select(2, promise:await()));
                    end;
                    local wrappedPromise = promise:andThen(function(...)
                        return ...;
                    end);
                    table.insert(promiseList, wrappedPromise);
                    promiseMap[index] = wrappedPromise;
                else
                    promiseMap[index] = promise;
                end;
            end;
            for index, promise in ipairs(promiseMap) do
                if promiseUtils.is(promise) then
                    local timeoutHandle = nil;
                    local success, awaitResult = promise:await();
                    local isSuccessful = success;
                    promise = awaitResult;
                    if not isSuccessful then
                        cancelAllPromises();
                        return reject(promise);
                    end;
                end;
                if isCancelled then
                    return ;
                end;
                local resolvedPromise = promiseUtils.resolve(handlerFunction(promise, index));
                table.insert(promiseList, resolvedPromise);
                local success, result = resolvedPromise:await();
                if not success then
                    cancelAllPromises();
                    return reject(result);
                end;
                resultsMap[index] = result;
            end;
            callbackFunction(resultsMap);
            return ;
        end);
    end;
    promiseUtils.is = function(object)
        if type(object) ~= "table" then
            return false;
        end;
        local metatable = getmetatableFunction(object);
        if metatable == promiseUtils then
            return true;
        end;
        if metatable == nil then
            return isFunctionType(object.andThen);
        end;
        if type(metatable) == "table" and type(rawgetFunction(metatable, "__index")) == "table" and isFunctionType(rawgetFunction(rawgetFunction(metatable, "__index"), "andThen")) then
            return true;
        end;
        return false;
    end;
    promiseUtils.promisify = function(callbackFunction)
        return function(...)
            return promiseUtils._try(debug.traceback(nil, 2), callbackFunction, ...);
        end;
    end;
    local timerNode = nil;
    local timeEventConnection = nil;
    promiseUtils.delay = function(delayTime)
        assertFunction(type(delayTime) == "number", "Bad argument #1 to Promise.delay, must be a number.");
        if not (0.016666666666666666 <= delayTime) or delayTime == math.huge then
            delayTime = 0.016666666666666666;
        end;
        return promiseUtils._new(debug.traceback(nil, 2), function(resolve, L_3883, timeoutCallback)
            local startTime = promiseUtils._getTime();
            local endTime = startTime + delayTime;
            local timeEventData = { resolve = resolve, startTime = startTime, endTime = endTime };
            if timeEventConnection == nil then
                timerNode = timeEventData;
                timeEventConnection = promiseUtils._timeEvent:Connect(function()
                    local currentTime = promiseUtils._getTime();
                    while timerNode ~= nil and timerNode.endTime < currentTime do
                        local nextTimeout = timerNode;
                        timerNode = nextTimeout.next;
                        if timerNode == nil then
                            timeEventConnection:Disconnect();
                            timeEventConnection = nil;
                        else
                            timerNode.previous = nil;
                        end;
                        nextTimeout.resolve(promiseUtils._getTime() - nextTimeout.startTime);
                    end;
                    return ;
                end);
            elseif timerNode.endTime < endTime then
                local previousTimeEvent = timerNode;
                local currentTimeEvent = previousTimeEvent.next;
                while currentTimeEvent ~= nil and currentTimeEvent.endTime < endTime do
                    previousTimeEvent = currentTimeEvent;
                    currentTimeEvent = previousTimeEvent.next;
                end;
                previousTimeEvent.next = timeEventData;
                timeEventData.previous = previousTimeEvent;
                if currentTimeEvent ~= nil then
                    timeEventData.next = currentTimeEvent;
                    currentTimeEvent.previous = timeEventData;
                end;
            else
                timeEventData.next = timerNode;
                timerNode.previous = timeEventData;
                timerNode = timeEventData;
            end;
            timeoutCallback(function()
                local nextTimeEvent = timeEventData.next;
                if timerNode == timeEventData then
                    if nextTimeEvent == nil then
                        timeEventConnection:Disconnect();
                        timeEventConnection = nil;
                    else
                        nextTimeEvent.previous = nil;
                    end;
                    timerNode = nextTimeEvent;
                else
                    local previousTimeout = timeEventData.previous;
                    previousTimeout.next = nextTimeEvent;
                    if nextTimeEvent ~= nil then
                        nextTimeEvent.previous = previousTimeout;
                    end;
                end;
                return ;
            end);
            return ;
        end);
    end;
    promiseUtils.prototype.timeout = function(promiseToRace, timeoutDuration, rejectionReason)
        local timeoutTraceback = debug.traceback(nil, 2);
        return promiseUtils.race({
            promiseUtils.delay(timeoutDuration):andThen(function()
                return promiseUtils.reject(rejectionReason == nil and PromiseError.new({ kind = PromiseError.Kind.TimedOut, error = "Timed out", context = string.format("Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s", timeoutDuration, timeoutTraceback) }) or rejectionReason);
            end),
            promiseToRace
        });
    end;
    promiseUtils.prototype.getStatus = function(promiseStatus)
        return promiseStatus._status;
    end;
    promiseUtils.prototype._andThen = function(promise, executor, resolveCallback, rejectCallback)
        promise._unhandledRejection = false;
        if promise._status == promiseUtils.Status.Cancelled then
            local cancellablePromise = promiseUtils.new(function()
                return ;
            end);
            cancellablePromise:cancel();
            return cancellablePromise;
        end;
        return promiseUtils._new(executor, function(successCallback, failureCallback, cleanupCallback)
            local resolveCallback = successCallback;
            if resolveCallback then
                resolveCallback = createPromiseHandler(executor, resolveCallback, successCallback, failureCallback);
            end;
            local rejectCallback = failureCallback;
            if rejectCallback then
                rejectCallback = createPromiseHandler(executor, rejectCallback, successCallback, failureCallback);
            end;
            if promise._status == promiseUtils.Status.Started then
                table.insert(promise._queuedResolve, resolveCallback);
                table.insert(promise._queuedReject, rejectCallback);
                cleanupCallback(function()
                    if promise._status == promiseUtils.Status.Started then
                        table.remove(promise._queuedResolve, table.find(promise._queuedResolve, resolveCallback));
                        table.remove(promise._queuedReject, table.find(promise._queuedReject, rejectCallback));
                    end;
                    return ;
                end);
            elseif promise._status == promiseUtils.Status.Resolved then
                resolveCallback(unpack(promise._values, 1, promise._valuesLength));
            elseif promise._status == promiseUtils.Status.Rejected then
                rejectCallback(unpack(promise._values, 1, promise._valuesLength));
            end;
            return ;
        end, promise);
    end;
    promiseUtils.prototype.andThen = function(promise, onFulfilled, onRejected)
        assertFunction(onFulfilled == nil or isFunctionType(onFulfilled), string.format("Please pass a handler function to %s!", "Promise:andThen"));
        assertFunction(onRejected == nil or isFunctionType(onRejected), string.format("Please pass a handler function to %s!", "Promise:andThen"));
        return promise:_andThen(debug.traceback(nil, 2), onFulfilled, onRejected);
    end;
    promiseUtils.prototype.catch = function(promiseObject, onCatch)
        assertFunction(onCatch == nil or isFunctionType(onCatch), string.format("Please pass a handler function to %s!", "Promise:catch"));
        return promiseObject:_andThen(debug.traceback(nil, 2), nil, onCatch);
    end;
    promiseUtils.prototype.tap = function(promise, tapHandler)
        assertFunction(isFunctionType(tapHandler), string.format("Please pass a handler function to %s!", "Promise:tap"));
        return promise:_andThen(debug.traceback(nil, 2), function(...)
            local tapResult = tapHandler(...);
            if promiseUtils.is(tapResult) then
                local numArgs, args = selectArguments(...);
                return tapResult:andThen(function()
                    return unpack(args, 1, numArgs);
                end);
            end;
            return ...;
        end);
    end;
    promiseUtils.prototype.andThenCall = function(promise, andThenCallHandler, ...)
        assertFunction(isFunctionType(andThenCallHandler), string.format("Please pass a handler function to %s!", "Promise:andThenCall"));
        local numArgsAndThenCall, argsAndThenCall = selectArguments(...);
        return promise:_andThen(debug.traceback(nil, 2), function()
            return andThenCallHandler(unpack(argsAndThenCall, 1, numArgsAndThenCall));
        end);
    end;
    promiseUtils.prototype.andThenReturn = function(promise, ...)
        local numArgsFinally, argsFinally = selectArguments(...);
        return promise:_andThen(debug.traceback(nil, 2), function()
            return unpack(argsFinally, 1, numArgsFinally);
        end);
    end;
    promiseUtils.prototype.cancel = function(promiseObject)
        if promiseObject._status ~= promiseUtils.Status.Started then
            return ;
        end;
        promiseObject._status = promiseUtils.Status.Cancelled;
        if promiseObject._cancellationHook then
            promiseObject._cancellationHook();
        end;
        coroutine.close(promiseObject._thread);
        if promiseObject._parent then
            promiseObject._parent:_consumerCancelled(promiseObject);
        end;
        for consumerIndex, consumer in pairsFunction(promiseObject._consumers) do
            consumerIndex:cancel();
        end;
        promiseObject:_finalize();
        return ;
    end;
    promiseUtils.prototype._consumerCancelled = function(promise, consumerKey)
        if promise._status ~= promiseUtils.Status.Started then
            return ;
        end;
        promise._consumers[consumerKey] = nil;
        if next(promise._consumers) == nil then
            promise:cancel();
        end;
        return ;
    end;
    promiseUtils.prototype._finally = function(promiseFinally, executor, transformFunction)
        promiseFinally._unhandledRejection = false;
        return promiseUtils._new(executor, function(resolveFinally, promiseResolveHandler, cancellationCallback)
            local finallyPromise = nil;
            cancellationCallback(function()
                promiseFinally:_consumerCancelled(promiseFinally);
                if finallyPromise then
                    finallyPromise:cancel();
                end;
                return ;
            end);
            local finallyHandler = resolveFinally;
            if transformFunction then
                finallyHandler = function(...)
                    local finallyResult = transformFunction(...);
                    if promiseUtils.is(finallyResult) then
                        finallyPromise = finallyResult;
                        finallyResult:finally(function(finallyStatus)
                            if finallyStatus ~= promiseUtils.Status.Rejected then
                                resolveFinally(promiseFinally);
                            end;
                            return ;
                        end):catch(function(...)
                            promiseResolveHandler(...);
                            return ;
                        end);
                    else
                        resolveFinally(promiseFinally);
                    end;
                    return ;
                end;
            end;
            if promiseFinally._status == promiseUtils.Status.Started then
                table.insert(promiseFinally._queuedFinally, finallyHandler);
            else
                finallyHandler(promiseFinally._status);
            end;
            return ;
        end);
    end;
    promiseUtils.prototype.finally = function(promiseObject, onFinally)
        assertFunction(onFinally == nil or isFunctionType(onFinally), string.format("Please pass a handler function to %s!", "Promise:finally"));
        return promiseObject:_finally(debug.traceback(nil, 2), onFinally);
    end;
    promiseUtils.prototype.finallyCall = function(promise, handlerFunction, ...)
        assertFunction(isFunctionType(handlerFunction), string.format("Please pass a handler function to %s!", "Promise:finallyCall"));
        local valuesLength, values = selectArguments(...);
        return promise:_finally(debug.traceback(nil, 2), function()
            return handlerFunction(unpack(values, 1, valuesLength));
        end);
    end;
    promiseUtils.prototype.finallyReturn = function(promise, ...)
        local valuesLength, values = selectArguments(...);
        return promise:_finally(debug.traceback(nil, 2), function()
            return unpack(values, 1, valuesLength);
        end);
    end;
    promiseUtils.prototype.awaitStatus = function(promise)
        promise._unhandledRejection = false;
        if promise._status == promiseUtils.Status.Started then
            local currentCoroutine = coroutine.running();
            promise:finally(function()
                task.spawn(currentCoroutine);
                return ;
            end):catch(function()
                return ;
            end);
            coroutine.yield();
        end;
        if promise._status == promiseUtils.Status.Resolved then
            return promise._status, unpack(promise._values, 1, promise._valuesLength);
        end;
        if promise._status == promiseUtils.Status.Rejected then
            return promise._status, unpack(promise._values, 1, promise._valuesLength);
        end;
        return promise._status;
    end;
    local isResolvedFunction = function(status, ...)
        return status == promiseUtils.Status.Resolved, ...;
    end;
    promiseUtils.prototype.await = function(statusCheckFunction)
        return isResolvedFunction(statusCheckFunction:awaitStatus());
    end;
    local handleRejectionFunction = function(promiseStatus, ...)
        if promiseStatus ~= promiseUtils.Status.Resolved then
            errorFunction(... == nil and "Expected Promise rejected with no value." or ..., 3);
        end;
        return ...;
    end;
    promiseUtils.prototype.expect = function(statusCheckFunction)
        return handleRejectionFunction(statusCheckFunction:awaitStatus());
    end;
    promiseUtils.prototype.awaitValue = promiseUtils.prototype.expect;
    promiseUtils.prototype._unwrap = function(promise)
        if promise._status == promiseUtils.Status.Started then
            errorFunction("Promise has not resolved or rejected.", 2);
        end;
        return promise._status == promiseUtils.Status.Resolved, unpack(promise._values, 1, promise._valuesLength);
    end;
    promiseUtils.prototype._resolve = function(newPromise, ...)
        if newPromise._status ~= promiseUtils.Status.Started then
            if promiseUtils.is((...)) then
                (...):_consumerCancelled(newPromise);
            end;
            return ;
        end;
        if promiseUtils.is((...)) then
            if 1 < select("#", ...) then
                local andThenWarning = string.format("When returning a Promise from andThen, extra arguments are discarded! See:\n\n%s", newPromise._source);
                warn(andThenWarning);
            end;
            local previousPromise = ...;
            local chainedPromise = previousPromise:andThen(function(...)
                newPromise:_resolve(...);
                return ;
            end, function(...)
                local rejectionError = previousPromise._values[1];
                if previousPromise._error then
                    rejectionError = PromiseError.new({ error = previousPromise._error, kind = PromiseError.Kind.ExecutionError, context = "[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]" });
                end;
                if PromiseError.isKind(rejectionError, PromiseError.Kind.ExecutionError) then
                    return newPromise:_reject(rejectionError:extend({ error = "This Promise was chained to a Promise that errored.", trace = "", context = string.format("The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n", newPromise._source) }));
                end;
                newPromise:_reject(...);
                return ;
            end);
            if chainedPromise._status == promiseUtils.Status.Cancelled then
                newPromise:cancel();
            elseif chainedPromise._status == promiseUtils.Status.Started then
                newPromise._parent = chainedPromise;
                chainedPromise._consumers[newPromise] = true;
            end;
            return ;
        end;
        newPromise._status = promiseUtils.Status.Resolved;
        local valuesLength, values = selectArguments(...);
        newPromise._valuesLength = valuesLength;
        newPromise._values = values;
        for resolveIndex, resolveCallback in ipairs(newPromise._queuedResolve) do
            coroutine.wrap(resolveCallback)(...);
        end;
        newPromise:_finalize();
        return ;
    end;
    promiseUtils.prototype._reject = function(promise, ...)
        if promise._status ~= promiseUtils.Status.Started then
            return ;
        end;
        promise._status = promiseUtils.Status.Rejected;
        local valuesLength, values = selectArguments(...);
        promise._valuesLength = valuesLength;
        promise._values = values;
        if not isTableEmpty(promise._queuedReject) then
            for index, rejectCallback in ipairs(promise._queuedReject) do
                coroutine.wrap(rejectCallback)(...);
            end;
        else
            local errorMessageString = tostring((...));
            coroutine.wrap(function()
                promiseUtils._timeEvent:Wait();
                if not promise._unhandledRejection then
                    return ;
                end;
                local unhandledRejectionMessage = string.format("Unhandled Promise rejection:\n\n%s\n\n%s", errorMessageString, promise._source);
                for callbackIndex, callback in ipairs(promiseUtils._unhandledRejectionCallbacks) do
                    task.spawn(callback, promise, unpack(promise._values, 1, promise._valuesLength));
                end;
                if promiseUtils.TEST then
                    return ;
                end;
                warn(unhandledRejectionMessage);
                return ;
            end)();
        end;
        promise:_finalize();
        return ;
    end;
    promiseUtils.prototype._finalize = function(promise)
        for index, finallyCallback in ipairs(promise._queuedFinally) do
            coroutine.wrap(finallyCallback)(promise._status);
        end;
        promise._queuedFinally = nil;
        promise._queuedReject = nil;
        promise._queuedResolve = nil;
        if not promiseUtils.TEST then
            promise._parent = nil;
            promise._consumers = nil;
        end;
        task.defer(coroutine.close, promise._thread);
        return ;
    end;
    promiseUtils.prototype.now = function(promiseObject, rejectionReason)
        local tracebackString = debug.traceback(nil, 2);
        if promiseObject._status == promiseUtils.Status.Resolved then
            return promiseObject:_andThen(tracebackString, function(...)
                return ...;
            end);
        end;
        return promiseUtils.reject(rejectionReason == nil and PromiseError.new({ kind = PromiseError.Kind.NotResolvedInTime, error = "This Promise was not resolved in time for :now()", context = ":now() was called at:\n\n" .. tracebackString }) or rejectionReason);
    end;
    promiseUtils.retry = function(retryFunction, retryCount, ...)
        assertFunction(isFunctionType(retryFunction), "Parameter #1 to Promise.retry must be a function");
        assertFunction(type(retryCount) == "number", "Parameter #2 to Promise.retry must be a number");
        local retryArguments = { ... };
        local argumentCount = select("#", ...);
        return promiseUtils.resolve(retryFunction(...)):catch(function(...)
            if 0 < retryCount then
                return promiseUtils.retry(retryFunction, retryCount - 1, unpack(retryArguments, 1, argumentCount));
            end;
            return promiseUtils.reject(...);
        end);
    end;
    promiseUtils.retryWithDelay = function(retryFunction, retryCount, delaySeconds, ...)
        assertFunction(isFunctionType(retryFunction), "Parameter #1 to Promise.retry must be a function");
        assertFunction(type(retryCount) == "number", "Parameter #2 (times) to Promise.retry must be a number");
        assertFunction(type(delaySeconds) == "number", "Parameter #3 (seconds) to Promise.retry must be a number");
        local retryWithDelayArguments = { ... };
        local argumentCount = select("#", ...);
        return promiseUtils.resolve(retryFunction(...)):catch(function(...)
            if 0 < retryCount then
                promiseUtils.delay(delaySeconds):await();
                return promiseUtils.retryWithDelay(retryFunction, retryCount - 1, delaySeconds, unpack(retryWithDelayArguments, 1, argumentCount));
            end;
            return promiseUtils.reject(...);
        end);
    end;
    promiseUtils.fromEvent = function(eventConnection, predicateFunction)
        local predicateFunction = predicateFunction or function()
            return true;
        end;
        return promiseUtils._new(debug.traceback(nil, 2), function(callbackFunction, L_3996, callbackFunction)
            local eventConnection = nil;
            local isPromiseResolved = false;
            local disconnectEventFunction = function()
                eventConnection:Disconnect();
                eventConnection = nil;
                return ;
            end;
            eventConnection = eventConnection:Connect(function(...)
                local predicateResult = predicateFunction(...);
                if predicateResult == true then
                    callbackFunction(...);
                    if eventConnection then
                        disconnectEventFunction();
                    else
                        isPromiseResolved = true;
                    end;
                elseif type(predicateResult) ~= "boolean" then
                    errorFunction("Promise.fromEvent predicate should always return a boolean");
                end;
                return ;
            end);
            if isPromiseResolved and eventConnection then
                return disconnectEventFunction();
            end;
            callbackFunction(disconnectEventFunction);
            return ;
        end);
    end;
    promiseUtils.onUnhandledRejection = function(unhandledRejectionCallback)
        table.insert(promiseUtils._unhandledRejectionCallbacks, unhandledRejectionCallback);
        return function()
            local callbackIndexInList = table.find(promiseUtils._unhandledRejectionCallbacks, unhandledRejectionCallback);
            if callbackIndexInList then
                table.remove(promiseUtils._unhandledRejectionCallbacks, callbackIndexInList);
            end;
            return ;
        end;
    end;
    return promiseUtils;
end);
registerModule("RuntimeLib", "ModuleScript", "rbxts-bundle-example.include.RuntimeLib", "rbxts-bundle-example.include", function()
    local runtimeLibModule = getModuleGlobals("rbxts-bundle-example.include.RuntimeLib");
    local runtimeLibScript = runtimeLibModule.script;
    local runtimeLibRequire = runtimeLibModule.require;
    local promiseModule = runtimeLibRequire(runtimeLibScript.Parent.Promise);
    local runService = game:GetService("RunService");
    local robloxTs = { Promise = promiseModule };
    local isPluginDescendantFunction = function(instance)
        return runService:IsStudio() and instance:FindFirstAncestorWhichIsA("Plugin") ~= nil;
    end;
    robloxTs.getModule = function(module, moduleScope, moduleName)
        if moduleName == nil then
            moduleName = moduleScope;
            moduleScope = "@rbxts";
        end;
        if runService:IsRunning() and runService:IsClient() and not isPluginDescendantFunction(module) and not game:IsLoaded() then
            game.Loaded:Wait();
        end;
        local ancestorInstance = module;
        repeat
            local nodeModulesFolder = ancestorInstance:FindFirstChild("node_modules");
            if nodeModulesFolder then
                local moduleFolder = nodeModulesFolder:FindFirstChild(moduleScope);
                if moduleFolder then
                    local moduleScript = moduleFolder:FindFirstChild(moduleName);
                    if moduleScript then
                        return moduleScript;
                    end;
                end;
            end;
            ancestorInstance = ancestorInstance.Parent;
        until ancestorInstance == nil;
        errorFunction("roblox-ts: " .. ("Could not find module: " .. moduleName), 2);
        return ;
    end;
    local moduleCache = {};
    local moduleCache = {};
    robloxTs.import = function(key, moduleScript, ...)
        for index = 1, select("#", ...), 1 do
            moduleScript = moduleScript:WaitForChild((select(index, ...)));
        end;
        if moduleScript.ClassName ~= "ModuleScript" then
            errorFunction("roblox-ts: " .. ("Failed to import! Expected ModuleScript, got " .. moduleScript.ClassName), 2);
        end;
        moduleCache[key] = moduleScript;
        local currentModule = moduleScript;
        local ancestorCount = 0;
        while currentModule do
            ancestorCount = ancestorCount + 1;
            currentModule = moduleCache[currentModule];
            if currentModule == moduleScript then
                local dependencyChain = currentModule.Name;
                for i = 1, ancestorCount, 1 do
                    currentModule = moduleCache[currentModule];
                    dependencyChain = dependencyChain .. ("  \226\135\146 " .. currentModule.Name);
                end;
                errorFunction("roblox-ts: " .. ("Failed to import! Detected a circular dependency chain: " .. dependencyChain), 2);
            end;
        end;
        if not moduleCache[moduleScript] then
            if _G[moduleScript] then
                errorFunction("roblox-ts: " .. ("Invalid module access! Do you have multiple TS runtimes trying to import this? " .. moduleScript:GetFullName()), 2);
            end;
            _G[moduleScript] = robloxTs;
            moduleCache[moduleScript] = true;
        end;
        local requireResult = runtimeLibRequire(moduleScript);
        if moduleCache[key] == moduleScript then
            moduleCache[key] = nil;
        end;
        return requireResult;
    end;
    robloxTs.instanceof = function(instance, constructor)
        if type(constructor) == "table" and type(constructor.instanceof) == "function" then
            return constructor.instanceof(instance);
        end;
        if type(instance) == "table" then
            local metatable = getmetatableFunction(instance);
            while metatable ~= nil do
                if metatable == constructor then
                    return true;
                end;
                local metatable = getmetatableFunction(metatable);
                if metatable then
                    metatable = metatable.__index;
                else
                    metatable = nil;
                end;
            end;
        end;
        return false;
    end;
    robloxTs.async = function(callback)
        return function(...)
            local argumentCount = select("#", ...);
            local argumentsTable = { ... };
            return promiseModule.new(function(errCallback, callbackFunction)
                coroutine.wrap(function()
                    local success, result = pcall(callback, unpack(argumentsTable, 1, argumentCount));
                    if success then
                        errCallback(result);
                    else
                        callbackFunction(result);
                    end;
                    return ;
                end)();
                return ;
            end);
        end;
    end;
    robloxTs.await = function(promise)
        if not promiseModule.is(promise) then
            return promise;
        end;
        local promiseStatus, promiseValue = promise:awaitStatus();
        if promiseStatus == promiseModule.Status.Resolved then
            return promiseValue;
        end;
        if promiseStatus == promiseModule.Status.Rejected then
            errorFunction(promiseValue, 2);
        else
            errorFunction("The awaited Promise was cancelled", 2);
        end;
        return ;
    end;
    local convertToInt32 = function(value)
        if bit32Library.btest(value, 2147483648) then
            return value - 4294967296;
        end;
        return value;
    end;
    robloxTs.bit_lrsh = function(numberValue, bitShiftAmount)
        return convertToInt32(bit32Library.arshift(numberValue, bitShiftAmount));
    end;
    robloxTs.TRY_RETURN = 1;
    robloxTs.TRY_BREAK = 2;
    robloxTs.TRY_CONTINUE = 3;
    robloxTs.try = function(functionToCall, callbackFunction, customHandler)
        local successCall, resultCall, errorMessage = pcall(functionToCall);
        local tryResult = nil;
        local message = nil;
        if successCall then
            tryResult = resultCall;
        else
            message = resultCall;
        end;
        local success = true;
        local errorValue = nil;
        if not successCall and callbackFunction then
            local stack = nil;
            local pcallResult = nil;
            local pcallSuccess, pcallResult, pcallError = pcall(callbackFunction, message);
            success = pcallSuccess;
            local resultValue = pcallResult;
            local errorMessage = pcallError;
            local successResult = nil;
            if success then
                successResult = resultValue;
            else
                errorValue = resultValue;
            end;
            if successResult then
                tryResult = successResult;
                errorMessage = errorMessage;
            end;
        end;
        if customHandler then
            local functionSuccess, functionResult = customHandler();
            if functionSuccess then
                tryResult = functionSuccess;
                errorMessage = functionResult;
            end;
        end;
        if tryResult ~= robloxTs.TRY_RETURN and tryResult ~= robloxTs.TRY_BREAK and tryResult ~= robloxTs.TRY_CONTINUE then
            if not success then
                errorFunction(errorValue, 2);
            end;
            if not successCall and not callbackFunction then
                errorFunction(message, 2);
            end;
        end;
        return tryResult, errorMessage;
    end;
    robloxTs.generator = function(coroutineFunction)
        local coroutineThread = coroutine.create(coroutineFunction);
        return {
            next = function(...)
                if coroutine.status(coroutineThread) == "dead" then
                    return { done = true };
                end;
                local coroutineSuccess, coroutineResult = coroutine.resume(coroutineThread, ...);
                if coroutineSuccess == false then
                    errorFunction(coroutineResult, 2);
                end;
                return { value = coroutineResult, done = coroutine.status(coroutineThread) == "dead" };
            end
        };
    end;
    return robloxTs;
end);
createInstance("node_modules", "Folder", "rbxts-bundle-example.include.node_modules", "rbxts-bundle-example.include");
createInstance("@rbxts", "Folder", "rbxts-bundle-example.include.node_modules.@rbxts", "rbxts-bundle-example.include.node_modules");
createInstance("compiler-types", "Folder", "rbxts-bundle-example.include.node_modules.@rbxts.compiler-types", "rbxts-bundle-example.include.node_modules.@rbxts");
createInstance("types", "Folder", "rbxts-bundle-example.include.node_modules.@rbxts.compiler-types.types", "rbxts-bundle-example.include.node_modules.@rbxts.compiler-types");
createInstance("types", "Folder", "rbxts-bundle-example.include.node_modules.@rbxts.types", "rbxts-bundle-example.include.node_modules.@rbxts");
createInstance("include", "Folder", "rbxts-bundle-example.include.node_modules.@rbxts.types.include", "rbxts-bundle-example.include.node_modules.@rbxts.types");
createInstance("generated", "Folder", "rbxts-bundle-example.include.node_modules.@rbxts.types.include.generated", "rbxts-bundle-example.include.node_modules.@rbxts.types.include");
initializeLocalScripts();
return ;